<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>emplace_back()</title>
      <link href="/2024/04/09/emplace-back/"/>
      <url>/2024/04/09/emplace-back/</url>
      
        <content type="html"><![CDATA[<h2 id="emplace-back"><a href="#emplace-back" class="headerlink" title="emplace_back( )"></a>emplace_back( )</h2><p>在容器末尾添加一个新元素，它通常使用 placement-new 在容器提供的位置就地构造元素。</p><p>通常要保证操作后的size不大于旧的capacity（end迭代器要重新生成），否则需要重新分配内存，这种情况下所有迭代器和对元素的所有引用都会失效。</p><p>下面代码是从cpp reference抄来的，理解一下怎么运行的。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cassert&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">President</span></span><br><span class="line">&#123;</span><br><span class="line">    std::string name;</span><br><span class="line">    std::string country;</span><br><span class="line">    <span class="type">int</span> year;</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">President</span>(std::string p_name, std::string p_country, <span class="type">int</span> p_year)</span><br><span class="line">        : <span class="built_in">name</span>(std::<span class="built_in">move</span>(p_name)), <span class="built_in">country</span>(std::<span class="built_in">move</span>(p_country)), <span class="built_in">year</span>(p_year)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;I am being constructed.\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">President</span>(President&amp;&amp; other)</span><br><span class="line">        : <span class="built_in">name</span>(std::<span class="built_in">move</span>(other.name)), <span class="built_in">country</span>(std::<span class="built_in">move</span>(other.country)), <span class="built_in">year</span>(other.year)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;I am being moved.\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    President&amp; <span class="keyword">operator</span>=(<span class="type">const</span> President&amp; other) = <span class="keyword">default</span>;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::vector&lt;President&gt; elections;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;emplace_back:\n&quot;</span>;</span><br><span class="line">    <span class="keyword">auto</span>&amp; ref = elections.<span class="built_in">emplace_back</span>(<span class="string">&quot;Nelson Mandela&quot;</span>, <span class="string">&quot;South Africa&quot;</span>, <span class="number">1994</span>);</span><br><span class="line">    <span class="built_in">assert</span>(ref.year == <span class="number">1994</span> &amp;&amp; <span class="string">&quot;uses a reference to the created object (C++17)&quot;</span>);</span><br><span class="line"> </span><br><span class="line">    std::vector&lt;President&gt; reElections;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;\npush_back:\n&quot;</span>;</span><br><span class="line">    reElections.<span class="built_in">push_back</span>(<span class="built_in">President</span>(<span class="string">&quot;Franklin Delano Roosevelt&quot;</span>, <span class="string">&quot;the USA&quot;</span>, <span class="number">1936</span>));</span><br><span class="line"> </span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;\nContents:\n&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (President <span class="type">const</span>&amp; president: elections)</span><br><span class="line">        std::cout &lt;&lt; president.name &lt;&lt; <span class="string">&quot; was elected president of &quot;</span></span><br><span class="line">                  &lt;&lt; president.country &lt;&lt; <span class="string">&quot; in &quot;</span> &lt;&lt; president.year &lt;&lt; <span class="string">&quot;.\n&quot;</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">for</span> (President <span class="type">const</span>&amp; president: reElections)</span><br><span class="line">        std::cout &lt;&lt; president.name &lt;&lt; <span class="string">&quot; was re-elected president of &quot;</span></span><br><span class="line">                  &lt;&lt; president.country &lt;&lt; <span class="string">&quot; in &quot;</span> &lt;&lt; president.year &lt;&lt; <span class="string">&quot;.\n&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面的是Output：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">emplace_back:</span><br><span class="line">I am being constructed.</span><br><span class="line"> </span><br><span class="line">push_back:</span><br><span class="line">I am being constructed.</span><br><span class="line">I am being moved.</span><br><span class="line"> </span><br><span class="line">Contents:</span><br><span class="line">Nelson Mandela was elected president of South Africa in 1994.</span><br><span class="line">Franklin Delano Roosevelt was re-elected president of the USA in 1936.</span><br></pre></td></tr></table></figure><h2 id="解析代码"><a href="#解析代码" class="headerlink" title="解析代码"></a>解析代码</h2><h3 id="default"><a href="#default" class="headerlink" title="= default"></a>= default</h3><p><code>President&amp; operator=(const President&amp; other) = default;</code></p><p>这串代码里的<code>= default</code>使得编译器将会提供该函数的默认实现，并且保证这些默认实现不会被删除；构造函数和析构函数将提供默认的空实现。</p><p>作用：</p><p>1、生成默认实现：当一个类没有显式定义构造函数或析构函数时，编译器会自动生成默认的构造函数或析构函数。如果我们在类中使用了default关键字，则可以显式地告诉编译器使用默认的实现。</p><p>2、防止默认实现被删除：在某些情况下，编译器不会生成默认的构造函数或析构函数，例如当类包含了一个用户自定义的构造函数或析构函数时。如果我们想要让编译器生成默认的实现，可以在类定义中使用default关键字来显式声明默认的构造函数或析构函数。（例子里属于这种）</p><h3 id="std-move"><a href="#std-move" class="headerlink" title="std : : move"></a>std : : move</h3><p><code>name(std::move(p_name))</code>这里的p_name作为一个右值，通过std::move绑定左值name，相当于构造函数里给name赋值。</p><h3 id="构造函数President"><a href="#构造函数President" class="headerlink" title="构造函数President"></a>构造函数President</h3><p>这里构造函数有两种手动实现，第一种直接传入三个参数构造，第二种传入类other再构造，通过输出很容易发现，通过emplace_back构造的函数直接通过第一种构造，传入参数，不需要生成类再拷贝。</p><p>通过push_back的输出发现，会先构造President类，再通过第二种构造拷贝构造，需要两步。</p><h3 id="c-11的for"><a href="#c-11的for" class="headerlink" title="c++11的for"></a>c++11的for</h3><p><code>for (President const&amp; president: elections)</code></p><p>先定义一个变量，这里是president，然后从序列elections一个一个取出全部元素循环。（例子里这里只有一个President变量elections，只循环一次，将elections作为president取出）。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这段代码就是让你看透emplace_back和push_back添加元素的本质区别。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>栈和寄存器</title>
      <link href="/2024/04/09/%E6%A0%88%E5%92%8C%E5%AF%84%E5%AD%98%E5%99%A8/"/>
      <url>/2024/04/09/%E6%A0%88%E5%92%8C%E5%AF%84%E5%AD%98%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="0x01-寄存器和栈"><a href="#0x01-寄存器和栈" class="headerlink" title="0x01 寄存器和栈"></a>0x01 寄存器和栈</h2><p><img src="../../../Hexo_Blog/blog-demo/source/Images/image-20240409170718620.png" alt="image-20240409170718620"></p><h3 id="被调用者保护"><a href="#被调用者保护" class="headerlink" title="被调用者保护"></a>被调用者保护</h3><p><code>%rbp</code> 和<code>%r12~15</code></p><p>被调用者保护的寄存器在进入一个函数后会先压入栈来保存原先的值</p><h3 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h3><p><code>%rax</code></p><p>寄存器rax通常存储着一个函数的返回值</p><h3 id="调用者保护"><a href="#调用者保护" class="headerlink" title="调用者保护"></a>调用者保护</h3><p>除被调用者保护外。</p><p>和被调用者保护相反，可以随意修改该寄存器里的值而不需要压入栈来保存</p><h3 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h3><p><code>%rdi,%rsi,%rdx,%rcx,%r8,%r9</code></p><p>这里默认有六个参数寄存器，在传入函数时使用，超过的参数将在栈帧上保存</p><h3 id="栈指针"><a href="#栈指针" class="headerlink" title="栈指针"></a>栈指针</h3><p><code>%rsp</code></p><p>指示着栈顶的位置，栈往低处生长</p><h2 id="0x02-运行时栈"><a href="#0x02-运行时栈" class="headerlink" title="0x02 运行时栈"></a>0x02 运行时栈</h2><p><img src="../../../Hexo_Blog/blog-demo/source/Images/image-20240409171340649.png" alt="image-20240409171340649"></p><h3 id="返回地址"><a href="#返回地址" class="headerlink" title="返回地址"></a>返回地址</h3><p>在进入一个函数前，先将该call该函数的指令的下一条指令的地址压入栈，当执行ret指令时将该返回地址从栈中弹出，作为%rip的值（下一条执行指令的地址）</p><h3 id="被保存的寄存器"><a href="#被保存的寄存器" class="headerlink" title="被保存的寄存器"></a>被保存的寄存器</h3><p>对应寄存器中的被调用者保护寄存器，进入函数前先保存。</p><h3 id="局部变量"><a href="#局部变量" class="headerlink" title="局部变量"></a>局部变量</h3><p>有时，局部数据必须存放在内存中，常见的情况包括：</p><p>1、寄存器不足够存放所有的本地数据。</p><p>2、对一个局部变量使用地址运算符＇＆＇，因此必须能够为它产生一个地址</p><p>3、某些局部变量是数组或结构，因此必须能够通过数组或结构引用被访问到 </p><h3 id="参数构造区"><a href="#参数构造区" class="headerlink" title="参数构造区"></a>参数构造区</h3><p>当传入的函数的参数超过六个（对应六个参数寄存器）时，需要在call之前先在栈顶构造参数，存储在栈上，使得调用的函数通过栈指针来读取参数。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 基础 </tag>
            
            <tag> cum15-213 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>结构体数据类型所占字节长度</title>
      <link href="/2024/04/09/%E7%BB%93%E6%9E%84%E4%BD%93%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%9A%84%E6%89%80%E5%8D%A0%E5%AD%97%E8%8A%82%E9%95%BF%E5%BA%A6/"/>
      <url>/2024/04/09/%E7%BB%93%E6%9E%84%E4%BD%93%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%9A%84%E6%89%80%E5%8D%A0%E5%AD%97%E8%8A%82%E9%95%BF%E5%BA%A6/</url>
      
        <content type="html"><![CDATA[<p>记录一下结构体的数据类型大小怎么算，主要看对齐数和地址偏移量</p><h2 id="计算原理"><a href="#计算原理" class="headerlink" title="计算原理"></a>计算原理</h2><p>举个例子</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">student</span> &#123;</span><br><span class="line"><span class="type">int</span> num;</span><br><span class="line"><span class="type">char</span> name[<span class="number">10</span>];<span class="comment">//8 byte</span></span><br><span class="line"><span class="type">int</span> com, math, english;</span><br><span class="line"><span class="type">double</span> average;<span class="comment">//8 byte</span></span><br><span class="line">&#125; stu;</span><br><span class="line">stu boy[<span class="number">1000</span>], * p;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">std::cout &lt;&lt; <span class="built_in">sizeof</span>(stu)&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">std::cout &lt;&lt; <span class="built_in">sizeof</span>(<span class="type">int</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对齐数的大小，在vs编译器里，是数据类型大小和默认对齐数（vs是8）的最小值。</p><p>从第二个数据开始，数据首个字节的地址的偏移量要为对齐数的整数倍</p><p>对于数据类型stu，num先填充4 bytes，之后第二个char name[10]的对齐数是10和8的较小值，为8 bytes，首地址应为8的整数倍的偏移地址量，最小为8，所以从8开始存放name，</p><p>第三个数据还是int，现在已经填充了num，4个0xcc，name，加起来偏移地址为18，int对齐数是4，再填充两个0xcc，从偏移地址20开始填充三个int，20+12=32，</p><p>第四个数据是double，对齐数是其64位的大小，8bytes，32是8的整数倍，可以直接填入，加起来是40，所以sizeof(stu) 的大小是40</p><p><img src="https://img-blog.csdnimg.cn/direct/430208b28b1148d99a4e0b1d209590c4.png" alt="img" style="zoom:50%;" /></p><p>数组的情况是同理的，把他看成几个连续的单个数据算就好了</p><h2 id="当结构体中有其他结构体"><a href="#当结构体中有其他结构体" class="headerlink" title="当结构体中有其他结构体"></a>当结构体中有其他结构体</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">student</span> &#123;</span><br><span class="line"><span class="type">int</span> num;</span><br><span class="line"><span class="type">char</span> name[<span class="number">10</span>];<span class="comment">//8 byte</span></span><br><span class="line"><span class="type">int</span> com, math, english;</span><br><span class="line"><span class="type">double</span> average;<span class="comment">//8 byte</span></span><br><span class="line">&#125; stu;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">cls</span> &#123;</span><br><span class="line"><span class="type">int</span> class_number;</span><br><span class="line">stu one;</span><br><span class="line">&#125;;</span><br><span class="line">stu boy[<span class="number">1000</span>], * p;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">std::cout &lt;&lt; <span class="built_in">sizeof</span>(stu)&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">std::cout &lt;&lt; <span class="built_in">sizeof</span>(cls);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>stu one 需要从其结构体内部数据的最大对齐数的整数倍的地址偏移量开始，这里内部最大是8，所以应该从cls里的地址偏移量为8开始存储，就是40+8=48。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数学公式编辑</title>
      <link href="/2024/04/07/%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F%E5%A4%A7%E5%85%A8/"/>
      <url>/2024/04/07/%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F%E5%A4%A7%E5%85%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="0x01-前言"><a href="#0x01-前言" class="headerlink" title="0x01 前言"></a>0x01 前言</h2><p>打算记录一些数学题目，发现不会编辑数学公式，遂记录。</p><p>编辑数学公式前，要将其囊括在首尾两个美元符号的大括号中。</p><h2 id="0x02-常用符号"><a href="#0x02-常用符号" class="headerlink" title="0x02 常用符号"></a>0x02 常用符号</h2><p>整合一些常用的符号例如古希腊字母，积分符号，求和符号等等。</p><h3 id="古希腊字母"><a href="#古希腊字母" class="headerlink" title="古希腊字母"></a>古希腊字母</h3><p><img src="/Images/image-20240402181057758.png" alt="image-20240402181057758"></p><h3 id="各种运算符号"><a href="#各种运算符号" class="headerlink" title="各种运算符号"></a>各种运算符号</h3><p><img src="/Images/image-20240402181435055.png" alt="image-20240402181435055"></p><h3 id="三角函数和对数"><a href="#三角函数和对数" class="headerlink" title="三角函数和对数"></a>三角函数和对数</h3><p>只需要在反斜杠后加上对应字母表示</p><p>补充一下圆周率是pi</p><h3 id="向量符号和根号等"><a href="#向量符号和根号等" class="headerlink" title="向量符号和根号等"></a>向量符号和根号等</h3><p><img src="/Images/image-20240402181724770.png" alt="image-20240402181724770"></p><h3 id="调整大小"><a href="#调整大小" class="headerlink" title="调整大小"></a>调整大小</h3><p>主要是math mode</p><p><img src="/Images/image-20240402181825954.png" alt="image-20240402181825954"></p><h2 id="0x03-基本编辑方法"><a href="#0x03-基本编辑方法" class="headerlink" title="0x03 基本编辑方法"></a>0x03 基本编辑方法</h2><p>记录一些数学公式编辑方法</p><h3 id="如何输入上下标"><a href="#如何输入上下标" class="headerlink" title="如何输入上下标"></a>如何输入上下标</h3><p><code>^</code> 表示上表，<code>_</code> 表示下标，如果上下标的内容多于一个字符，需要用 <code>&#123;&#125;</code>将这些内容括成一个整体</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$&#123;e&#123;^x_y&#125;=(x+2)^5&#125;$</span><br></pre></td></tr></table></figure><p>​                                                                 ${e{^x_y}=(x+2)^5}$</p><h3 id="如何显示分数"><a href="#如何显示分数" class="headerlink" title="如何显示分数"></a>如何显示分数</h3><p>通常使用 <code>\frac &#123;分子&#125; &#123;分母&#125;</code> 来生成一个分数，分数可多层嵌套。如果分式较为复杂，亦可使用 <code>分子 \over 分母</code> 此时分数仅有一层                                </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$&#123;\frac&#123;x+1&#125;&#123;y+1&#125;=\frac xy&#125;$</span><br></pre></td></tr></table></figure><p>​                                                                    ${\frac{x+1} {y+1}=\frac xy}$</p><p>或者使用<code>\frac ab</code>快速生成一个a/b</p><h3 id="如何输入省略号"><a href="#如何输入省略号" class="headerlink" title="如何输入省略号"></a>如何输入省略号</h3><p>数学公式中常见的省略号有两种，<code>\ldots</code> 表示与 <strong>文本底线</strong> 对齐的省略号，<code>\cdots</code> 表示与 <strong>文本中线</strong> 对齐的省略号</p><h3 id="如何输入积分"><a href="#如何输入积分" class="headerlink" title="如何输入积分"></a>如何输入积分</h3><p>使用 <code>\int_积分下限^积分上限 &#123;被积表达式&#125;</code> 来输入一个积分</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$&#123;\int&#123;_1^2&#125;&#123;f^&#123;-1&#125;(x)dx&#125;&#125;$</span><br></pre></td></tr></table></figure><p>​                                                                 ${\int{_1^2} {f^{-1}(x)dx} }$</p><h3 id="如何输入极限"><a href="#如何输入极限" class="headerlink" title="如何输入极限"></a>如何输入极限</h3><p>使用 <code>\lim_&#123;变量 \to 表达式&#125; 表达式</code> 来输入一个极限。如有需求，可以更改 <code>\to</code> 符号至任意符号</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$&#123;\lim_&#123;x \to \infty&#125;\frac&#123;sinx&#125;&#123;x&#125;&#125;$</span><br></pre></td></tr></table></figure><p>​                                                                  ${\lim_{x \to \infty}\frac{sinx} {x} }$</p><h2 id="0x04-符号汇总"><a href="#0x04-符号汇总" class="headerlink" title="0x04 符号汇总"></a>0x04 符号汇总</h2><p><img src="/Images/2018041621294865.png" alt="2018041621294865"></p><p><img src="/Images/20180416213036844.png" alt="20180416213036844"></p><p><img src="/Images/20180416213119987.png" alt="20180416213119987"></p><p><img src="/Images/20180416213126857.png" alt="20180416213126857"></p><h3 id="0x05-其他"><a href="#0x05-其他" class="headerlink" title="0x05 其他"></a>0x05 其他</h3><p><a href="https://blog.csdn.net/Snakewood/article/details/130445273">纯手打可复制的数学公式表</a></p>]]></content>
      
      
      <categories>
          
          <category> math </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基础 </tag>
            
            <tag> 数学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++11关于四个引用的学习</title>
      <link href="/2024/03/09/c-11%E5%85%B3%E4%BA%8E-%E5%BC%95%E7%94%A8/"/>
      <url>/2024/03/09/c-11%E5%85%B3%E4%BA%8E-%E5%BC%95%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="0x01-引用的嵌套"><a href="#0x01-引用的嵌套" class="headerlink" title="0x01 引用的嵌套"></a>0x01 引用的嵌套</h2><p>It is permitted to form references to references through type manipulations in templates or typedefs, in which case the <em>reference collapsing</em> rules apply: rvalue reference to rvalue reference collapses to rvalue reference, all other combinations form lvalue reference</p><p>引用折叠规则：右值对右值的引用折叠为右值引用，所有其他组合为左值引用。</p><h2 id="0x02-左值引用"><a href="#0x02-左值引用" class="headerlink" title="0x02 左值引用"></a>0x02 左值引用</h2><p>Lvalue references can be used to alias an existing object (optionally with different cv-qualification):</p><p>左值引用可以作为一个已存在对象的别名，且可以用多个别名，别名之间共享一个对象。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::string s = <span class="string">&quot;Ex&quot;</span>;</span><br><span class="line">    std::string&amp; r1 = s;</span><br><span class="line">    <span class="type">const</span> std::string&amp; r2 = s;</span><br><span class="line"> </span><br><span class="line">    r1 += <span class="string">&quot;ample&quot;</span>;           <span class="comment">// modifies s</span></span><br><span class="line"><span class="comment">//  r2 += &quot;!&quot;;               // error: cannot modify through reference to const</span></span><br><span class="line">    std::cout &lt;&lt; r2 &lt;&lt; <span class="string">&#x27;\n&#x27;</span>; <span class="comment">// prints s, which now holds &quot;Example&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//这里r1和r2是一个东西</span></span><br></pre></td></tr></table></figure><p>They can also be used to implement pass-by-reference semantics in function calls:</p><p>左值引用可以在函数中引用传递</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">double_string</span><span class="params">(std::string&amp; s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    s += s; <span class="comment">// &#x27;s&#x27; is the same object as main()&#x27;s &#x27;str&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::string str = <span class="string">&quot;Test&quot;</span>;</span><br><span class="line">    <span class="built_in">double_string</span>(str);</span><br><span class="line">    std::cout &lt;&lt; str &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>When a function’s return type is lvalue reference, the function call expression becomes an lvalue expression:</p><p>当一个函数的返回值是左值引用时，这个函数调用表达式也成为了左值表达式</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">char</span>&amp; <span class="title">char_number</span><span class="params">(std::string&amp; s, std::<span class="type">size_t</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> s.<span class="built_in">at</span>(n); <span class="comment">// string::at() returns a reference to char</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::string str = <span class="string">&quot;Test&quot;</span>;</span><br><span class="line">    <span class="built_in">char_number</span>(str, <span class="number">1</span>) = <span class="string">&#x27;a&#x27;</span>; <span class="comment">// the function call is lvalue, can be assigned to</span></span><br><span class="line">    std::cout &lt;&lt; str &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//这里s.at(1) = &#x27;a&#x27;;一个左值表达式</span></span><br></pre></td></tr></table></figure><h2 id="0x03-右值引用"><a href="#0x03-右值引用" class="headerlink" title="0x03 右值引用"></a>0x03 右值引用</h2><p>Rvalue referencesRvalue references can be used to extend the lifetimes of temporary objects (note, lvalue references to const can extend the lifetimes of temporary objects too, but they are not modifiable through them):</p><p>右值引用可以延长临时对象的生命周期，左值引用加const也能延长生命周期（cppref 的例子，我也不知道有什么用，随便翻译一下吧）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::string s1 = <span class="string">&quot;Test&quot;</span>;</span><br><span class="line"><span class="comment">//  std::string&amp;&amp; r1 = s1;           // error: can&#x27;t bind to lvalue不能绑定左值</span></span><br><span class="line"> </span><br><span class="line">    <span class="type">const</span> std::string&amp; r2 = s1 + s1; <span class="comment">// okay: lvalue reference to const extends lifetime</span></span><br><span class="line">     <span class="comment">//const左值引用可以延长生命周期</span></span><br><span class="line"><span class="comment">//  r2 += &quot;Test&quot;;                    // error: can&#x27;t modify through reference to const</span></span><br><span class="line">     <span class="comment">//const 的值不能修改</span></span><br><span class="line"> </span><br><span class="line">    std::string&amp;&amp; r3 = s1 + s1;      <span class="comment">// okay: rvalue reference extends lifetime</span></span><br><span class="line">     <span class="comment">//延长临时变量生命周期</span></span><br><span class="line">    r3 += <span class="string">&quot;Test&quot;</span>;                    <span class="comment">// okay: can modify through reference to non-const</span></span><br><span class="line">    std::cout &lt;&lt; r3 &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>More importantly, when a function has both rvalue reference and lvalue reference overloads, the rvalue reference overload binds to rvalues (including both prvalues and xvalues), while the lvalue reference overload binds to lvalues</p><p>当一个函数同时有左值和右值的重载时，右值引用重载绑定右值，左值引用重载绑定左值</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">int</span>&amp; x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;lvalue reference overload f(&quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&quot;)\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">const</span> <span class="type">int</span>&amp; x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;lvalue reference to const overload f(&quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&quot;)\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">int</span>&amp;&amp; x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;rvalue reference overload f(&quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&quot;)\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">1</span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> ci = <span class="number">2</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">f</span>(i);  <span class="comment">// calls f(int&amp;)</span></span><br><span class="line">    <span class="built_in">f</span>(ci); <span class="comment">// calls f(const int&amp;)</span></span><br><span class="line">    <span class="built_in">f</span>(<span class="number">3</span>);  <span class="comment">// calls f(int&amp;&amp;)</span></span><br><span class="line">           <span class="comment">// would call f(const int&amp;) if f(int&amp;&amp;) overload wasn&#x27;t provided</span></span><br><span class="line">       <span class="comment">// 如果没有f(int&amp;&amp;)重载提供，将调用f(const int&amp;)</span></span><br><span class="line">    <span class="comment">//move后左值被转化成右值</span></span><br><span class="line">    <span class="built_in">f</span>(std::<span class="built_in">move</span>(i)); <span class="comment">// calls f(int&amp;&amp;)</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">// rvalue reference variables are lvalues when used in expressions</span></span><br><span class="line">    <span class="comment">//右值引用将被当成左值，在函数表达式中时</span></span><br><span class="line">    <span class="type">int</span>&amp;&amp; x = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">f</span>(x);            <span class="comment">// calls f(int&amp; x)</span></span><br><span class="line">    <span class="comment">//move后左值被转化成右值</span></span><br><span class="line">    <span class="built_in">f</span>(std::<span class="built_in">move</span>(x)); <span class="comment">// calls f(int&amp;&amp; x)</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Output:</span></span><br><span class="line"><span class="comment">/*lvalue reference overload f(1)</span></span><br><span class="line"><span class="comment">  lvalue reference to const overload f(2)</span></span><br><span class="line"><span class="comment">  rvalue reference overload f(3)</span></span><br><span class="line"><span class="comment">  rvalue reference overload f(1)</span></span><br><span class="line"><span class="comment">  lvalue reference overload f(1)</span></span><br><span class="line"><span class="comment">  rvalue reference overload f(1)*/</span></span><br></pre></td></tr></table></figure><p>可以通过std::move将42绑定i2，使得i2成为一个右值</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i2 = <span class="number">42</span>;</span><br><span class="line"><span class="type">int</span>&amp;&amp; rri = std::<span class="built_in">move</span>(i2); <span class="comment">// binds directly to i2</span></span><br></pre></td></tr></table></figure><p>This makes it possible to move out of an object in scope that is no longer needed:</p><p>通过这样就可以舍去作用域中不再需要的对象：（这个例子移去了v）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line">std::vector&lt;<span class="type">int</span>&gt; v&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"><span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">v2</span><span class="params">(std::move(v))</span></span>; <span class="comment">// binds an rvalue reference to v（绑定右值引用到v）</span></span><br><span class="line"><span class="comment">//断言函数，程序可以正常运行说明v为空</span></span><br><span class="line"><span class="built_in">assert</span>(v.<span class="built_in">empty</span>());</span><br></pre></td></tr></table></figure><h2 id="0x04-Forwarding-reference"><a href="#0x04-Forwarding-reference" class="headerlink" title="0x04 Forwarding reference"></a>0x04 Forwarding reference</h2><p>转发引用是一种特殊的引用，它保留了函数参数的值类别（左值和右值性质不变），从而可以通过 std::forward 进行转发给另一个函数或者类，实现完美转发。（该引用是左右不确定的）</p><p>例子1，模板函数参数声明为类模板参数的右值引用</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">f</span><span class="params">(T&amp;&amp; x)</span>                      <span class="comment">// x is a forwarding reference</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">g</span>(std::forward&lt;T&gt;(x)); <span class="comment">// and so can be forwarded</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i;<span class="comment">//根据引用的嵌套性质</span></span><br><span class="line">    <span class="built_in">f</span>(i); <span class="comment">// argument is lvalue, calls f&lt;int&amp;&gt;(int&amp;), std::forward&lt;int&amp;&gt;(x) is lvalue</span></span><br><span class="line">    <span class="built_in">f</span>(<span class="number">0</span>); <span class="comment">// argument is rvalue, calls f&lt;int&gt;(int&amp;&amp;), std::forward&lt;int&gt;(x) is rvalue</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;<span class="comment">//const使得左值变右值</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">g</span><span class="params">(<span class="type">const</span> T&amp;&amp; x)</span></span>; <span class="comment">// x is not a forwarding reference: const T is not cv-unqualified</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;<span class="comment">//要实现forwarding reference的话应该把这个模板声明写到下面</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> U&gt;</span></span><br><span class="line"><span class="function">    <span class="title">A</span><span class="params">(T&amp;&amp; x, U&amp;&amp; y, <span class="type">int</span>* p)</span></span>; <span class="comment">// x is not a forwarding reference: T is not a</span></span><br><span class="line">                             <span class="comment">// type template parameter of the constructor,</span></span><br><span class="line">                             <span class="comment">// but y is a forwarding reference</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>例子2，auto&amp;&amp;能自动推导。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span>&amp;&amp; vec = <span class="built_in">foo</span>();       <span class="comment">// foo() may be lvalue or rvalue, vec is a forwarding reference</span></span><br><span class="line"><span class="keyword">auto</span> i = std::<span class="built_in">begin</span>(vec); <span class="comment">// works either way</span></span><br><span class="line">(*i)++;                   <span class="comment">// works either way</span></span><br><span class="line"> </span><br><span class="line"><span class="built_in">g</span>(std::forward&lt;<span class="keyword">decltype</span>(vec)&gt;(vec)); <span class="comment">// forwards, preserving value category</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span>&amp;&amp; x: <span class="built_in">f</span>())<span class="comment">//能自动推导f类型，从中取出x循环</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// x is a forwarding reference; this is a common way to use range for in generic code</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">auto</span>&amp;&amp; z = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;; <span class="comment">// *not* a forwarding reference (special case for initializer lists)初始化器列表的特殊情况</span></span><br></pre></td></tr></table></figure><h2 id="0x05-Dangling-references"><a href="#0x05-Dangling-references" class="headerlink" title="0x05 Dangling references"></a>0x05 Dangling references</h2><p>生命周期已经结束，但引用仍可以访问（悬挂）访问这样的引用是未定义的行为</p><p>If the referred-to object was destroyed (e.g. by explicit destructor call), but the storage was not deallocated, a reference to the out-of-lifetime object may be used in limited ways, and may become valid if the object is recreated in the same storage (see <a href="https://en.cppreference.com/w/cpp/language/lifetime#Access_outside_of_lifetime">Access outside of lifetime</a> for details).</p><p>如果被引用的对象已被销毁（例如通过显式析构函数调用），但存储空间未被清空，则对超出生命周期的对象的引用可以以有限的方式使用，如果在同一存储空间中重新创建该对象，则该引用可能有效（详见超出生命周期的访问）。（deepl翻译的）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::string&amp; <span class="title">f</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::string s = <span class="string">&quot;Example&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> s; <span class="comment">// exits the scope of s:</span></span><br><span class="line">              <span class="comment">// its destructor is called and its storage deallocated</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//正常都是没法访问到的，会报错</span></span><br><span class="line">std::string&amp; r = <span class="built_in">f</span>(); <span class="comment">// dangling reference（会出现警告）</span></span><br><span class="line">std::cout &lt;&lt; r;       <span class="comment">// undefined behavior: reads from a dangling reference</span></span><br><span class="line">std::string s = <span class="built_in">f</span>();  <span class="comment">// undefined behavior: copy-initializes from a dangling reference</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基础 </tag>
            
            <tag> C++11 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据表达实验</title>
      <link href="/2024/03/09/csapp%E6%95%B0%E6%8D%AE%E8%A1%A8%E8%BE%BE%E5%AE%9E%E9%AA%8C/"/>
      <url>/2024/03/09/csapp%E6%95%B0%E6%8D%AE%E8%A1%A8%E8%BE%BE%E5%AE%9E%E9%AA%8C/</url>
      
        <content type="html"><![CDATA[<h2 id="0x01-实验前的环境部署和操作"><a href="#0x01-实验前的环境部署和操作" class="headerlink" title="0x01 实验前的环境部署和操作"></a>0x01 实验前的环境部署和操作</h2><h3 id="安装gcc-multilib插件"><a href="#安装gcc-multilib插件" class="headerlink" title="安装gcc-multilib插件"></a>安装gcc-multilib插件</h3><p>由于实验自带的检验和打分等程序是32位程序，而我的虚拟机是Ubuntu64位的，因此安装这个插件来兼容64位系统。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install gcc-multilib</span><br></pre></td></tr></table></figure><h3 id="实验步骤简述"><a href="#实验步骤简述" class="headerlink" title="实验步骤简述"></a>实验步骤简述</h3><p>我这里用vscode远程连接本地Ubuntu虚拟机，打开<code>datalab-handout</code>文件夹的<code>bits.c</code>文件，根据里面的要求补全函数。</p><p>（参考网站：<a href="https://blog.csdn.net/qq_29856169/article/details/115489702">vscode远程连接本地虚拟机</a>；<a href="https://blog.csdn.net/qq_27727147/article/details/104814170">出现无法连接的问题时</a>）</p><h3 id="实验结果检验"><a href="#实验结果检验" class="headerlink" title="实验结果检验"></a>实验结果检验</h3><p>在linux终端中输入以下命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">make 编译</span><br><span class="line">./btest 测试</span><br></pre></td></tr></table></figure><h2 id="0x02-补全bits-c里的函数思路"><a href="#0x02-补全bits-c里的函数思路" class="headerlink" title="0x02 补全bits.c里的函数思路"></a>0x02 补全bits.c里的函数思路</h2><h3 id="01-bitXor"><a href="#01-bitXor" class="headerlink" title="01 bitXor"></a>01 bitXor</h3><p>根据异或公式，(~x &amp; y) | (x &amp; ~y)，由于这里不允许使用或|，于是使用摩根定律替换</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1</span></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * bitXor - x^y using only ~ and &amp; </span></span><br><span class="line"><span class="comment"> *   Example: bitXor(4, 5) = 1</span></span><br><span class="line"><span class="comment"> *   Legal ops: ~ &amp;</span></span><br><span class="line"><span class="comment"> *   Max ops: 14</span></span><br><span class="line"><span class="comment"> *   Rating: 1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">bitXor</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> ~(~(~x &amp; y) &amp; ~(x &amp; ~y));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="02-tmin"><a href="#02-tmin" class="headerlink" title="02 tmin"></a>02 tmin</h3><p>返回补码数的最小值，就是1开头后面全是0的数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * tmin - return minimum two&#x27;s complement integer </span></span><br><span class="line"><span class="comment"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span></span><br><span class="line"><span class="comment"> *   Max ops: 4</span></span><br><span class="line"><span class="comment"> *   Rating: 1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">tmin</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> (<span class="number">1</span>&lt;&lt;<span class="number">31</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="03-isTmax"><a href="#03-isTmax" class="headerlink" title="03 isTmax"></a>03 isTmax</h3><p>检测是不是int补码数最大值，即0111后面全是1，我发现，只有-1和INT_MAX加1后再与本身异或运算，才有可能是位级表示下全1的数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0111 ^ 1000 = 1111 Or 1111 ^ 0000 = 1111</span><br></pre></td></tr></table></figure><p>全1的数很好判断，只有取反再测是不是0。这时候只要排除-1的情况就好了，只要x加1后非0，这个数就不是-1。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * isTmax - returns 1 if x is the maximum, two&#x27;s complement number,</span></span><br><span class="line"><span class="comment"> *     and 0 otherwise </span></span><br><span class="line"><span class="comment"> *   Legal ops: ! ~ &amp; ^ | +</span></span><br><span class="line"><span class="comment"> *   Max ops: 10</span></span><br><span class="line"><span class="comment"> *   Rating: 2</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">isTmax</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> !!(x+<span class="number">1</span>) &amp; !(~((x+<span class="number">1</span>) ^ x));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="04-allOddBits"><a href="#04-allOddBits" class="headerlink" title="04 allOddBits"></a>04 allOddBits</h3><p>如果某个数所有的奇数位是1就返回1，比如0xAA：1010 1010</p><p>用0xAA AA AA AA取输入数x的掩码，然后再判断是否与0xAAAAAAAA相等</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * allOddBits - return 1 if all odd-numbered bits in word set to 1</span></span><br><span class="line"><span class="comment"> *   Examples allOddBits(0xFFFFFFFD) = 0, allOddBits(0xAAAAAAAA) = 1</span></span><br><span class="line"><span class="comment"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span></span><br><span class="line"><span class="comment"> *   Max ops: 12</span></span><br><span class="line"><span class="comment"> *   Rating: 2</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">allOddBits</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">  <span class="type">int</span> temp = <span class="number">0xAA</span>;</span><br><span class="line">  temp |= temp &lt;&lt; <span class="number">8</span>;</span><br><span class="line">  temp |= temp &lt;&lt; <span class="number">16</span>;</span><br><span class="line">  <span class="keyword">return</span> !((x &amp; temp) ^ temp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="05-negate"><a href="#05-negate" class="headerlink" title="05 negate"></a>05 negate</h3><p>返回一个负数</p><p>按照补码运算性质马上就能得出答案，按位取反再加1（最大补码负数的取负还是本身）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * negate - return -x </span></span><br><span class="line"><span class="comment"> *   Example: negate(1) = -1.</span></span><br><span class="line"><span class="comment"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span></span><br><span class="line"><span class="comment"> *   Max ops: 5</span></span><br><span class="line"><span class="comment"> *   Rating: 2</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">negate</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> (~x+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="06-isAsciiDigit"><a href="#06-isAsciiDigit" class="headerlink" title="06 isAsciiDigit"></a>06 isAsciiDigit</h3><p>如果是ASCII码下的数字符号就返回1，在0x30到0x39之间</p><p>先排除大于0xff的情况，与一个高24位全是1的掩码，之后除了0x3x，再判断低四位，有0xxx，和100x两种情况，分别讨论即可。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * isAsciiDigit - return 1 if 0x30 &lt;= x &lt;= 0x39 (ASCII codes for characters &#x27;0&#x27; to &#x27;9&#x27;)</span></span><br><span class="line"><span class="comment"> *   Example: isAsciiDigit(0x35) = 1.</span></span><br><span class="line"><span class="comment"> *            isAsciiDigit(0x3a) = 0.</span></span><br><span class="line"><span class="comment"> *            isAsciiDigit(0x05) = 0.</span></span><br><span class="line"><span class="comment"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span></span><br><span class="line"><span class="comment"> *   Max ops: 15</span></span><br><span class="line"><span class="comment"> *   Rating: 3</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">isAsciiDigit</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">  <span class="type">int</span> test_number = (<span class="number">1</span>&lt;&lt;<span class="number">31</span>)&gt;&gt;<span class="number">23</span>;</span><br><span class="line">  <span class="keyword">return</span> !(x &amp; test_number) &amp; (!((x &amp; <span class="number">0xf8</span>) ^ <span class="number">0x30</span>) | !((x &amp; <span class="number">0xfe</span>) ^ <span class="number">0x38</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="07-conditional"><a href="#07-conditional" class="headerlink" title="07 conditional"></a>07 conditional</h3><p><code>x ? y : z</code> 三元运算符，x为真取y，假取z</p><p>若x为真，根据x的值来生成一个全1的掩码，跟y与得到y本身；全1的非，即全0，跟z与得到0，最后两者再或运算</p><p>得到y，若x为假，同上理得到z。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * conditional - same as x ? y : z </span></span><br><span class="line"><span class="comment"> *   Example: conditional(2,4,5) = 4</span></span><br><span class="line"><span class="comment"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span></span><br><span class="line"><span class="comment"> *   Max ops: 16</span></span><br><span class="line"><span class="comment"> *   Rating: 3</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">conditional</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> z)</span> &#123;</span><br><span class="line">  <span class="type">int</span> Bool = ((!!x) &lt;&lt; <span class="number">31</span>) &gt;&gt; <span class="number">31</span>;</span><br><span class="line">  <span class="keyword">return</span> (Bool &amp; y) | (~Bool &amp; z);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="08-isLessOrEqual"><a href="#08-isLessOrEqual" class="headerlink" title="08 isLessOrEqual"></a>08 isLessOrEqual</h3><p>实现小于或等于号</p><p>判断y - x 是否大于或等于0，减法用加逆元来实现（实测发现虽然INT_MIN的逆元是本身，但是能正常运算）。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * isLessOrEqual - if x &lt;= y  then return 1, else return 0 </span></span><br><span class="line"><span class="comment"> *   Example: isLessOrEqual(4,5) = 1.</span></span><br><span class="line"><span class="comment"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span></span><br><span class="line"><span class="comment"> *   Max ops: 24</span></span><br><span class="line"><span class="comment"> *   Rating: 3</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">isLessOrEqual</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> &#123;</span><br><span class="line">  <span class="type">int</span> test_number = <span class="number">1</span> &lt;&lt; <span class="number">31</span>;</span><br><span class="line">  <span class="keyword">return</span> !(((y + (~x + <span class="number">1</span>)) &gt;&gt; <span class="number">31</span>) &amp; test_number) ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="09-logicalNeg"><a href="#09-logicalNeg" class="headerlink" title="09 logicalNeg"></a>09 logicalNeg</h3><p>不用 <code>!</code> 来实现 <code>!</code></p><p>0得到1，非0得到0</p><p>非0的数的逆元（否定）会翻转符号位，而0不会，于是非0数的否定与本身或运算得到符号位为1的数。</p><p>然后再算术右移，若非0则得到-1，为0则得到0，再加1就实现成功。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * logicalNeg - implement the ! operator, using all of </span></span><br><span class="line"><span class="comment"> *              the legal operators except !</span></span><br><span class="line"><span class="comment"> *   Examples: logicalNeg(3) = 0, logicalNeg(0) = 1</span></span><br><span class="line"><span class="comment"> *   Legal ops: ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span></span><br><span class="line"><span class="comment"> *   Max ops: 12</span></span><br><span class="line"><span class="comment"> *   Rating: 4 </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">logicalNeg</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> (((~x + <span class="number">1</span>) | x) &gt;&gt; <span class="number">31</span>) + <span class="number">1</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="0A-howManyBits"><a href="#0A-howManyBits" class="headerlink" title="0A howManyBits"></a>0A howManyBits</h3><p>判断某个数，最少可以用多少位级表示，由于x和~x的位级所需位是一样的，所有负数都通过翻转成正数来处理（正数不变）。以下操作可以实现</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x = x &gt;&gt; <span class="number">31</span> ^ x;</span><br></pre></td></tr></table></figure><p>之后开始查找第一个1的位置，表示第一个1的位置所需的位级再加上1（符号位），就能返回正确答案。</p><p>查找位置的方法用二分查找，每次取中间位置，看看高位是否存在1，若存在再右移x来查找高位，否则不位移来查找低位，记录被右移掉的位数，最后要加到结果中。经过5轮的二分，就能查找到第一个1的确切位置。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* howManyBits - return the minimum number of bits required to represent x in</span></span><br><span class="line"><span class="comment"> *             two&#x27;s complement</span></span><br><span class="line"><span class="comment"> *  Examples: howManyBits(12) = 5</span></span><br><span class="line"><span class="comment"> *            howManyBits(298) = 10</span></span><br><span class="line"><span class="comment"> *            howManyBits(-5) = 4</span></span><br><span class="line"><span class="comment"> *            howManyBits(0)  = 1</span></span><br><span class="line"><span class="comment"> *            howManyBits(-1) = 1</span></span><br><span class="line"><span class="comment"> *            howManyBits(0x80000000) = 32</span></span><br><span class="line"><span class="comment"> *  Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span></span><br><span class="line"><span class="comment"> *  Max ops: 90</span></span><br><span class="line"><span class="comment"> *  Rating: 4</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">howManyBits</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">  x = x &gt;&gt; <span class="number">31</span> ^ x;</span><br><span class="line">  </span><br><span class="line">  <span class="type">int</span> b16, b8, b4, b2, b1;</span><br><span class="line"></span><br><span class="line">  b16 = !!(x &gt;&gt; <span class="number">16</span>) &lt;&lt; <span class="number">4</span>;</span><br><span class="line">  x = x &gt;&gt; (b16);</span><br><span class="line">  b8 = !!(x &gt;&gt; <span class="number">8</span>) &lt;&lt; <span class="number">3</span>;</span><br><span class="line">  x = x &gt;&gt; b8;</span><br><span class="line">  b4 = !!(x &gt;&gt; <span class="number">4</span>) &lt;&lt; <span class="number">2</span>;</span><br><span class="line">  x = x &gt;&gt; b4;</span><br><span class="line">  b2 = !!(x &gt;&gt; <span class="number">2</span>) &lt;&lt; <span class="number">1</span>;</span><br><span class="line">  x = x &gt;&gt; b2;</span><br><span class="line">  b1 = !!(x &gt;&gt; <span class="number">1</span>);</span><br><span class="line">  x = x &gt;&gt; b1;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> b16 + b8 + b4 + b2 + b1 + x + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="0B-float-twice"><a href="#0B-float-twice" class="headerlink" title="0B float_twice"></a>0B float_twice</h3><p>把一个浮点数乘以2，返回对应的值。</p><p>NaN返回本身：<code>exp = 0xff,frac != 0</code></p><p>非规格化：<code>exp = 0, frac &lt;&lt;= 1</code>，与规格化的过渡是平滑的，直接frac左移一位即可</p><p>规格化乘以2后溢出：<code>&#123;exp = 0xff，frac = 0&#125; Or &#123;exp = 0xff-1&#125;</code>，return ∞（返回无穷）</p><p>规格化未溢出：<code>exp += 1</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//float</span></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * float_twice - Return bit-level equivalent of expression 2*f for</span></span><br><span class="line"><span class="comment"> *   floating point argument f.</span></span><br><span class="line"><span class="comment"> *   Both the argument and result are passed as unsigned int&#x27;s, but</span></span><br><span class="line"><span class="comment"> *   they are to be interpreted as the bit-level representation of</span></span><br><span class="line"><span class="comment"> *   single-precision floating point values.</span></span><br><span class="line"><span class="comment"> *   When argument is NaN, return argument</span></span><br><span class="line"><span class="comment"> *   Legal ops: Any integer/unsigned operations incl. ||, &amp;&amp;. also if, while</span></span><br><span class="line"><span class="comment"> *   Max ops: 30</span></span><br><span class="line"><span class="comment"> *   Rating: 4</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">unsigned</span> <span class="title function_">float_twice</span><span class="params">(<span class="type">unsigned</span> uf)</span> &#123;</span><br><span class="line">  <span class="type">unsigned</span> sign = uf &amp; (<span class="number">1</span> &lt;&lt; <span class="number">31</span>);</span><br><span class="line">  <span class="type">unsigned</span> <span class="built_in">exp</span> = (uf ^ sign) &gt;&gt; <span class="number">23</span>;</span><br><span class="line">  <span class="type">unsigned</span> frac = uf &amp; <span class="number">0x7fffff</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(!<span class="built_in">exp</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> (uf &lt;&lt; <span class="number">1</span>) | sign;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span>(!(<span class="built_in">exp</span> ^ <span class="number">0xff</span>) &amp;&amp; frac)&#123;</span><br><span class="line">    <span class="keyword">return</span> uf;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span>((!(<span class="built_in">exp</span> ^ <span class="number">0xff</span>) &amp;&amp; !frac) || !(<span class="built_in">exp</span> ^ <span class="number">0xfe</span>))&#123;</span><br><span class="line">    <span class="built_in">exp</span> = <span class="number">0xff</span>;</span><br><span class="line">    <span class="keyword">return</span> sign | (<span class="built_in">exp</span> &lt;&lt; <span class="number">23</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (uf ^ (<span class="built_in">exp</span> &lt;&lt; <span class="number">23</span>)) | (<span class="built_in">exp</span> + <span class="number">1</span>) &lt;&lt; <span class="number">23</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="0C-float-i2f"><a href="#0C-float-i2f" class="headerlink" title="0C float_i2f"></a>0C float_i2f</h3><p>（偶数舍入方法：先加上舍弃位的半值，利用四舍五入，小于半值的加上半值也不会进位，移位后自然舍弃，大于半值的加上半值会产生进位，完全符合我们的需求。对于刚好半值，加上半值会进位，但是它比较特殊，加完后舍弃的值是全0，如果最低有效位是1，说明原来是0，不该进位，所以再减1去掉进位。）</p><p>（这个有点难，我最后参考了网上的做法）</p><p>先把int正数取正（无符号），再算出uf的位数，把其转化为frac表示，然后记录exp，最后合并。</p><p>然后后九位要根据向偶数舍入来舍入（如果int部分超过24）。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="title function_">float_i2f</span><span class="params">(<span class="type">int</span> x)</span>&#123;</span><br><span class="line">  <span class="type">unsigned</span> uf, <span class="built_in">exp</span>;</span><br><span class="line">  <span class="type">unsigned</span> sign = x &amp; (<span class="number">1</span> &lt;&lt; <span class="number">31</span>);</span><br><span class="line">  <span class="type">unsigned</span> i = <span class="number">30</span>, t;<span class="comment">//i存储的是最高位的向量下标</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(x==<span class="number">0</span>)&#123;</span><br><span class="line">    uf = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span>(x == <span class="number">0x80000000</span>)&#123;</span><br><span class="line">    uf = <span class="number">0xcf000000</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(sign)&#123;</span><br><span class="line">      uf = ~x + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">      uf = x;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(!(uf &amp; (<span class="number">1</span> &lt;&lt; i)))&#123;</span><br><span class="line">      i--;</span><br><span class="line">    &#125;</span><br><span class="line">    uf = uf - (<span class="number">1</span> &lt;&lt; i);<span class="comment">//去掉最高位的1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(i &lt; <span class="number">24</span>)&#123;<span class="comment">//如果不大于24位，不需要舍入操作</span></span><br><span class="line">      uf = uf &lt;&lt; (<span class="number">23</span> - i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">      t = i - <span class="number">23</span>;</span><br><span class="line">      uf += (<span class="number">1</span> &lt;&lt; (t - <span class="number">1</span>));   <span class="comment">//加即将丢弃的值的一半，四舍五入</span></span><br><span class="line">      <span class="keyword">if</span>(uf &amp; ((<span class="number">1</span> &lt;&lt; (t + <span class="number">1</span>)) - <span class="number">1</span>))&#123;   <span class="comment">//判断奇偶，如果是1后跟着0，说明不该进位。</span></span><br><span class="line">        uf -= <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      uf = uf &gt;&gt; t;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">exp</span> = (<span class="number">127</span> + i) &lt;&lt; <span class="number">23</span>;</span><br><span class="line">    <span class="comment">//这里用加法而不是或运算是可能因为尾数舍入进位</span></span><br><span class="line">    uf += <span class="built_in">exp</span> | sign;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> uf;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="0D-float-f2i"><a href="#0D-float-f2i" class="headerlink" title="0D float_f2i"></a>0D float_f2i</h3><p>应该是默认向0舍入。</p><p>当float数小于1时，直接返回0</p><p>当float数大于1，但不溢出int所能表示的范围时（exp 在127到157之间）</p><p>先补全小数点前的1，再根据E = exp -1 调整阶数。</p><p>当float超过int所能表示的范围，或者是NaN时，按照题意返回 0x8000 0000</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * float_f2i - Return bit-level equivalent of expression (int) f</span></span><br><span class="line"><span class="comment"> *   for floating point argument f.</span></span><br><span class="line"><span class="comment"> *   Argument is passed as unsigned int, but</span></span><br><span class="line"><span class="comment"> *   it is to be interpreted as the bit-level representation of a</span></span><br><span class="line"><span class="comment"> *   single-precision floating point value.</span></span><br><span class="line"><span class="comment"> *   Anything out of range (including NaN and infinity) should return</span></span><br><span class="line"><span class="comment"> *   0x80000000u.</span></span><br><span class="line"><span class="comment"> *   Legal ops: Any integer/unsigned operations incl. ||, &amp;&amp;. also if, while</span></span><br><span class="line"><span class="comment"> *   Max ops: 30</span></span><br><span class="line"><span class="comment"> *   Rating: 4</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">float_f2i</span><span class="params">(<span class="type">unsigned</span> uf)</span> &#123;</span><br><span class="line">  <span class="type">unsigned</span> sign = uf &amp; (<span class="number">1</span> &lt;&lt; <span class="number">31</span>);</span><br><span class="line">  <span class="type">unsigned</span> <span class="built_in">exp</span> = (uf ^ sign) &gt;&gt; <span class="number">23</span>;</span><br><span class="line">  <span class="type">unsigned</span> frac = uf &amp; <span class="number">0x7fffff</span>;</span><br><span class="line">  <span class="type">unsigned</span> E;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(<span class="built_in">exp</span> == <span class="number">0</span> || (<span class="built_in">exp</span> &gt;= <span class="number">1</span> &amp;&amp; <span class="built_in">exp</span> &lt;= <span class="number">126</span>))&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">exp</span> &gt;= <span class="number">127</span> &amp;&amp; <span class="built_in">exp</span> &lt;= <span class="number">157</span>)&#123;</span><br><span class="line">    E = <span class="built_in">exp</span> - <span class="number">127</span>;</span><br><span class="line">    frac |= <span class="number">0x800000</span>;</span><br><span class="line">    <span class="keyword">if</span>(E &lt;= <span class="number">23</span>)&#123;</span><br><span class="line">      frac &gt;&gt;= (<span class="number">23</span> - E);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(E &gt; <span class="number">23</span>)&#123;</span><br><span class="line">      frac &lt;&lt;= (E - <span class="number">23</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">exp</span> &gt;= <span class="number">158</span> &amp;&amp; <span class="built_in">exp</span> &lt;= <span class="number">255</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0x80000000</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(sign)&#123;</span><br><span class="line">    <span class="keyword">return</span> ~frac + <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> frac;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 基础 </tag>
            
            <tag> cum15-213 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>cum15-213程序bomb破解</title>
      <link href="/2024/03/09/cum%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B%E5%BA%8Fbomb%E9%80%86%E5%90%91/"/>
      <url>/2024/03/09/cum%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B%E5%BA%8Fbomb%E9%80%86%E5%90%91/</url>
      
        <content type="html"><![CDATA[<h2 id="0x01-前言"><a href="#0x01-前言" class="headerlink" title="0x01 前言"></a>0x01 前言</h2><p>最近在学习csapp时，发现第三章作业是一个程序叫bomb，要求破解六个步骤拆除炸弹。bomb是一个elf文件，我们用ida64分析，然后打开kali虚拟机远程调试，准备工作就做好了。</p><h2 id="0x02-前五个部分"><a href="#0x02-前五个部分" class="headerlink" title="0x02 前五个部分"></a>0x02 前五个部分</h2><p>炸弹的前五个部分十分简单。第一部分就是比较一个输入的字符串，而这个字符点开加密函数phase_1就可以找到。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Border relations with Canada have never been better.</span><br></pre></td></tr></table></figure><p>第二部分是输入6个数字，然后数字前后直接要满足后面一个是前面一个两倍的关系</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">__int64 __fastcall <span class="title function_">phase_2</span><span class="params">(__int64 a1)</span></span><br><span class="line">&#123;</span><br><span class="line">  __int64 result; <span class="comment">// rax</span></span><br><span class="line">  <span class="type">char</span> *v2; <span class="comment">// rbx</span></span><br><span class="line">  <span class="type">int</span> v3; <span class="comment">// [rsp+0h] [rbp-38h] BYREF</span></span><br><span class="line">  <span class="type">char</span> v4; <span class="comment">// [rsp+4h] [rbp-34h] BYREF</span></span><br><span class="line">  <span class="type">char</span> v5; <span class="comment">// [rsp+18h] [rbp-20h] BYREF</span></span><br><span class="line"></span><br><span class="line">  read_six_numbers(a1, &amp;v3);</span><br><span class="line">  <span class="keyword">if</span> ( v3 != <span class="number">1</span> )</span><br><span class="line">    explode_bomb(a1, &amp;v3);</span><br><span class="line">  v2 = &amp;v4;</span><br><span class="line">  <span class="keyword">do</span></span><br><span class="line">  &#123;</span><br><span class="line">    result = (<span class="number">2</span> * *(v2 - <span class="number">1</span>));</span><br><span class="line">    <span class="keyword">if</span> ( *v2 != result )</span><br><span class="line">      explode_bomb(a1, &amp;v3);</span><br><span class="line">    v2 += <span class="number">4</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span> ( v2 != &amp;v5 );</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输入首项为1，公比为2的等比数列前六项即可。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 2 4 8 16 32</span><br></pre></td></tr></table></figure><p>第三部分是输入两个数字，然后第一个数字作为switch的索引来查找一个数字，再把这个数字和输入的第二个数字比较，相同即可。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">__int64 __fastcall <span class="title function_">phase_3</span><span class="params">(__int64 a1)</span></span><br><span class="line">&#123;</span><br><span class="line">  __int64 v1; <span class="comment">// rdx</span></span><br><span class="line">  __int64 v2; <span class="comment">// rcx</span></span><br><span class="line">  __int64 result; <span class="comment">// rax</span></span><br><span class="line">  <span class="type">int</span> v4; <span class="comment">// [rsp+8h] [rbp-10h] BYREF</span></span><br><span class="line">  <span class="type">int</span> v5; <span class="comment">// [rsp+Ch] [rbp-Ch] BYREF</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ( __isoc99_sscanf(a1, <span class="string">&quot;%d %d&quot;</span>, &amp;v4, &amp;v5) &lt;= <span class="number">1</span> )</span><br><span class="line">    explode_bomb(a1, <span class="string">&quot;%d %d&quot;</span>, v1, v2);</span><br><span class="line">  <span class="keyword">switch</span> ( v4 )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">      result = <span class="number">207LL</span>;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">      result = <span class="number">311LL</span>;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">      result = <span class="number">707LL</span>;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">      result = <span class="number">256LL</span>;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">      result = <span class="number">389LL</span>;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">      result = <span class="number">206LL</span>;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">6</span>:</span><br><span class="line">      result = <span class="number">682LL</span>;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">7</span>:</span><br><span class="line">      result = <span class="number">327LL</span>;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      explode_bomb(a1, <span class="string">&quot;%d %d&quot;</span>, v1, v2);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> ( result != v5 )</span><br><span class="line">    explode_bomb(a1, <span class="string">&quot;%d %d&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我这里随便找一个组合输入</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">7 327</span><br></pre></td></tr></table></figure><p>第四部分是一个二分查找的递归函数，满足的条件是return 0，这里发现只要a1小于一次中值v3，result就会被赋值0，之后递归回溯时就会把result=0返回出去。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//加密函数</span></span><br><span class="line">__int64 __fastcall <span class="title function_">phase_4</span><span class="params">(__int64 a1)</span></span><br><span class="line">&#123;</span><br><span class="line">  __int64 v1; <span class="comment">// rdi</span></span><br><span class="line">  __int64 result; <span class="comment">// rax</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> v3; <span class="comment">// [rsp+8h] [rbp-10h] BYREF</span></span><br><span class="line">  <span class="type">int</span> v4; <span class="comment">// [rsp+Ch] [rbp-Ch] BYREF</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ( __isoc99_sscanf(a1, <span class="string">&quot;%d %d&quot;</span>, &amp;v3, &amp;v4) != <span class="number">2</span> || v3 &gt; <span class="number">0xE</span> )</span><br><span class="line">    explode_bomb(a1, <span class="string">&quot;%d %d&quot;</span>);</span><br><span class="line">  v1 = v3;</span><br><span class="line">  result = func4(v3, <span class="number">0LL</span>, <span class="number">14LL</span>);</span><br><span class="line">  <span class="keyword">if</span> ( result || v4 )</span><br><span class="line">    explode_bomb(v1, <span class="number">0LL</span>);</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//递归函数</span></span><br><span class="line">__int64 __fastcall <span class="title function_">func4</span><span class="params">(__int64 a1, __int64 a2, __int64 a3)</span></span><br><span class="line">    <span class="comment">//a2初始是0，a3初始是14</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> v3; <span class="comment">// ecx</span></span><br><span class="line">  __int64 result; <span class="comment">// rax</span></span><br><span class="line"></span><br><span class="line">  v3 = (a3 - a2) / <span class="number">2</span> + a2;</span><br><span class="line">  <span class="keyword">if</span> ( v3 &gt; a1 )</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span> * func4(a1, a2, (v3 - <span class="number">1</span>));</span><br><span class="line">  result = <span class="number">0LL</span>;</span><br><span class="line">  <span class="keyword">if</span> ( v3 &lt; a1 )</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span> * func4(a1, (v3 + <span class="number">1</span>), a3) + <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里需要输入两个值，第一个值v4必为0，第二个值v3我为了保险起见，输入了一个0，让上述二分查找里a1，也就是v3传进去的值能一直小于中值，然后result赋值为0接着返回。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0 0</span><br></pre></td></tr></table></figure><p>第五部分是个查找表的加密，输入长度为6的字符串，然后取每个字符的二进制前四位掩码，作为数组array_3449的下标，依次和字符串flyers比较。这里通过找表发现下标顺序是9 F E 5 6 7，只要依次输入低四位是这些数字的字符就好了。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> __int64 __fastcall <span class="title function_">phase_5</span><span class="params">(__int64 a1, <span class="type">const</span> <span class="type">char</span> *a2)</span></span><br><span class="line">&#123;</span><br><span class="line">  __int64 i; <span class="comment">// rax</span></span><br><span class="line">  <span class="type">char</span> v4[<span class="number">8</span>]; <span class="comment">// [rsp+10h] [rbp-18h] BYREF</span></span><br><span class="line">  <span class="type">unsigned</span> __int64 v5; <span class="comment">// [rsp+18h] [rbp-10h]</span></span><br><span class="line"></span><br><span class="line">  v5 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  <span class="keyword">if</span> ( string_length() != <span class="number">6</span> )</span><br><span class="line">    explode_bomb(a1, a2);</span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">0LL</span>; i != <span class="number">6</span>; ++i )</span><br><span class="line">    v4[i] = array_3449[*(a1 + i) &amp; <span class="number">0xF</span>];</span><br><span class="line">  v4[<span class="number">6</span>] = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> ( strings_not_equal(v4, <span class="string">&quot;flyers&quot;</span>) )</span><br><span class="line">    explode_bomb(v4, <span class="string">&quot;flyers&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> __readfsqword(<span class="number">0x28</span>u) ^ v5;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//数组array_3449（索引表）</span></span><br><span class="line">.rodata:<span class="number">00000000004024B</span>0                               ; <span class="type">char</span> array_3449[<span class="number">16</span>]</span><br><span class="line">.rodata:<span class="number">00000000004024B</span>0 <span class="number">6</span>D                            array_3449 db <span class="number">6</span>Dh                       ; DATA XREF: phase_5+<span class="number">37</span>↑r</span><br><span class="line">.rodata:<span class="number">00000000004024B</span>1 <span class="number">61</span>                            db  <span class="number">61</span>h ; a</span><br><span class="line">.rodata:<span class="number">00000000004024B</span>2 <span class="number">64</span>                            db  <span class="number">64</span>h ; d</span><br><span class="line">.rodata:<span class="number">00000000004024B</span>3 <span class="number">75</span>                            db  <span class="number">75</span>h ; u</span><br><span class="line">.rodata:<span class="number">00000000004024B</span>4 <span class="number">69</span>                            db  <span class="number">69</span>h ; i</span><br><span class="line">.rodata:<span class="number">00000000004024B</span>5 <span class="number">65</span>                            db  <span class="number">65</span>h ; e</span><br><span class="line">.rodata:<span class="number">00000000004024B</span>6 <span class="number">72</span>                            db  <span class="number">72</span>h ; r</span><br><span class="line">.rodata:<span class="number">00000000004024B</span>7 <span class="number">73</span>                            db  <span class="number">73</span>h ; s</span><br><span class="line">.rodata:<span class="number">00000000004024B</span>8 <span class="number">6</span>E                            db  <span class="number">6</span>Eh ; n</span><br><span class="line">.rodata:<span class="number">00000000004024B</span>9 <span class="number">66</span>                            db  <span class="number">66</span>h ; f</span><br><span class="line">.rodata:<span class="number">00000000004024B</span>A <span class="number">6F</span>                            db  <span class="number">6F</span>h ; o</span><br><span class="line">.rodata:<span class="number">00000000004024B</span>B <span class="number">74</span>                            db  <span class="number">74</span>h ; t</span><br><span class="line">.rodata:<span class="number">00000000004024B</span>C <span class="number">76</span>                            db  <span class="number">76</span>h ; v</span><br><span class="line">.rodata:<span class="number">00000000004024B</span>D <span class="number">62</span>                            db  <span class="number">62</span>h ; b</span><br><span class="line">.rodata:<span class="number">00000000004024B</span>E <span class="number">79</span>                            db  <span class="number">79</span>h ; y</span><br><span class="line">.rodata:<span class="number">00000000004024B</span>F <span class="number">6</span>C                            db  <span class="number">6</span>Ch ; l</span><br></pre></td></tr></table></figure><p>我这里输入 69  6F 6E 65 66 67</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ionefg</span><br></pre></td></tr></table></figure><h2 id="0x03-最后一部分"><a href="#0x03-最后一部分" class="headerlink" title="0x03 最后一部分"></a>0x03 最后一部分</h2><p>最后一部分调了我一个傍晚，发现是个链表加密</p><p><img src="../../../Hexo_Blog/blog-demo/source/Images/image-20240309192021180.png" alt="image-20240309192021180" style="zoom: 67%;" /></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line">__int64 __fastcall <span class="title function_">phase_6</span><span class="params">(__int64 a1)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> *v1; <span class="comment">// r13</span></span><br><span class="line">  <span class="type">int</span> v2; <span class="comment">// r12d</span></span><br><span class="line">  <span class="type">int</span> v3; <span class="comment">// ebx</span></span><br><span class="line">  <span class="type">char</span> *v4; <span class="comment">// rax</span></span><br><span class="line">  <span class="type">unsigned</span> __int64 i; <span class="comment">// rsi</span></span><br><span class="line">  _QWORD *v6; <span class="comment">// rdx</span></span><br><span class="line">  <span class="type">int</span> v7; <span class="comment">// eax</span></span><br><span class="line">  <span class="type">int</span> v8; <span class="comment">// ecx</span></span><br><span class="line">  __int64 v9; <span class="comment">// rbx</span></span><br><span class="line">  <span class="type">char</span> *v10; <span class="comment">// rax</span></span><br><span class="line">  __int64 j; <span class="comment">// rcx</span></span><br><span class="line">  __int64 v12; <span class="comment">// rdx</span></span><br><span class="line">  <span class="type">int</span> v13; <span class="comment">// ebp</span></span><br><span class="line">  __int64 result; <span class="comment">// rax</span></span><br><span class="line">  <span class="type">int</span> num[<span class="number">6</span>]; <span class="comment">// [rsp+0h] [rbp-78h] BYREF</span></span><br><span class="line">  <span class="type">char</span> v16; <span class="comment">// [rsp+18h] [rbp-60h] BYREF</span></span><br><span class="line">  __int64 v17; <span class="comment">// [rsp+20h] [rbp-58h]</span></span><br><span class="line">  <span class="type">char</span> v18; <span class="comment">// [rsp+28h] [rbp-50h] BYREF</span></span><br><span class="line">  <span class="type">char</span> v19[<span class="number">40</span>]; <span class="comment">// [rsp+50h] [rbp-28h] BYREF</span></span><br><span class="line"></span><br><span class="line">  v1 = num;</span><br><span class="line">  read_six_numbers(a1, num);</span><br><span class="line">  v2 = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( (*v1 - <span class="number">1</span>) &gt; <span class="number">5</span> )                        <span class="comment">// 第一个大于6</span></span><br><span class="line">      explode_bomb(a1, num);</span><br><span class="line">    <span class="keyword">if</span> ( ++v2 == <span class="number">6</span> )</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    v3 = v2;</span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> ( *v1 == num[v3] )                     <span class="comment">// 如果第一个和最后一个相等</span></span><br><span class="line">        explode_bomb(a1, num);</span><br><span class="line">      ++v3;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> ( v3 &lt;= <span class="number">5</span> );                          <span class="comment">// v3=6</span></span><br><span class="line">    ++v1;</span><br><span class="line">  &#125;                                             <span class="comment">// 检查6个数字是否互不相等</span></span><br><span class="line">  v4 = num;</span><br><span class="line">  <span class="keyword">do</span></span><br><span class="line">  &#123;</span><br><span class="line">    *v4 = <span class="number">7</span> - *v4;</span><br><span class="line">    v4 += <span class="number">4</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span> ( v4 != &amp;v16 );                         <span class="comment">// 7-输入数字</span></span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">0LL</span>; i != <span class="number">24</span>; i += <span class="number">4LL</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    v8 = num[i / <span class="number">4</span>];</span><br><span class="line">    <span class="keyword">if</span> ( v8 &lt;= <span class="number">1</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      v6 = &amp;node1;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      v7 = <span class="number">1</span>;</span><br><span class="line">      v6 = &amp;node1;</span><br><span class="line">      <span class="keyword">do</span></span><br><span class="line">      &#123;</span><br><span class="line">        v6 = v6[<span class="number">1</span>];</span><br><span class="line">        ++v7;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">while</span> ( v7 != v8 );</span><br><span class="line">    &#125;</span><br><span class="line">    *(&amp;v17 + <span class="number">2</span> * i) = v6;                       <span class="comment">// v17是各节点地址数组，循序是输入的1到6的顺序</span></span><br><span class="line">  &#125;</span><br><span class="line">  v9 = v17;                                     <span class="comment">// 第一个</span></span><br><span class="line">  v10 = &amp;v18;                                   <span class="comment">// 第二个</span></span><br><span class="line">  <span class="keyword">for</span> ( j = v17; ; j = v12 )</span><br><span class="line">  &#123;</span><br><span class="line">    v12 = *v10;                                 <span class="comment">// 第二个的值</span></span><br><span class="line">    *(j + <span class="number">8</span>) = *v10;</span><br><span class="line">    v10 += <span class="number">8</span>;                                   <span class="comment">// 第三个</span></span><br><span class="line">    <span class="keyword">if</span> ( v10 == v19 )</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  *(v12 + <span class="number">8</span>) = <span class="number">0LL</span>;</span><br><span class="line">  v13 = <span class="number">5</span>;</span><br><span class="line">  <span class="keyword">do</span></span><br><span class="line">  &#123;</span><br><span class="line">    result = **(v9 + <span class="number">8</span>);                        <span class="comment">// result的值是该节点指向的节点的值</span></span><br><span class="line">    <span class="keyword">if</span> ( *v9 &lt; result )</span><br><span class="line">      explode_bomb(a1, v19);</span><br><span class="line">    v9 = *(v9 + <span class="number">8</span>);                             <span class="comment">// 设置为下一个节点</span></span><br><span class="line">    --v13;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span> ( v13 );</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这坨式主要的逻辑就是，输入1到6的数字，然后取关于3.5的对称数，接着根据1到6的代表节点1到6，来重置链表的顺序，最后进行一个某节点与下一个节点的比较，若小于则程序退出，于是我们就要使得链表的顺序重置为从大到小排列。（其实是非常简单的逻辑，第一次见链表式存储的逆向给我卡了，调试后才发现）</p><p>根据逆向原理，我们得先找到排序然后再取数的对称。找到6个节点各自的值</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1    2  3    4    5    6</span><br><span class="line">014c a8 039c 02b3 01dd 01bb</span><br><span class="line">//排序</span><br><span class="line">3 4 6 5 2 1</span><br><span class="line">//取对称</span><br><span class="line">4 3 2 1 6 5</span><br></pre></td></tr></table></figure><p>这样就把炸弹拆除了。</p><h2 id="0x04-后续"><a href="#0x04-后续" class="headerlink" title="0x04 后续"></a>0x04 后续</h2><p>其实这个程序，我感觉作者的本意应该是让我们在机器语言或者汇编语言层面调试分析，奈何ida工具太强大了。</p>]]></content>
      
      
      <categories>
          
          <category> Re-wp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基础 </tag>
            
            <tag> 逆向 </tag>
            
            <tag> cum15-213 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>安装Ubuntu虚拟机</title>
      <link href="/2024/03/05/%E5%AE%89%E8%A3%85Ubuntu/"/>
      <url>/2024/03/05/%E5%AE%89%E8%A3%85Ubuntu/</url>
      
        <content type="html"><![CDATA[<h2 id="0x01-创建虚拟机"><a href="#0x01-创建虚拟机" class="headerlink" title="0x01 创建虚拟机"></a>0x01 创建虚拟机</h2><p>先在VMware创建一个虚拟机容器，直接点击”创建新的虚拟机“就好了。</p><p><img src="/Images/image-20240305203001550.png" alt="image-20240305203001550" style="zoom: 67%;" /></p><p>点击稍后安装操作系统，到时候去Ubuntu官网下载一个映像文件。</p><p><img src="/Images/image-20240305203050232.png" alt="image-20240305203050232" style="zoom:67%;" /></p><p>选择Ubuntu 64位，操作系统当然是Linux。</p><p>之后的虚拟机名称，默认就好了，无所谓，位置放到一个容易管理的文件夹里。</p><p><img src="/Images/image-20240305203217149.png" alt="image-20240305203217149" style="zoom:67%;" /></p><p>选择将虚拟磁盘储存为单个文件，最大磁盘大小并不会一开始就占用你20GB内存，而是动态扩展的，有大容量需求的话可以多分配一点，对我来说20GB绰绰有余了。</p><p>之后点击完成，虚拟机就创建好了。</p><h2 id="0x02-安装Ubuntu"><a href="#0x02-安装Ubuntu" class="headerlink" title="0x02 安装Ubuntu"></a>0x02 安装Ubuntu</h2><p>去Ubuntu的官网下载Linux系统映像文件（<a href="https://ubuntu.com/download/desktop">传送门</a>）</p><p><img src="/Images/image-20240305203502313.png" alt="image-20240305203502313" style="zoom:67%;" /></p><p>我安装了这个23.10版本，是去年10月份的最新版本。</p><p>大概有4GB左右，安装得有点慢。</p><p>安装好后将他放在随便一个文件夹里，最好是能找得到的，我创建了一个software文件夹来存放它。</p><p>再次打开Vmware，选择我们之前创建的虚拟机，点击编辑此虚拟机，</p><p><img src="/Images/image-20240305203757046.png" alt="image-20240305203757046" style="zoom:50%;" /></p><p>这里可以调整内存大小，我们先不管，点击CD/DVD，选择使用ISO映像文件，预览我们之前下载好的映像文件。</p><p>选择好之后就可以启动虚拟机了。</p><p>第一次启动会配置一些东西，一直下一步就行了。选择语言界面的我还是建议选择英语，方便之后命令的书写，我不小心点到Chinese了现在很痛苦。还有的就是填写用户名，密码和计算机名称这里，尽量把密码设置简单一点，之后在命令行安装文件一直都要输入密码，太长的密码搞人心态；还有就是计算机名称也填一个好记的名称，之后remote连接可能要用到，用户名就无所谓了，随便输入。</p><p>配置完后会重启虚拟机，然后等待安装配置就好了。</p><h2 id="0x03-VMware-Tools安装"><a href="#0x03-VMware-Tools安装" class="headerlink" title="0x03 VMware Tools安装"></a>0x03 VMware Tools安装</h2><p>这个工具能帮助我们把电脑里的文件和命令直接的东西复制到虚拟机里，非常实用，建议安装。</p><p>Vmware tools在Vm里有个安装的操作提示，如果你已经按照它的步骤并且安装成功了，那这部分你就不用看了。如果你安装成功后却无法将电脑里的文件拖拽进虚拟机（例如把桌面的照片拖拽到虚拟机），那么请你看看下面的解决方法（我也是用这个方法才解决的）</p><h3 id="卸载Vmware-Tools"><a href="#卸载Vmware-Tools" class="headerlink" title="卸载Vmware Tools"></a>卸载Vmware Tools</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get autoremove open-vm-tools</span><br></pre></td></tr></table></figure><h3 id="联网安装VMware-tools"><a href="#联网安装VMware-tools" class="headerlink" title="联网安装VMware tools"></a>联网安装VMware tools</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install open-vm-tools-desktop</span><br><span class="line">如果安装错误请以此输入下面两条命令</span><br><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install open-vm-tools-desktop fuse</span><br></pre></td></tr></table></figure><h3 id="重启虚拟机"><a href="#重启虚拟机" class="headerlink" title="重启虚拟机"></a>重启虚拟机</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">reboot</span><br></pre></td></tr></table></figure><p><img src="/Images/image-20240305204931600.png" alt="image-20240305204931600" style="zoom: 50%;" /></p><p>如此，我成功把一张照片复制到了桌面文件夹里。</p><h2 id="0x04-Linux终端命令"><a href="#0x04-Linux终端命令" class="headerlink" title="0x04 Linux终端命令"></a>0x04 Linux终端命令</h2><p>一些基本的cd，ls常用的先看看就好了。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 随手记 </tag>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>图论算法</title>
      <link href="/2024/03/01/%E5%9B%BE%E8%AE%BA%E7%AE%97%E6%B3%95/"/>
      <url>/2024/03/01/%E5%9B%BE%E8%AE%BA%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h2 id="0x01-Dijkstra算法（寻找有权图最短路径）"><a href="#0x01-Dijkstra算法（寻找有权图最短路径）" class="headerlink" title="0x01 Dijkstra算法（寻找有权图最短路径）"></a>0x01 Dijkstra算法（寻找有权图最短路径）</h2><p>看视频的讲解实现的，P4（<a href="https://www.bilibili.com/video/BV1hc41187JZ?p=4&amp;vd_source=bdd8551641c485c305190c0dc5e3875e">视频地址</a>）</p><p>这里默认源点是1，之后再改改自定义源点的，</p><p>这个算法的大致思路是，从一个源点开始，把他压入优先队列（小的先出），然后给存储最短路径的dis数组全部初始化无穷大，接着就可以开始循环了。只要队列不为空，我们就一直取队列里的元素，然后判断由这个节点到下个节点的路径是不是最小的，如果是就把下个节点压入队列，若不是就不压入。每个节点到源点的最短路径是递归而来的。</p><p><img src="/Images/image-20240227213034851.png" alt="image-20240227213034851"></p><p>算法就是一直在完善这个表。由于有优先队列存在，省去了无意义的路线判断，很大程度上一次就可以寻得最短路径，因为是从小权重的边开始寻路的。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">0x7fffffff</span>;</span><br><span class="line"><span class="type">int</span> m,n;<span class="comment">//m是边权方向设定数，n是顶点数</span></span><br><span class="line"><span class="type">int</span> x,y,w,temp_n,temp_w;<span class="comment">//顶点坐标xy，边权数w</span></span><br><span class="line"><span class="type">int</span> mat[<span class="number">100</span>][<span class="number">100</span>];</span><br><span class="line"><span class="type">int</span> dis[<span class="number">100</span>];</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">info</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">info</span>(<span class="type">int</span> node, <span class="type">int</span> weight)&#123;</span><br><span class="line">            <span class="keyword">this</span>-&gt;node = node;</span><br><span class="line">    <span class="keyword">this</span>-&gt;weight = weight;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">friend</span> <span class="type">bool</span> <span class="keyword">operator</span>&lt;(<span class="type">const</span> info &amp;info1, <span class="type">const</span> info &amp;info2)&#123;</span><br><span class="line">            <span class="keyword">return</span> info1.weight &gt; info2.weight;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> node;</span><br><span class="line">        <span class="type">int</span> weight;</span><br><span class="line">&#125;;</span><br><span class="line">priority_queue&lt;info&gt; q;</span><br><span class="line"><span class="comment">//求从源点1到各个顶点的最短路径</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Dijkstra</span><span class="params">(<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="comment">//初始化操作，dis初始化</span></span><br><span class="line">    dis[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        dis[i] = INF;</span><br><span class="line">    &#125;</span><br><span class="line">    q.<span class="built_in">emplace</span>(<span class="number">1</span>,dis[<span class="number">1</span>]);<span class="comment">//源点进入队列</span></span><br><span class="line">    <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        temp_n = q.<span class="built_in">top</span>().node, temp_w = q.<span class="built_in">top</span>().weight;</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;    </span><br><span class="line">            <span class="keyword">if</span>(mat[temp_n][i] != INF &amp;&amp; temp_n != i)&#123;</span><br><span class="line">                <span class="keyword">if</span>(temp_w + mat[temp_n][i] &lt; dis[i])&#123;</span><br><span class="line">                    dis[i] = temp_w + mat[temp_n][i];</span><br><span class="line">                    q.<span class="built_in">emplace</span>(i,dis[i]);</span><br><span class="line">                &#125;  </span><br><span class="line">            &#125;             </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i == j)&#123;</span><br><span class="line">                mat[i][j] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                mat[i][j] = INF;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">        cin &gt;&gt; x &gt;&gt; y &gt;&gt; w;</span><br><span class="line">        mat[x][y] = w;<span class="comment">//由x指向y，边权为w</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">Dijkstra</span>(n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        cout &lt;&lt; dis[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="0x03-Prim算法（寻找最小生成树）"><a href="#0x03-Prim算法（寻找最小生成树）" class="headerlink" title="0x03 Prim算法（寻找最小生成树）"></a>0x03 Prim算法（寻找最小生成树）</h2><p>首先记录一下什么是生成树，生成树是在一个连通的，无回环的无向图中，寻找能构成树的节点和边。</p><p>n个节点的图中，生成树必须是n个节点，n-1条边的。</p><p>最小生成树就是生成树中边权重之和最小的数。</p><p>最小生成树简单的应用在于修路问题，在原有的道路的基础上，铺设新的道路，最省钱，又能全部连通，这时候就要用到最小生成树了。</p><p>先记录一下Prim算法，算法的大致思路就是从一个源点开始，将他标记为树的节点，然后从树与剩余图连接的边中选择权重最小的边，将与该边连接的节点也纳入树中，以此类推，知道全部节点都成为树的一部分。</p><p><img src="/Images/image-20240227213926642.png" alt="image-20240227213926642"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">0x7fffffff</span>;</span><br><span class="line"><span class="type">int</span> m,n;<span class="comment">//m是边权方向设定数，n是顶点数</span></span><br><span class="line"><span class="type">int</span> x,y,w,ans = <span class="number">0</span>,temp_w,temp_n;<span class="comment">//顶点坐标xy，边权数w</span></span><br><span class="line"><span class="comment">//temp_w暂时存储边权，temp_n暂时存储节点</span></span><br><span class="line"><span class="type">int</span> mat[<span class="number">100</span>][<span class="number">100</span>];</span><br><span class="line"><span class="type">int</span> dis[<span class="number">100</span>];<span class="comment">//存储某个节点到树的距离</span></span><br><span class="line"><span class="type">bool</span> book[<span class="number">100</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Prim</span><span class="params">(<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">    dis[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    book[<span class="number">1</span>] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)&#123;<span class="comment">//初始化dis</span></span><br><span class="line">        dis[i] = <span class="built_in">min</span>(dis[i], mat[<span class="number">1</span>][i]);<span class="comment">//只有结点1的数，初始化设定到1的距离</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        temp_w = INF, temp_n = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">2</span>;j&lt;=n;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!book[j] &amp;&amp; dis[j] &lt; temp_w)&#123;</span><br><span class="line">                <span class="comment">//找到离树边权最小的节点</span></span><br><span class="line">                temp_n = j, temp_w = dis[j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(temp_n == <span class="number">-1</span>)&#123;<span class="comment">//若为-1，代表找不到节点，无法构成树</span></span><br><span class="line">            ans = INF;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        book[temp_n] = <span class="literal">true</span>;<span class="comment">//找到后把节点纳入树中</span></span><br><span class="line">        ans += temp_w;<span class="comment">//计算边权和</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">2</span>;j&lt;=n;j++)&#123;<span class="comment">//更新节点离树的边权，未被访问到的节点dis为INF</span></span><br><span class="line">            dis[j] = <span class="built_in">min</span>(dis[j], mat[temp_n][j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i == j)&#123;</span><br><span class="line">                mat[i][j] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                mat[i][j] = INF;</span><br><span class="line">            &#125;</span><br><span class="line">            dis[i] = INF;<span class="comment">//给dis全设置为正无穷</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">        cin &gt;&gt; x &gt;&gt; y &gt;&gt; w;</span><br><span class="line">        mat[x][y] = mat[y][x] = w;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">Prim</span>(n);</span><br><span class="line">    cout &lt;&lt; ans;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="0x04-Kruskal算法（寻找最小生成树）"><a href="#0x04-Kruskal算法（寻找最小生成树）" class="headerlink" title="0x04 Kruskal算法（寻找最小生成树）"></a>0x04 Kruskal算法（寻找最小生成树）</h2><p>Kruskal算法的和Prim算法的区别在于，他的核心点在于边和森林。一开始把图看成一个森林，然后选取边权最小的边事先合并，逐渐把森林连接成树。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">edge</span>&#123;<span class="comment">//边类</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">edge</span>(<span class="type">int</span> x,<span class="type">int</span> y,<span class="type">int</span> w)&#123;</span><br><span class="line">            <span class="keyword">this</span>-&gt;w = w, <span class="keyword">this</span>-&gt;x = x, <span class="keyword">this</span>-&gt;y = y;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> x,y,w;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(edge &amp;p1, edge &amp;p2)</span></span>&#123;<span class="comment">//sort判断函数重载</span></span><br><span class="line">    <span class="keyword">if</span>(p1.w &lt; p2.w)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> n, m, x, y, w, ans=<span class="number">0</span>, cnt=<span class="number">0</span>;</span><br><span class="line">vector&lt;edge&gt; T;<span class="comment">//边容器T</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; tree;<span class="comment">//下标代表节点，值代表树</span></span><br><span class="line"><span class="comment">//比如tree[1] = 1, tree[2] = 1,说明节点1和节点2在同一颗树内，初始每个节点在不同树内</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Kruskal</span><span class="params">(<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="built_in">sort</span>(T.<span class="built_in">begin</span>(),T.<span class="built_in">end</span>(),cmp);<span class="comment">//根据边权排序，从小到大</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=n;i++)&#123;<span class="comment">//tree初始化</span></span><br><span class="line">        tree.<span class="built_in">push_back</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;<span class="comment">//遍历m条边</span></span><br><span class="line">        <span class="keyword">if</span>(tree[T[i].x] != tree[T[i].y])&#123;<span class="comment">//若不在同一树内</span></span><br><span class="line">            ans += T[i].w;</span><br><span class="line">            cnt++;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)&#123;<span class="comment">//遍历节点修改节点所属的树</span></span><br><span class="line">                <span class="keyword">if</span>(tree[j] == tree[T[i].y])&#123;</span><br><span class="line">                    tree[j] = tree[T[i].x];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(cnt != n<span class="number">-1</span>)&#123;<span class="comment">//如果构不成树</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;error&quot;</span>;</span><br><span class="line">        ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="comment">//由于这个算法主要是分析边的，这里就不读取mat了</span></span><br><span class="line">    T.<span class="built_in">emplace_back</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>);<span class="comment">//占0下标，方便从1开始循环</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">        <span class="comment">//读取图的边</span></span><br><span class="line">        cin &gt;&gt; x &gt;&gt; y &gt;&gt; w;</span><br><span class="line">        T.<span class="built_in">emplace_back</span>(x,y,w);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">Kruskal</span>(n);</span><br><span class="line">    cout &lt;&lt; ans;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="并查集优化"><a href="#并查集优化" class="headerlink" title="并查集优化"></a>并查集优化</h3><p>写完这个算法后，询问了一下大佬的意见，连接树这一部分可以用并查集算法优化。</p><p>同样设置一个tree数组，tree下标代表节点，这时候值则代表节点的双亲节点（parents[ ]）。</p><p>例如 tree[1] = 2，说明节点1往上查找是节点2。当数组值等于数组下标时，说明该节点是其所属树的根结点，因为无法再溯源了，很好理解（自己的双亲节点是自己，就是没有了）。</p><p>这时候查找一个节点的所属树时，只要找到他的根结点，跟另一个节点的根节点比较，若相同则说明两者有同一祖宗，不相等则不是，这时候把其中任意根结点的值改成另一根结点的值，使得两者有共同祖宗，就所属同一棵树了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x != parents[x])&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">find</span>(parents[x]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个算法中，若该节点x不是根结点，继续回溯，判断x的双亲节点是不是根结点，直到找到后返回根结点。</p><p>虽然这个算法满足了回溯找祖宗的功能，但没有在过去的查找中逐渐优化树，让下一次的查找无需多次return。</p><p>如果能在每次查找中优化树结构，让本来由1 -&gt; 2 -&gt; 3 的树，变成1 -&gt; 3 ，2 -&gt; 3，的少层多孩子的树，能大大减少查找的时间，使得1无需经过两次回溯才能找到根节点。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x != parents[x])&#123;</span><br><span class="line">        parents[x] = <span class="built_in">find</span>(parents[x]);</span><br><span class="line">    &#125;   </span><br><span class="line">    <span class="keyword">return</span> parents[x];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>每次查找失败后，将双亲节点的值赋值为祖宗节点。</p><p>这里顺便把sort排序用于判断的小于号重载并用友元全局函数封装进edge类内，让整体感更强。</p><p>优化后的算法如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">edge</span>&#123;<span class="comment">//边类</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">edge</span>(<span class="type">int</span> x,<span class="type">int</span> y,<span class="type">int</span> w)&#123;</span><br><span class="line">            <span class="keyword">this</span>-&gt;w = w, <span class="keyword">this</span>-&gt;x = x, <span class="keyword">this</span>-&gt;y = y;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">friend</span> <span class="type">bool</span> <span class="keyword">operator</span>&lt;(<span class="type">const</span> edge &amp;edge1,<span class="type">const</span> edge &amp;edge2)&#123;<span class="comment">//重载小于号，方便sort排序</span></span><br><span class="line">            <span class="keyword">return</span> edge1.w &lt; edge2.w;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> x,y,w;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> n, m, x, y, w, ans=<span class="number">0</span>, cnt=<span class="number">0</span>;</span><br><span class="line">vector&lt;edge&gt; T;<span class="comment">//边容器T</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; parents;<span class="comment">//下标代表节点，值代表双亲节点</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x != parents[x])&#123;</span><br><span class="line">        parents[x] = <span class="built_in">find</span>(parents[x]);</span><br><span class="line">    &#125;   </span><br><span class="line">    <span class="keyword">return</span> parents[x];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Kruskal</span><span class="params">(<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="built_in">sort</span>(T.<span class="built_in">begin</span>(),T.<span class="built_in">end</span>());<span class="comment">//根据边权排序，从小到大</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=n;i++)&#123;<span class="comment">//tree初始化</span></span><br><span class="line">        parents.<span class="built_in">push_back</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;<span class="comment">//遍历m条边</span></span><br><span class="line">        x = <span class="built_in">find</span>(T[i].x), y = <span class="built_in">find</span>(T[i].y);</span><br><span class="line">        <span class="keyword">if</span>(x != y)&#123;<span class="comment">//若不在同一树内</span></span><br><span class="line">            parents[x] = y;</span><br><span class="line">            ans += T[i].w;</span><br><span class="line">            cnt++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(cnt != n<span class="number">-1</span>)&#123;<span class="comment">//如果构不成树</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;error&quot;</span>;</span><br><span class="line">        ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="comment">//由于这个算法主要是分析边的，这里就不读取mat了</span></span><br><span class="line">    T.<span class="built_in">emplace_back</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>);<span class="comment">//占0下标，方便从1开始循环</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">        <span class="comment">//读取图的边</span></span><br><span class="line">        cin &gt;&gt; x &gt;&gt; y &gt;&gt; w;</span><br><span class="line">        T.<span class="built_in">emplace_back</span>(x,y,w);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">Kruskal</span>(n);</span><br><span class="line">    cout &lt;&lt; ans;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="0x05-网络流问题Nework-Flow"><a href="#0x05-网络流问题Nework-Flow" class="headerlink" title="0x05 网络流问题Nework Flow"></a>0x05 网络流问题Nework Flow</h2><p><img src="/Images/image-20240229123902886.png" alt="image-20240229123902886" style="zoom: 50%;" /></p><p>如图就是一个经典网络流问题，从起点S出发，流量不超过最大容量（边权），最多能有多少流量到终点T。</p><p>这里先介绍一种基础的计算网络流的办法，这种办法算出来不一定正确。</p><p>先找到一条从S到T的简单路径，然后各种短板效应找到通过该路径的最大流量，接着用容量减去流量计算出空闲量，更新上面的空闲量图</p><p><img src="/Images/image-20240229124820753.png" alt="image-20240229124820753" style="zoom:50%;" /></p><p>更新后如图，继续寻找从S到T的简单路径，直到找不到从S到T的路径。</p><p>这个算法当选择路径的顺序正确时，能够计算出最大流量，但多数时候路径的选择顺序是不固定的，选择的不是最优解也无法回头再来。</p><h2 id="0x06-Ford-Fulkerson算法"><a href="#0x06-Ford-Fulkerson算法" class="headerlink" title="0x06 Ford-Fulkerson算法"></a>0x06 Ford-Fulkerson算法</h2><p>这个算法一定能找到最大流，介绍一下大致思想，为下一个E-K算法做铺垫。</p><p>先创建一个residual graph，然后开始循环找从起点到终点的简单路径，和上节介绍的方法一样，但是在每次更新得到residual graph后，在原先的Flow上添加一条方向路径（如图绿色）</p><p><img src="/Images/image-20240229130256745.png" alt="image-20240229130256745" style="zoom:50%;" /></p><p>这条反向路径的在之后寻找从起点到终点的简单路径时是可以选择的，他的存在使得Flow的选择能够反悔，例如图中从S到T流向了三份水后，添加的反向路径使得水能够动态的从T流回S，之后若选择的路径通过的Flow不好，也可以通过反向路径流动水，一来一回相当于水没流动，修改路径上水的Flow。</p><h3 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><p>但是F-F算法选择路径的方式是随机的，最坏的情况下时间复杂度为O(f*m)（f是最大流量，m是边的数量）</p><p>O(m)用来寻找从起点到终点的路径，O(f)则是最坏情况下的循环找路径次数。</p><h2 id="0x07-Edmonds-Karp算法（F-F算法特例）"><a href="#0x07-Edmonds-Karp算法（F-F算法特例）" class="headerlink" title="0x07 Edmonds-Karp算法（F-F算法特例）"></a>0x07 Edmonds-Karp算法（F-F算法特例）</h2><p>基于F-F算法，E-K算法在寻找路径时添加了一条规则，优先选择最短路径（把图看成有向无权图）</p><p>最坏情况下时间复杂度为O(m <em> m </em> n)，时间复杂度与最大流无关（m是边的数量，n是节点数）</p><h3 id="代码实现思路"><a href="#代码实现思路" class="headerlink" title="代码实现思路"></a>代码实现思路</h3><p>先写一个无权图的最短路径BFS算法，根据这个算法，遍历每个节点，记录到源点的最短路径，节点的前驱节点，并且在计算的过程中，更新当前路径的最大容量。思路是先设置一个info节点类，维护节点编号、最短路径和前驱节点，然后设置一个mat图二维数组，存储residual图（初始是有向容量图），维护着图的各种路径，方向路径等。（邻接矩阵法）</p><p>先贴个网址，以后再补：<a href="https://blog.csdn.net/qq_45361883/article/details/106860975">最大流问题——Ford Fulkerson算法_fordfulkerson算法求最大流-CSDN博客</a></p><p><a href="https://www.cnblogs.com/Icys/p/15122777.html">                                          三种网络流（最大流）的实现算法讲解与代码 - Icys - 博客园 (cnblogs.com)</a></p><p>完结撒花，已经补全了，真是道阻且长！！</p><p>这里用的是新的链式前向星存储图的思路，重点在于找到最短路径并计算最大Flow这个操作，该算法巧妙的用一个数组last存储指向某个节点的边的编号，再通过反向路径编号=正向路径编号+1的存取方式，将正反向路径的to（指向的节点编号）联动起来，成功实现溯源，遍历路径节点的同时修改边权（边的容量剩余量）的操作，我觉得很妙，思路主要来源于第二篇文章。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Edge</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">Edge</span>(<span class="type">int</span> to,<span class="type">int</span> w,<span class="type">int</span> next)&#123;</span><br><span class="line">            <span class="comment">//Next，表示与这个边起点相同的上一条边的编号</span></span><br><span class="line">            <span class="comment">//to，表示边指向的节点，w是边权（容量）</span></span><br><span class="line">            <span class="keyword">this</span>-&gt;next = next, <span class="keyword">this</span>-&gt;to = to, <span class="keyword">this</span>-&gt;w = w;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> to,w,next;</span><br><span class="line">&#125;;</span><br><span class="line">vector&lt;Edge&gt; edge;</span><br><span class="line"><span class="type">int</span> cnt = <span class="number">1</span>,head[<span class="number">100</span>];<span class="comment">//初始化-1</span></span><br><span class="line"><span class="type">int</span> n,m,x,y,w,s,t,INF = <span class="number">0x7fffffff</span>;</span><br><span class="line"><span class="type">int</span> last[<span class="number">100</span>],flow[<span class="number">100</span>];<span class="comment">//last记录从S到T的完整路径，flow记录到该节点的流量</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add_edge</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v,<span class="type">int</span> w)</span></span>&#123;<span class="comment">//u起点，v终点，w边权</span></span><br><span class="line">    edge[cnt].to = v;</span><br><span class="line">    edge[cnt].w = w;</span><br><span class="line">    edge[cnt].next = head[u];<span class="comment">//以u为起点最后一条边的编号，也就是与这个边起点相同的上一条边的编号</span></span><br><span class="line">    <span class="comment">//这时候edge[cnt]变成以u起点的最后一条边，存储进head，然后cnt++</span></span><br><span class="line">    head[u] = cnt++;</span><br><span class="line">&#125;    </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">(<span class="type">int</span> m)</span></span>&#123;<span class="comment">//初始化head，m代表边数</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">        head[i] = <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">bfs</span><span class="params">(<span class="type">int</span> s,<span class="type">int</span> t,<span class="type">int</span> n)</span></span>&#123;<span class="comment">//搜索从s到t的最短路径，找出最小容量，并生成一个last数组供查询</span></span><br><span class="line">    <span class="type">int</span> temp_n,dis[<span class="number">100</span>];<span class="comment">//dis用来寻找最短路径</span></span><br><span class="line">    <span class="type">bool</span> vis[<span class="number">100</span>] = &#123;<span class="literal">false</span>&#125;;<span class="comment">//各点访问情况</span></span><br><span class="line">    queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        dis[i] = INF;<span class="comment">//初始化INF</span></span><br><span class="line">        last[i] = <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    dis[s] = <span class="number">0</span>;</span><br><span class="line">    q.<span class="built_in">push</span>(s);</span><br><span class="line">    flow[s] = INF;</span><br><span class="line">    <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        temp_n = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">if</span>(temp_n == t)&#123;</span><br><span class="line">            <span class="keyword">break</span>;<span class="comment">//找到终点t了，直接break</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=head[temp_n];i!=<span class="number">-1</span>;i=edge[i].next)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!vis[edge[i].to] &amp;&amp; edge[i].w&gt;<span class="number">0</span>)&#123;<span class="comment">//节点未有水流过，且到达节点的边的容量不为0</span></span><br><span class="line">                dis[edge[i].to] = dis[temp_n] + <span class="number">1</span>;<span class="comment">//更新未访问过的点的路径（这里用不到，找最短路径用）</span></span><br><span class="line">                last[edge[i].to] = i;<span class="comment">//到edge[i].to这个点要走边i</span></span><br><span class="line">                flow[edge[i].to] = <span class="built_in">min</span>(flow[temp_n],edge[i].w);<span class="comment">//记录当前节点的水量</span></span><br><span class="line">                vis[edge[i].to] = <span class="literal">true</span>;<span class="comment">//表示访问过</span></span><br><span class="line">                q.<span class="built_in">push</span>(edge[i].to);<span class="comment">//入栈</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> last[t]!=<span class="number">-1</span>;<span class="comment">//找到s到t的路径就返回true</span></span><br><span class="line">&#125;   </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">max_flow</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> maxflow = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">bfs</span>(s,t,n))&#123;</span><br><span class="line">        maxflow += flow[t];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=t;i!=s;i = edge[last[i]+<span class="number">1</span>].to)&#123;<span class="comment">//这个last[i]得到路径里指向i的边的编号，然后编号+1得到反向边，</span></span><br><span class="line">        <span class="comment">//接着取这条边的to，就是找到指向结点i的边的起点，这样一步步反向回溯路径直到起点s</span></span><br><span class="line">            edge[last[i]].w -= flow[t];<span class="comment">//减去流量得到边的容量剩余量</span></span><br><span class="line">            edge[last[i]+<span class="number">1</span>].w += flow[t];<span class="comment">//添加反向路径</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxflow;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    edge.<span class="built_in">resize</span>(<span class="number">100</span>,<span class="built_in">Edge</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>));</span><br><span class="line">    <span class="built_in">init</span>(m);<span class="comment">//初始化head</span></span><br><span class="line">    cin &gt;&gt; s &gt;&gt; t;<span class="comment">//记录起点到终点</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">        cin &gt;&gt; x &gt;&gt; y &gt;&gt; w;</span><br><span class="line">        <span class="built_in">add_edge</span>(x,y,w);<span class="comment">//添加正向边，编号为奇数</span></span><br><span class="line">        <span class="built_in">add_edge</span>(y,x,<span class="number">0</span>);<span class="comment">//添加初始容量为0的反向边，编号是偶数</span></span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt; <span class="built_in">max_flow</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="0x08-Dinic’s算法（有点复杂但更快）"><a href="#0x08-Dinic’s算法（有点复杂但更快）" class="headerlink" title="0x08 Dinic’s算法（有点复杂但更快）"></a>0x08 Dinic’s算法（有点复杂但更快）</h2><p>关键在于blocking graph，level graph和residual graph</p><p>该算法引入了level graph层级图这个概念，先记录一下层级图</p><h3 id="Level-Graph"><a href="#Level-Graph" class="headerlink" title="Level Graph"></a>Level Graph</h3><p>层级图的构建，从起点S开始，能从S一步到达的节点为一层，从一层节点一步到达的节点为二层节点（访问过的节点不算），直到访问到终点T。</p><p><img src="/Images/image-20240229205316906.png" alt="image-20240229205316906" style="zoom: 33%;" /></p><h3 id="Blocking-Graph"><a href="#Blocking-Graph" class="headerlink" title="Blocking Graph"></a>Blocking Graph</h3><p>阻流图，其实就是0x05节介绍简单网络流问时，用于初步解决的简单算法得到的Flow graph，不一定是最大流，只要是把通往终点T的容量全部填满就好了。（在d算法中，阻塞流计算用于level graph）</p><p><img src="/Images/image-20240229205959257.png" alt="image-20240229205959257" style="zoom:33%;" /></p><h3 id="Dinic’s算法流程"><a href="#Dinic’s算法流程" class="headerlink" title="Dinic’s算法流程"></a>Dinic’s算法流程</h3><p>算法需要准备一个residual graph，每次循环都根据residual graph更新level graph，然后再在residual graph中减去level graph中的阻塞流，得到新的residual graph，然后再在residual中添加反向路径（和F-F算法中的思路一样），反向路径也算实际存在的路径，用于level graph的构建，一直循环知道level graph没法构建，算法就结束，这时候用Original graph（原图）的，和起点S相连边的容量减去它的residual（空闲量），就能得到最大流量。（公式：Original - Residual = Flow）</p><h2 id="0x09-图的存储"><a href="#0x09-图的存储" class="headerlink" title="0x09 图的存储"></a>0x09 图的存储</h2><h3 id="邻接矩阵"><a href="#邻接矩阵" class="headerlink" title="邻接矩阵"></a>邻接矩阵</h3><p>邻接矩阵矩阵属于是好写但效率低的存储方式，挺实用的数据结构。</p><p>建立一个二维数组mat[x] [y]，表示x -&gt; y，权值为数组mat的值weight，例如节点1到节点2的边权值为5，记为mat[1] [2]  = 5。很好理解。</p><h3 id="链式前向星"><a href="#链式前向星" class="headerlink" title="链式前向星"></a>链式前向星</h3><p>链式前向星的存储主体是边，是以【1，n】为起点的边的集合，例如将以1为起点的边的集合放在一起：</p><p>1：1 5 6，1 3 4，1 2 1，2： 2 3 2 …………</p><p>知道这个后，得先了解几个变量的含义：</p><p>Next，表示与这个边起点相同的上一条边的编号。</p><p>head[ i ]数组，表示以 i 为起点的最后一条边的编号（一般初始化为-1）。</p><p>cnt，用来记录边的编号（我习惯从1开始）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Edge</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">Edge</span>(<span class="type">int</span> to,<span class="type">int</span> w,<span class="type">int</span> next)&#123;</span><br><span class="line">            <span class="comment">//Next，表示与这个边起点相同的上一条边的编号</span></span><br><span class="line">            <span class="comment">//to，表示边指向的节点，w是边权</span></span><br><span class="line">            <span class="keyword">this</span>-&gt;next = next, <span class="keyword">this</span>-&gt;to = to, <span class="keyword">this</span>-&gt;w = w;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> to,w,next;</span><br><span class="line">&#125;;</span><br><span class="line">vector&lt;Edge&gt; edge;</span><br><span class="line"><span class="type">int</span> cnt = <span class="number">1</span>,head[<span class="number">100</span>];<span class="comment">//初始化-1</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add_edge</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v,<span class="type">int</span> w)</span></span>&#123;<span class="comment">//u起点，v终点，w边权</span></span><br><span class="line">    edge[cnt].to = v;</span><br><span class="line">    edge[cnt].w = w;</span><br><span class="line">    edge[cnt].next = head[u];<span class="comment">//以u为起点最后一条边的编号，也就是与这个边起点相同的上一条边的编号</span></span><br><span class="line">    <span class="comment">//这时候edge[cnt]变成以u起点的最后一条边，存储进head，然后cnt++</span></span><br><span class="line">    head[u] = cnt++;</span><br><span class="line">&#125;    </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">(<span class="type">int</span> m)</span></span>&#123;<span class="comment">//初始化head，m代表边数</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">        head[m] = <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    edge.<span class="built_in">resize</span>(<span class="number">100</span>,<span class="built_in">Edge</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>));<span class="comment">//这里容器edge也要初始化一下</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以说为什么要给head数初始化-1呢？每次读入边时，就会记入edge[cnt].next，表示同起点的上一条边的编号，那么第一条边的next就会被head赋值成-1，当你读取边时，edge[cnt].next == -1为终止条件（从后到前）</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基础 </tag>
            
            <tag> C++ </tag>
            
            <tag> 算法 </tag>
            
            <tag> 数据结构 </tag>
            
            <tag> 图论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>STL队列和栈</title>
      <link href="/2024/02/24/STL%E9%98%9F%E5%88%97%E5%92%8C%E6%A0%88/"/>
      <url>/2024/02/24/STL%E9%98%9F%E5%88%97%E5%92%8C%E6%A0%88/</url>
      
        <content type="html"><![CDATA[<h2 id="0x01-栈"><a href="#0x01-栈" class="headerlink" title="0x01 栈"></a>0x01 栈</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stack&gt;</span></span></span><br></pre></td></tr></table></figure><p>先记录一下栈stack。</p><p>和数据结构教材讲的性质基本一致，这里记录一下STL实现栈的方法。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stack&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> Container = deque&lt;T&gt;&gt;</span><br></pre></td></tr></table></figure><p>栈的类模板，第一个参数是存储对象的类型，第二个参数是底层容器的类型。</p><p><img src="/Images/image-20240225200412230.png" alt="image-20240225200412230" style="zoom:80%;" /></p><p>还有一个swap函数，swap(stack<T> &amp;other_stack)，能将当前栈中的元素和参数中的元素交换。stack模板还有赋值运算符重载，operator=( )。</p><p>访问栈：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">deque&lt;<span class="type">int</span>&gt; data&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;; </span><br><span class="line"><span class="comment">//初始化一个栈</span></span><br><span class="line"><span class="function">stack&lt;<span class="type">int</span>&gt; <span class="title">data</span><span class="params">(data)</span></span>; </span><br><span class="line">cout&lt;&lt;<span class="string">&quot;data : &quot;</span>&lt;&lt;data.<span class="built_in">size</span>()&lt;&lt;endl; </span><br><span class="line"><span class="keyword">while</span>(!data.<span class="built_in">empty</span>())&#123;   </span><br><span class="line">    <span class="comment">//获得栈顶元素</span></span><br><span class="line">cout&lt;&lt;data.<span class="built_in">top</span>()&lt;&lt;<span class="string">&quot; &quot;</span>;  </span><br><span class="line">    <span class="comment">//栈顶元素出栈 </span></span><br><span class="line">data.<span class="built_in">pop</span>();</span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;endl; </span><br><span class="line">cout&lt;&lt;<span class="string">&quot;data : &quot;</span>&lt;&lt;data.<span class="built_in">size</span>()&lt;&lt;endl;</span><br></pre></td></tr></table></figure><h2 id="0x02-队列"><a href="#0x02-队列" class="headerlink" title="0x02 队列"></a>0x02 队列</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br></pre></td></tr></table></figure><p>stack和queue这类模板在初始化时，都默认封装了一个deque<T>容器，修改第二个参数的模板类型能使用其他自定义的容器。</p><p><img src="/Images/image-20240225201211734.png" alt="image-20240225201211734" style="zoom:80%;" /></p><p>这里顺便记录一下emplace是什么吧，我当时看的时候也不懂，看这个例子就完全明白了</p><p><img src="/Images/image-20240225203600168.png" alt="image-20240225203600168" style="zoom: 80%;" />也有赋值运算符重，也有swap函数，也有拷贝构造函数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">list&lt;<span class="type">int</span>&gt; data_&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;; </span><br><span class="line">queue&lt;<span class="type">int</span>,list&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">q</span>(data_); </span><br><span class="line"><span class="comment">//list容器初始化队列</span></span><br><span class="line">queue&lt;<span class="type">int</span>,list&lt;<span class="type">int</span>&gt;&gt; copy_q &#123;q&#125;; </span><br><span class="line"><span class="comment">//拷贝构造新队列</span></span><br></pre></td></tr></table></figure><p>这里补充一下，list容器类似于链表，deque容器类似于vector，但是是双端数组，可以对头部进行插入和删除。具体操作再看。</p><p>栈和队列两种模板默认封装deque容器，更利于头尾的修改。</p><h2 id="0x03-堆（优先队列）"><a href="#0x03-堆（优先队列）" class="headerlink" title="0x03 堆（优先队列）"></a>0x03 堆（优先队列）</h2><p>优先队列具有队列的所有特性，包括基本操作，只是在这基础上添加了内部的一个排序，它本质是一个堆实现的。他和queue不同的就在于我们可以自定义其中数据的优先级, 让优先级高的排在队列前面,优先出队。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">priority_queue&lt;Type, Container, Functional&gt;</span><br></pre></td></tr></table></figure><p>Type就是数据类型，Container就是容器类型，STL里默认vector。Functional就是比较的方式（是一个仿函数，重载了括号），默认大顶堆</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//升序队列（小顶堆）</span></span><br><span class="line">priority_queue &lt;<span class="type">int</span>,vector&lt;<span class="type">int</span>&gt;,greater&lt;<span class="type">int</span>&gt; &gt; q;</span><br><span class="line"><span class="comment">//降序队列（大顶堆）</span></span><br><span class="line">priority_queue&lt;<span class="type">int</span>&gt; a;（默认大顶堆）</span><br><span class="line">priority_queue &lt;<span class="type">int</span>,vector&lt;<span class="type">int</span>&gt;,less&lt;<span class="type">int</span>&gt; &gt;q;</span><br></pre></td></tr></table></figure><p>如果你用的不是int这种基本数据类型，比如比较两个类，那么就要填入自己重载后的运算符了。</p><p><a href="https://blog.csdn.net/weixin_36888577/article/details/79937886">c++优先队列(priority_queue)用法详解</a></p><p><a href="https://zhuanlan.zhihu.com/p/352404451">C++ STL 之 stack 和 queue</a></p><p><a href="https://blog.csdn.net/penghuicheng/article/details/51505625">C++11新特性emplace操作</a></p><p><a href="https://blog.csdn.net/qq_46514118/article/details/120698465">优先队列自定义类型</a></p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 进阶 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vector容器基础</title>
      <link href="/2024/02/24/vector%E5%AE%B9%E5%99%A8/"/>
      <url>/2024/02/24/vector%E5%AE%B9%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="0x01-vector构造函数"><a href="#0x01-vector构造函数" class="headerlink" title="0x01 vector构造函数"></a>0x01 vector构造函数</h2><p><img src="/Images/adfb98be36cf58f17c2a79b8087f429.png" alt="adfb98be36cf58f17c2a79b8087f429"></p><p>除了第一种，其他几种基本都是拷贝构造而来的。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt;<span class="built_in">v</span>(<span class="number">10</span>,<span class="number">100</span>);</span><br><span class="line"><span class="comment">//压入10个100的int数</span></span><br></pre></td></tr></table></figure><p>拷贝构造函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt;<span class="built_in">v2</span>(v);</span><br><span class="line"><span class="comment">//拷贝了v的10个100</span></span><br></pre></td></tr></table></figure><h2 id="0x02-vector赋值操作"><a href="#0x02-vector赋值操作" class="headerlink" title="0x02 vector赋值操作"></a>0x02 vector赋值操作</h2><p><img src="/Images/image-20240219145512229.png" alt="image-20240219145512229"></p><p>第一种就是等号运算符重载，直接v1 = v2赋值就好了。</p><h2 id="0x03-vector容量和大小"><a href="#0x03-vector容量和大小" class="headerlink" title="0x03 vector容量和大小"></a>0x03 vector容量和大小</h2><p><img src="/Images/image-20240219153402588.png" alt="image-20240219153402588"></p><p>empty( )，若容量为空则返回true，不为空则返回false。</p><p>capacity( )是返回容器的容量的函数，容器的容量不小于容器中元素的个数（常识）。</p><p>resize函数能调整容器的大小（长度size，并非容量）。</p><p>resize函数若不指定填充的元素elem，则默认填充0。</p><h2 id="0x04-vector插入和删除"><a href="#0x04-vector插入和删除" class="headerlink" title="0x04 vector插入和删除"></a>0x04 vector插入和删除</h2><p><img src="/Images/image-20240219160518544.png" alt="image-20240219160518544"></p><p>这里重点记录一下迭代器修改元素的方法。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//迭代器插入法</span></span><br><span class="line">v1.<span class="built_in">insert</span>(v1.<span class="built_in">begin</span>(),<span class="number">100</span>);</span><br><span class="line"><span class="comment">//在v1.begin()的位置插入100，v1.begin()是指向首元的迭代器</span></span><br></pre></td></tr></table></figure><p>注意const_iterator pos 位置是传入迭代器就好了。</p><h2 id="0x05-vector数据存取"><a href="#0x05-vector数据存取" class="headerlink" title="0x05 vector数据存取"></a>0x05 vector数据存取</h2><p><img src="/Images/image-20240219161554444.png" alt="image-20240219161554444"></p><p>没啥好注意的，一般都用[ ]重载来访问</p><h2 id="0x06-vector互换容器"><a href="#0x06-vector互换容器" class="headerlink" title="0x06 vector互换容器"></a>0x06 vector互换容器</h2><p><img src="/Images/image-20240219161831638.png" alt="image-20240219161831638"></p><p>实现两个容器内元素进行互换。</p><p>巧用swap可以收缩内存空间。</p><p>实际情况：假设你定义了一个容量很大的容器时，若当你不需要使用这么大的容量时，通过resize函数只能改变容器的大小，而容量不会改变，这时候多余的容量就遭到了浪费。</p><p>比如你push_back了10000个数据，容量会给你自动扩展到约13000的数据，这时候你resize(3)，将容器的大小调整至3，这时候容量依然是13000左右。这会造成浪费！！！</p><p>解决方法，匿名函数和swap函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(v).<span class="built_in">swap</span>(v);</span><br></pre></td></tr></table></figure><p>vector<int>(v) 默认构造匿名对象。这里会根据v目前所用的元素个数的大小来初始化匿名对象，在这里的例子里，大小为3。</p><p>然后调用 .swap(v)，v的容量经过swap交换后是 3，大小（size）也是 3，不会造成空间浪费了，匿名对象的容量经过swap后占用很大，但是在这一行执行完后匿名对象会被销毁，就不会造成空间浪费了。</p><p><img src="/Images/image-20240219182013042.png" alt="image-20240219182013042"></p><h2 id="0x07-vector预留空间"><a href="#0x07-vector预留空间" class="headerlink" title="0x07 vector预留空间"></a>0x07 vector预留空间</h2><p><img src="/Images/image-20240219182129095.png" alt="image-20240219182129095"></p><p>预留空间是为了，减少vector在动态扩展容量时的扩展次数。</p><p>vector容器在创建的时候是会先预留较多的空间来应对之后的扩展，比如我push_back了10个数据，编译器会事先将这个vector容器的容量设定成100多（大概的，反正比容器大小，元素个数多）。当你继续扩展这个容器时，可能超过了事先预留好的容量，这时候编译器会将原先的容器内的数据拷贝到一个新的，容量更大的容器中，虽然容器的名字不会变，但是该容器的首地址会发生了改变（因为数据被拷贝存储到了一个新开辟的空间）。</p><p>经过浅显的测试，10000个数据在push_back时大约会发生30次的新开辟存储空间的情况，浪费了时间资源。</p><p>测试代码如下</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line"><span class="comment">//统计开辟次数</span></span><br><span class="line"><span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> *p = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++)&#123;</span><br><span class="line">    v.<span class="built_in">push_back</span>(i);</span><br><span class="line">    <span class="comment">//当每次开辟新空间时，v[0]的地址就会变化，以此为参照统计开辟次数</span></span><br><span class="line">    <span class="keyword">if</span>(p!= &amp;v[<span class="number">0</span>])&#123;</span><br><span class="line">        p = &amp;v[<span class="number">0</span>];</span><br><span class="line">        cnt++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; cnt;</span><br></pre></td></tr></table></figure><p>所以一开始就先预留出容量，能减少扩展次数。</p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 进阶 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>线段树转载记录</title>
      <link href="/2024/02/24/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%A7%8D%E4%B8%80%E9%A2%97%E6%A0%91/"/>
      <url>/2024/02/24/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%A7%8D%E4%B8%80%E9%A2%97%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<p><a href="https://zhuanlan.zhihu.com/p/106118909">原文章（线段树）</a></p><h2 id="0x01-种一颗线段树"><a href="#0x01-种一颗线段树" class="headerlink" title="0x01 种一颗线段树"></a>0x01 种一颗线段树</h2><p>假如我现在有一个数组A，总共有n个元素，我既想实现区间修改，又想单个修改，这时候种一颗线段树来维护这个数组，能平衡收益。</p><h2 id="0x02-怎么建立？"><a href="#0x02-怎么建立？" class="headerlink" title="0x02 怎么建立？"></a>0x02 怎么建立？</h2><p>线段树是一颗平衡二叉树，双亲结点是区间的和，左右子节点是双亲区间分两半的区间</p><p><img src="../../..//Images/image-20240224211506204.png" alt="image-20240224211506204" style="zoom: 50%;" /></p><p>每个节点 p 的左右子节点的编号分别为 2p 和 2p+1，假设 双亲结点p 的为区间 [l , r]的和。</p><p>设 mid = [(l + r)/2]，那么两个子节点分别存储[l , mid] 和 [mid+1 , r]的和。可以发现，左节点对应的区间长度，与右节点相同或者比之恰好多1。</p><p>知道这些后，便可以用递归的方法来种一颗线段树了。大体的思想就是，从叶子结点开始，从下往上逐步建立。这便是递归的思想</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(elem l = <span class="number">1</span>, elem r = n, elem p = <span class="number">1</span>)</span></span>&#123;</span><br><span class="line"><span class="comment">// 到达叶子节点</span></span><br><span class="line">    <span class="keyword">if</span> (l == r)&#123; </span><br><span class="line">    <span class="comment">// 到达叶子节点</span></span><br><span class="line">        tree[p] = A[l];</span><br><span class="line">        <span class="comment">// 用数组中的数据赋值</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        elem mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">        <span class="built_in">build</span>(l, mid, p * <span class="number">2</span>); </span><br><span class="line">        <span class="comment">// 先建立左右子节点</span></span><br><span class="line">        <span class="built_in">build</span>(mid + <span class="number">1</span>, r, p * <span class="number">2</span> + <span class="number">1</span>);</span><br><span class="line">        tree[p] = tree[p * <span class="number">2</span>] + tree[p * <span class="number">2</span> + <span class="number">1</span>]; </span><br><span class="line">        <span class="comment">// 该节点的值等于左右子节点之和</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="0x03-修改维护"><a href="#0x03-修改维护" class="headerlink" title="0x03 修改维护"></a>0x03 修改维护</h2><p>在讲区间修改前，要先引入一个 “<strong>懒标记</strong>”（lazy） 的概念。懒标记是线段树的精髓所在。对于区间修改，朴素的想法是用<strong>递归</strong>的方式一层层修改（类似于线段树的建立），但这样的时间复杂度比较高。使用懒标记后，对于那些正好是线段树节点的区间，我们不继续递归下去，而是打上一个<strong>标记</strong>，将来要用到它的<strong>子区间</strong>的时候，再向下<strong>传递</strong>。</p><p>给目标区间[l , r]加上数d。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(ll l, ll r, ll d, ll p = <span class="number">1</span>, ll cl = <span class="number">1</span>, ll cr = n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (cl &gt; r || cr &lt; l) <span class="comment">// 区间无交集</span></span><br><span class="line">        <span class="keyword">return</span>; <span class="comment">// 剪枝</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (cl &gt;= l &amp;&amp; cr &lt;= r) <span class="comment">// 当前节点对应的区间包含在目标区间中</span></span><br><span class="line">    &#123;</span><br><span class="line">        tree[p] += (cr - cl + <span class="number">1</span>) * d; <span class="comment">// 更新当前区间的值</span></span><br><span class="line">        <span class="keyword">if</span> (cr &gt; cl) <span class="comment">// 如果不是叶子节点</span></span><br><span class="line">            mark[p] += d; <span class="comment">// 给当前区间打上标记</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="comment">// 与目标区间有交集，但不包含于其中</span></span><br><span class="line">    &#123;</span><br><span class="line">        ll mid = (cl + cr) / <span class="number">2</span>;</span><br><span class="line">        mark[p * <span class="number">2</span>] += mark[p]; <span class="comment">// 标记向下传递</span></span><br><span class="line">        mark[p * <span class="number">2</span> + <span class="number">1</span>] += mark[p];</span><br><span class="line">        tree[p * <span class="number">2</span>] += mark[p] * (mid - cl + <span class="number">1</span>); <span class="comment">// 往下更新一层</span></span><br><span class="line">        tree[p * <span class="number">2</span> + <span class="number">1</span>] += mark[p] * (cr - mid);</span><br><span class="line">        mark[p] = <span class="number">0</span>; <span class="comment">// 清除标记</span></span><br><span class="line">        <span class="built_in">update</span>(l, r, d, p * <span class="number">2</span>, cl, mid); <span class="comment">// 递归地往下寻找</span></span><br><span class="line">        <span class="built_in">update</span>(l, r, d, p * <span class="number">2</span> + <span class="number">1</span>, mid + <span class="number">1</span>, cr);</span><br><span class="line">        tree[p] = tree[p * <span class="number">2</span>] + tree[p * <span class="number">2</span> + <span class="number">1</span>]; <span class="comment">// 根据子节点更新当前节点的值</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>分三种情况处理，当前结点p的区间[cl , rl]，与目标区间无交集，包含关系，有交集。</p><p>用懒标记来给维护区间的加减</p><h2 id="0x04-区间查询"><a href="#0x04-区间查询" class="headerlink" title="0x04 区间查询"></a>0x04 区间查询</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ll <span class="title">query</span><span class="params">(ll l, ll r, ll p = <span class="number">1</span>, ll cl = <span class="number">1</span>, ll cr = n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (cl &gt; r || cr &lt; l)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (cl &gt;= l &amp;&amp; cr &lt;= r)</span><br><span class="line">        <span class="keyword">return</span> tree[p];</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        ll mid = (cl + cr) / <span class="number">2</span>;</span><br><span class="line">        <span class="built_in">push_down</span>(p, cr - cl + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">query</span>(l, r, p * <span class="number">2</span>, cl, mid) + <span class="built_in">query</span>(l, r, p * <span class="number">2</span> + <span class="number">1</span>, mid + <span class="number">1</span>, cr); </span><br><span class="line">        <span class="comment">// 上一行拆成三行写就和区间修改格式一致了</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基础 </tag>
            
            <tag> C++ </tag>
            
            <tag> 算法 </tag>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>记录一下刷的入门题</title>
      <link href="/2024/02/24/%E5%B0%8F%E5%B0%8F%E8%AE%B0%E5%BD%95%E4%B8%80%E4%B8%8B%E5%88%B7%E7%9A%84%E5%85%A5%E9%97%A8%E9%A2%98/"/>
      <url>/2024/02/24/%E5%B0%8F%E5%B0%8F%E8%AE%B0%E5%BD%95%E4%B8%80%E4%B8%8B%E5%88%B7%E7%9A%84%E5%85%A5%E9%97%A8%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h2 id="0x01-P1009-NOIP1998-普及组-阶乘之和"><a href="#0x01-P1009-NOIP1998-普及组-阶乘之和" class="headerlink" title="0x01 P1009 [NOIP1998 普及组] 阶乘之和"></a>0x01 P1009 [NOIP1998 普及组] 阶乘之和</h2><p>这题要用高精度乘法和高精度加法，把每位数字单独存储到一个数组中，每个元素如果大于9再进位，以此类推。这题的乘法是半个高精度，一个是高精度数字，另一个是普通的int数，简单了一点。</p><p>不过如果两个都是高精度数的乘法，原理差不多，就是把这个一个高精度一个普通的做好多遍，然后全部加起来再进位就好了，以后有机会再写。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> i,sum[<span class="number">1005</span>]=&#123;<span class="number">0</span>&#125;,one[<span class="number">1005</span>]=&#123;<span class="number">0</span>&#125;,n,j;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    sum[<span class="number">0</span>]=one[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span> (j=<span class="number">0</span>;j&lt;<span class="number">100</span>;j++)&#123;</span><br><span class="line">            one[j]*=i;</span><br><span class="line">            <span class="comment">//乘法操作</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (j=<span class="number">0</span>;j&lt;<span class="number">100</span>;j++)</span><br><span class="line">            <span class="keyword">if</span>(one[j]&gt;<span class="number">9</span>)&#123;</span><br><span class="line">                one[j+<span class="number">1</span>] += one[j]/<span class="number">10</span>;</span><br><span class="line">                one[j]%=<span class="number">10</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//进位操作</span></span><br><span class="line">        <span class="keyword">for</span> (j=<span class="number">0</span>;j&lt;<span class="number">100</span>;j++)&#123;</span><br><span class="line">            sum[j]+=one[j];</span><br><span class="line">            <span class="comment">//加法操作</span></span><br><span class="line">            <span class="keyword">if</span> (sum[j]&gt;<span class="number">9</span>) &#123;</span><br><span class="line">                sum[j+<span class="number">1</span>] += sum[j]/<span class="number">10</span>;</span><br><span class="line">                sum[j]%=<span class="number">10</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//进位操作</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    i = <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">while</span>(i&gt;=<span class="number">0</span> &amp;&amp; sum[i]==<span class="number">0</span>)&#123;</span><br><span class="line">        i--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//抹0操作</span></span><br><span class="line">    <span class="keyword">for</span> (j=i;j&gt;=<span class="number">0</span>;j--)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,sum[j]);</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="comment">//输出</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="0x02-P1217-USACO1-5-回文质数-Prime-Palindromes"><a href="#0x02-P1217-USACO1-5-回文质数-Prime-Palindromes" class="headerlink" title="0x02 P1217 [USACO1.5] 回文质数 Prime Palindromes"></a>0x02 P1217 [USACO1.5] 回文质数 Prime Palindromes</h2><p>sb题目，老是卡我时间。</p><p>先判断回文再判断质数，不然时间不够。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">zhi</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i*i&lt;=x;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(x % i == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">huiwen</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> y=<span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> temp=x;</span><br><span class="line">    <span class="keyword">while</span>(x&gt;<span class="number">0</span>)&#123;</span><br><span class="line">        y = y*<span class="number">10</span> + x%<span class="number">10</span>;</span><br><span class="line">        x /= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(temp==y)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> a,b;</span><br><span class="line">    cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=a;i&lt;=b;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(i==<span class="number">9989900</span>)&#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">huiwen</span>(i)&amp;&amp;<span class="built_in">zhi</span>(i))&#123;</span><br><span class="line">            cout &lt;&lt; i &lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="0x03-P1420-最长连号"><a href="#0x03-P1420-最长连号" class="headerlink" title="0x03 P1420 最长连号"></a>0x03 P1420 最长连号</h2><p>超级超级简单的动态规划，把每次最长的连号存储起来，断了就重新计数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> a[<span class="number">10005</span>];</span><br><span class="line"><span class="type">int</span> dp[<span class="number">10005</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n,m = <span class="number">0</span>;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        cin &gt;&gt; a[i];</span><br><span class="line">        dp[i] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(a[i]==a[i<span class="number">-1</span>]+<span class="number">1</span>)&#123;</span><br><span class="line">            dp[i] += dp[i<span class="number">-1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        m = <span class="built_in">max</span>(m,dp[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; m;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="0x04-P3613-【深基15-例2】寄包柜"><a href="#0x04-P3613-【深基15-例2】寄包柜" class="headerlink" title="0x04 P3613 【深基15.例2】寄包柜"></a>0x04 P3613 【深基15.例2】寄包柜</h2><p>初次用容器vector和map解题，挺有意思的，map类似python的字典</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">map&lt;<span class="type">int</span>,map&lt;<span class="type">int</span>,<span class="type">int</span>&gt;&gt; V;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; ans;</span><br><span class="line"><span class="type">int</span> n,q,i,j,k,opcode=<span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; q;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> t=<span class="number">1</span>;t&lt;=q;t++)&#123;</span><br><span class="line">        cin &gt;&gt; opcode &gt;&gt; i &gt;&gt; j;</span><br><span class="line">        <span class="keyword">if</span>(opcode==<span class="number">1</span>)&#123;</span><br><span class="line">            cin &gt;&gt; k;</span><br><span class="line">            V[i][j] = k;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(opcode==<span class="number">2</span>)&#123;</span><br><span class="line">            ans.<span class="built_in">push_back</span>(V[i][j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(ans.<span class="built_in">size</span>()!=<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">for</span>(vector&lt;<span class="type">int</span>&gt;::iterator it = ans.<span class="built_in">begin</span>();it != ans.<span class="built_in">end</span>(); it++)&#123;</span><br><span class="line">            cout &lt;&lt; *it &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="0x05-U264780-新生杯录取"><a href="#0x05-U264780-新生杯录取" class="headerlink" title="0x05 U264780 新生杯录取"></a>0x05 U264780 新生杯录取</h2><p>题目大概的意思就是，再给定的很多数据里，挑选最小的几个然后排序。</p><p>由于限制了内存，先排序再取值很难实现，学习了堆排序的知识后，决定先取值再排序。</p><p>输入n个数据，然后排k，从小到大。</p><p>这里讲一下堆的结构，对于大堆，用完全二叉树的形式表示，他的任意一个节点的值总比他的左右孩子大，这里就隐含了一个信息，二叉树形式的堆的头结点的值是最大的，不管头结点的值怎么被修改，只要在此之后把堆维护一下，头结点的值仍然是最大的。用这个特性，我们在建立了k个元素的大堆后，之后每插入一个元素时先和头结点比较，如果更小就和头结点交换值，然后再维护一下，以此类推，最后堆内的k个元素必定是n个元素中最小的那几个，最后再堆排序一下输出。</p><p>知道思路后，关于堆，有建立堆，维护堆，堆排序三个操作，这里贴代码都有实现。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> heap[<span class="number">105</span>];</span><br><span class="line"><span class="type">int</span> n,k,temp;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(<span class="type">int</span> heap[],<span class="type">int</span> a, <span class="type">int</span> b)</span></span>&#123;</span><br><span class="line">    heap[<span class="number">0</span>] = heap[a];</span><br><span class="line">    heap[a] = heap[b];</span><br><span class="line">    heap[b] = heap[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">correctHeap</span><span class="params">(<span class="type">int</span> heap[],<span class="type">int</span> index, <span class="type">int</span> len)</span></span>&#123;<span class="comment">//维护堆的函数，始终保持大堆</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">2</span> * index &lt;= len)&#123;<span class="comment">//如果index有孩子</span></span><br><span class="line">        <span class="type">int</span> l = <span class="number">2</span>*index, r = <span class="number">2</span>*index+<span class="number">1</span> ;</span><br><span class="line">        <span class="type">int</span> maxIndex = l;</span><br><span class="line">        <span class="keyword">if</span>(r &lt;= len &amp;&amp; heap[r] &gt; heap[l])&#123;</span><br><span class="line">            maxIndex = r;</span><br><span class="line">        &#125;<span class="comment">//判断左右孩子谁大</span></span><br><span class="line">        <span class="keyword">if</span>(heap[index] &gt;= heap[maxIndex])&#123;<span class="comment">//如果双亲更大</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">swap</span>(heap, index, maxIndex);</span><br><span class="line">        index = maxIndex;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">heapSort</span><span class="params">(<span class="type">int</span> heap[], <span class="type">int</span> len)</span></span>&#123;<span class="comment">//堆排序，从小到大</span></span><br><span class="line">    <span class="type">int</span> s = len;</span><br><span class="line">    <span class="keyword">while</span>(s &gt; <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="built_in">swap</span>(heap,<span class="number">1</span>,s);</span><br><span class="line">        s--;</span><br><span class="line">        <span class="built_in">correctHeap</span>(heap, <span class="number">1</span>, s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">heapCreate</span><span class="params">(<span class="type">int</span> heap[], <span class="type">int</span> len)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> index = len/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">while</span>(index &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">correctHeap</span>(heap, index, len);</span><br><span class="line">        index--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//改善输入输出流时间效率的代码，具体含义可以查一下</span></span><br><span class="line">    std::ios_base::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);std::cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; k;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=k;i++)&#123;</span><br><span class="line">        cin &gt;&gt; heap[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//先建一个k大堆</span></span><br><span class="line">    <span class="built_in">heapCreate</span>(heap,k);</span><br><span class="line">    <span class="comment">//插入数据和堆顶比较，小就交换，大就舍去</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n-k;i++)&#123;</span><br><span class="line">        cin &gt;&gt; heap[<span class="number">104</span>];</span><br><span class="line">        <span class="keyword">if</span>(heap[<span class="number">104</span>] &lt; heap[<span class="number">1</span>])&#123;</span><br><span class="line">            <span class="built_in">swap</span>(heap,<span class="number">104</span>,<span class="number">1</span>);</span><br><span class="line">            <span class="built_in">correctHeap</span>(heap,<span class="number">1</span>,k);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//最后排序</span></span><br><span class="line">    <span class="built_in">heapSort</span>(heap,k);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=k;i++)&#123;</span><br><span class="line">        cout &lt;&lt; heap[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="堆的维护操作"><a href="#堆的维护操作" class="headerlink" title="堆的维护操作"></a>堆的维护操作</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">correctHeap</span><span class="params">(<span class="type">int</span> heap[],<span class="type">int</span> index, <span class="type">int</span> len)</span></span>&#123;<span class="comment">//维护堆的函数，始终保持大堆</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">2</span> * index &lt;= len)&#123;<span class="comment">//如果index有孩子</span></span><br><span class="line">        <span class="type">int</span> l = <span class="number">2</span>*index, r = <span class="number">2</span>*index+<span class="number">1</span> ;</span><br><span class="line">        <span class="type">int</span> maxIndex = l;</span><br><span class="line">        <span class="keyword">if</span>(r &lt;= len &amp;&amp; heap[r] &gt; heap[l])&#123;</span><br><span class="line">            maxIndex = r;</span><br><span class="line">        &#125;<span class="comment">//判断左右孩子谁大</span></span><br><span class="line">        <span class="keyword">if</span>(heap[index] &gt;= heap[maxIndex])&#123;<span class="comment">//如果双亲更大</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">swap</span>(heap, index, maxIndex);</span><br><span class="line">        index = maxIndex;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>堆的维护操作（这里以大堆为例子），其实就是让某个结点index和左右孩子结点比较，若双亲节点大则不用维护，若双亲节点小，交换双亲节点和值较大的那个孩子节点，之后有index 的节点继续作为双亲节点和他的孩子节点比较，直到叶子结点，或者双亲节点大。</p><h3 id="堆的建立"><a href="#堆的建立" class="headerlink" title="堆的建立"></a>堆的建立</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">heapCreate</span><span class="params">(<span class="type">int</span> heap[], <span class="type">int</span> len)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> index = len/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">while</span>(index &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">correctHeap</span>(heap, index, len);</span><br><span class="line">        index--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>堆的建立其实就是，把每个节点（叶子外）全都做一遍堆的维护，而且要自下而上（i—就可以实现)。这样做就能保证每个节点的左右孩子均比这个节点小。</p><h3 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">heapSort</span><span class="params">(<span class="type">int</span> heap[], <span class="type">int</span> len)</span></span>&#123;<span class="comment">//堆排序，从小到大</span></span><br><span class="line">    <span class="type">int</span> s = len;</span><br><span class="line">    <span class="keyword">while</span>(s &gt; <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="built_in">swap</span>(heap,<span class="number">1</span>,s);</span><br><span class="line">        s--;</span><br><span class="line">        <span class="built_in">correctHeap</span>(heap, <span class="number">1</span>, s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>堆排序，其实就是将堆顶元素一个一个取出来的操作，将堆顶元素和堆底元素交换，然后堆的大小减一，然后再把缩小后的堆维护一下，最后原先的那个堆，从堆底到堆顶，就是从大到小排序的数了，正着输出就是从小到大排序。</p><h2 id="0x06-P1449-后缀表达式"><a href="#0x06-P1449-后缀表达式" class="headerlink" title="0x06 P1449 后缀表达式"></a>0x06 P1449 后缀表达式</h2><p>这是一道用栈（stack）模拟算术的题，非常经典，故记录。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">char</span> c;</span><br><span class="line"><span class="type">int</span> num = <span class="number">0</span>;</span><br><span class="line">stack&lt;<span class="type">int</span>&gt; sta;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">run_code</span><span class="params">(<span class="type">char</span> code)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> fir,sec;</span><br><span class="line">    fir = sta.<span class="built_in">top</span>();</span><br><span class="line">    sta.<span class="built_in">pop</span>();</span><br><span class="line">    sec = sta.<span class="built_in">top</span>();</span><br><span class="line">    sta.<span class="built_in">pop</span>();</span><br><span class="line">    <span class="keyword">switch</span>(code)&#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;+&#x27;</span>:</span><br><span class="line">            sec += fir;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;-&#x27;</span>:</span><br><span class="line">            sec -= fir;   </span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;*&#x27;</span>:</span><br><span class="line">            sec *= fir;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;/&#x27;</span>:</span><br><span class="line">            sec /= fir; </span><br><span class="line">            <span class="keyword">break</span>;      </span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    sta.<span class="built_in">push</span>(sec);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">        cin &gt;&gt; c;</span><br><span class="line">        <span class="keyword">if</span>(c==<span class="string">&#x27;@&#x27;</span>)&#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(c&gt;=<span class="string">&#x27;0&#x27;</span> &amp;&amp; c&lt;=<span class="string">&#x27;9&#x27;</span>)&#123;</span><br><span class="line">            num = <span class="number">10</span>*num + (c-<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(c==<span class="string">&#x27;.&#x27;</span>)&#123;</span><br><span class="line">            sta.<span class="built_in">push</span>(num);</span><br><span class="line">            num = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="built_in">run_code</span>(c);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; sta.<span class="built_in">top</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="0x07-P1996-约瑟夫问题"><a href="#0x07-P1996-约瑟夫问题" class="headerlink" title="0x07 P1996 约瑟夫问题"></a>0x07 P1996 约瑟夫问题</h2><p>刚开始学C语言时碰到的难题，现在看来豁然开朗，记录一下。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; ans,<span class="built_in">people</span>(<span class="number">101</span>,<span class="number">0</span>);</span><br><span class="line"><span class="type">int</span> n,m,cnt = <span class="number">0</span>,i=<span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">while</span>(ans.<span class="built_in">size</span>()!=n)&#123;</span><br><span class="line">        <span class="keyword">if</span>(people[i]==<span class="number">0</span>)&#123;</span><br><span class="line">            cnt++;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">if</span>(cnt == m)&#123;<span class="comment">//假如数到m了</span></span><br><span class="line">            cnt =<span class="number">0</span>;</span><br><span class="line">            people[i] = <span class="number">1</span>;<span class="comment">//赋值1代表出局</span></span><br><span class="line">            ans.<span class="built_in">push_back</span>(i);</span><br><span class="line">        &#125;  </span><br><span class="line">        i = (i%n) + <span class="number">1</span>;       </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(vector&lt;<span class="type">int</span>&gt;::iterator it=ans.<span class="built_in">begin</span>();it!=ans.<span class="built_in">end</span>();it++)&#123;</span><br><span class="line">        cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我用了模拟的方法，模拟这个过程进行。</p><h2 id="0x08-P1160-队列安排"><a href="#0x08-P1160-队列安排" class="headerlink" title="0x08 P1160 队列安排"></a>0x08 P1160 队列安排</h2><p>我真没想到我写的这一坨式能跑过，记录留念一下。</p><p>这题用链表查找，跑的内存真大，我以后看能不能优化一下这个思路。</p><p>内存爆满，有一说一，处理得不太好。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">list&lt;<span class="type">int</span>&gt; student;</span><br><span class="line">map&lt;<span class="type">int</span>,list&lt;<span class="type">int</span>&gt;::iterator&gt; id; </span><br><span class="line">list&lt;<span class="type">int</span>&gt;::iterator it;</span><br><span class="line"><span class="type">int</span> n,m,loc,stu_id;<span class="comment">//学生数，去掉学生数</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    student.<span class="built_in">push_front</span>(<span class="number">1</span>);</span><br><span class="line">    id[<span class="number">1</span>] = student.<span class="built_in">begin</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        cin &gt;&gt; stu_id &gt;&gt; loc;</span><br><span class="line">        <span class="keyword">if</span>(loc == <span class="number">0</span>)&#123;<span class="comment">//插入左边</span></span><br><span class="line">            id[i] = student.<span class="built_in">insert</span>(id[stu_id],i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(loc == <span class="number">1</span>)&#123;<span class="comment">//插入右边</span></span><br><span class="line">            it = <span class="built_in">next</span>(id[stu_id]);</span><br><span class="line">            id[i] = student.<span class="built_in">insert</span>(it,i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//删除操作</span></span><br><span class="line">    cin &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">        cin &gt;&gt; stu_id;</span><br><span class="line">        <span class="keyword">if</span>(*id[stu_id]!=<span class="number">0</span>)&#123;</span><br><span class="line">            *id[stu_id] = <span class="number">0</span>;</span><br><span class="line">            student.<span class="built_in">erase</span>(id[stu_id]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//输出</span></span><br><span class="line">    <span class="keyword">for</span>(it = student.<span class="built_in">begin</span>();it!=student.<span class="built_in">end</span>();it++)&#123;</span><br><span class="line">        cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;     </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//清空容器</span></span><br><span class="line">    id.<span class="built_in">clear</span>();</span><br><span class="line">    map&lt;<span class="type">int</span>,list&lt;<span class="type">int</span>&gt;::iterator&gt;().<span class="built_in">swap</span>(id);</span><br><span class="line">    student.<span class="built_in">clear</span>();</span><br><span class="line">    <span class="built_in">list</span>&lt;<span class="type">int</span>&gt;().<span class="built_in">swap</span>(student);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>后来我写着写着发现，这题感觉根本就不用map这个东西，map容器id下标是int，完全用普通数组就可以胜任这个记录的工作。</p><p>后面看别人写的才发现insert操作会返回插入值位置的迭代器。。。。我还一直在搞什么it++，it—操作，搞得像个啥乱一样。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;list&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">list&lt;<span class="type">int</span>&gt; student;</span><br><span class="line">vector&lt;list&lt;<span class="type">int</span>&gt;::iterator&gt; id;</span><br><span class="line">list&lt;<span class="type">int</span>&gt;::iterator it;</span><br><span class="line"><span class="type">int</span> n,m,loc,stu_id;<span class="comment">//学生数，去掉学生数</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    id.<span class="built_in">resize</span>(<span class="number">100005</span>);</span><br><span class="line">    student.<span class="built_in">push_front</span>(<span class="number">1</span>);</span><br><span class="line">    id[<span class="number">1</span>] = student.<span class="built_in">begin</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        cin &gt;&gt; stu_id &gt;&gt; loc;</span><br><span class="line">        <span class="keyword">if</span>(loc == <span class="number">0</span>)&#123;<span class="comment">//插入左边</span></span><br><span class="line">            id[i] = student.<span class="built_in">insert</span>(id[stu_id],i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(loc == <span class="number">1</span>)&#123;<span class="comment">//插入右边</span></span><br><span class="line">            it = <span class="built_in">next</span>(id[stu_id]);</span><br><span class="line">            id[i] = student.<span class="built_in">insert</span>(it,i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//删除操作</span></span><br><span class="line">    cin &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">        cin &gt;&gt; stu_id;</span><br><span class="line">        <span class="keyword">if</span>(*id[stu_id]!=<span class="number">0</span>)&#123;</span><br><span class="line">            *id[stu_id] = <span class="number">0</span>;</span><br><span class="line">            student.<span class="built_in">erase</span>(id[stu_id]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//输出</span></span><br><span class="line">    <span class="keyword">for</span>(it = student.<span class="built_in">begin</span>();it!=student.<span class="built_in">end</span>();it++)&#123;</span><br><span class="line">        cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;     </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//清空容器</span></span><br><span class="line">    id.<span class="built_in">clear</span>();</span><br><span class="line">    vector&lt;list&lt;<span class="type">int</span>&gt;::iterator&gt;().<span class="built_in">swap</span>(id);</span><br><span class="line">    student.<span class="built_in">clear</span>();</span><br><span class="line">    <span class="built_in">list</span>&lt;<span class="type">int</span>&gt;().<span class="built_in">swap</span>(student);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>优化了一下，不使用map，而使用vector存取，内存消耗减少了一倍。</p><h2 id="0x09-P1540-NOIP2010-提高组-机器翻译"><a href="#0x09-P1540-NOIP2010-提高组-机器翻译" class="headerlink" title="0x09 P1540 [NOIP2010 提高组] 机器翻译"></a>0x09 P1540 [NOIP2010 提高组] 机器翻译</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> m,n;<span class="comment">//m是内存容量，n是单词个数</span></span><br><span class="line"><span class="type">int</span> cnt = <span class="number">0</span>, word;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; mem;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin &gt;&gt; m &gt;&gt; n;</span><br><span class="line">    mem.<span class="built_in">reserve</span>(<span class="number">10000</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        cin &gt;&gt; word;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">find</span>(mem.<span class="built_in">begin</span>(),mem.<span class="built_in">end</span>(),word) == mem.<span class="built_in">end</span>())&#123;</span><br><span class="line">            mem.<span class="built_in">push_back</span>(word);</span><br><span class="line">            cnt++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(mem.<span class="built_in">size</span>() &gt; m)&#123;</span><br><span class="line">            mem.<span class="built_in">erase</span>(mem.<span class="built_in">begin</span>());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    mem.<span class="built_in">clear</span>();</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;().<span class="built_in">swap</span>(mem);</span><br><span class="line">    cout &lt;&lt; cnt;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>队列问题，不过需要常常遍历这个队列，所以不用queue而用vector代替了。</p>]]></content>
      
      
      <categories>
          
          <category> 刷题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基础 </tag>
            
            <tag> C++ </tag>
            
            <tag> 算法 </tag>
            
            <tag> 刷题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++容器初识和string容器</title>
      <link href="/2024/02/19/c-%E5%AE%B9%E5%99%A8%E5%88%9D%E8%AF%86%E5%92%8Cstring%E5%AE%B9%E5%99%A8/"/>
      <url>/2024/02/19/c-%E5%AE%B9%E5%99%A8%E5%88%9D%E8%AF%86%E5%92%8Cstring%E5%AE%B9%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="0x01-vector容器"><a href="#0x01-vector容器" class="headerlink" title="0x01 vector容器"></a>0x01 vector容器</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//创建vector容器</span></span><br><span class="line">std::vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line"><span class="comment">//存入数据</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; <span class="number">10</span>;i ++)&#123;</span><br><span class="line">v.<span class="built_in">push_back</span>(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//通过迭代器遍历</span></span><br><span class="line"><span class="comment">//it可看成指针，begin()是起始迭代器，存放容器第一个数据的地址</span></span><br><span class="line"><span class="keyword">for</span>(std::vector&lt;<span class="type">int</span>&gt;::iterator it = v.<span class="built_in">begin</span>(); it != v.<span class="built_in">end</span>();it ++)&#123;</span><br><span class="line">std::cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//运行结果：0 1 2 3 4 5 6 7 8 9 </span></span><br></pre></td></tr></table></figure><p>简单的使用方法。。</p><p>vector类模板，除了int以外还能定义其他数据类型。</p><p>容器是可以嵌套容器的，可以将内层的容器看成一个数据类型，</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; V;</span><br></pre></td></tr></table></figure><h2 id="0x02-string容器"><a href="#0x02-string容器" class="headerlink" title="0x02 string容器"></a>0x02 string容器</h2><p>string 的初始化构造。</p><p>我们常用的c++风格的字符串数据类型string本质也是一个容器。</p><p>先介绍一个string容器的构造方式</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建一个空的字符串</span></span><br><span class="line">string str;</span><br><span class="line"><span class="comment">//用c类型的字符串初始化</span></span><br><span class="line"><span class="function">string <span class="title">str</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *s)</span></span>;</span><br><span class="line"><span class="comment">//用一个string对象初始化另一个string对象</span></span><br><span class="line"><span class="function">string <span class="title">str</span><span class="params">(<span class="type">const</span> string &amp;s)</span></span>;</span><br><span class="line"><span class="comment">//用n个字符c初始化</span></span><br><span class="line"><span class="function">string <span class="title">str</span><span class="params">(<span class="type">int</span> n, <span class="type">char</span> c)</span></span>;</span><br></pre></td></tr></table></figure><p>string内部实际上也是维护着一个c语言的字符串的数据类型。</p><h2 id="0x03-string赋值操作"><a href="#0x03-string赋值操作" class="headerlink" title="0x03 string赋值操作"></a>0x03 string赋值操作</h2><p><img src="/Images/image-20240219003258861.png" alt="image-20240219003258861"></p><h2 id="0x04-string字符串拼接"><a href="#0x04-string字符串拼接" class="headerlink" title="0x04 string字符串拼接"></a>0x04 string字符串拼接</h2><p><img src="/Images/image-20240219004951406.png" alt="image-20240219004951406"></p><h2 id="0x05-string的查找和替换"><a href="#0x05-string的查找和替换" class="headerlink" title="0x05 string的查找和替换"></a>0x05 string的查找和替换</h2><p><img src="/Images/image-20240219133011947.png" alt="image-20240219133011947"></p><h2 id="0x06-字符串比较"><a href="#0x06-字符串比较" class="headerlink" title="0x06 字符串比较"></a>0x06 字符串比较</h2><p><img src="/Images/image-20240219135705055.png" alt="image-20240219135705055"></p><h2 id="0x07-string字符存取"><a href="#0x07-string字符存取" class="headerlink" title="0x07 string字符存取"></a>0x07 string字符存取</h2><p><img src="/Images/image-20240219140111418.png" alt="image-20240219140111418"></p><p>第一种方法类似于数组下标的索引法</p><h2 id="0x08-string的插入和删除"><a href="#0x08-string的插入和删除" class="headerlink" title="0x08 string的插入和删除"></a>0x08 string的插入和删除</h2><p><img src="/Images/image-20240219140235034.png" alt="image-20240219140235034"></p><h2 id="0x09-string子串获取"><a href="#0x09-string子串获取" class="headerlink" title="0x09 string子串获取"></a>0x09 string子串获取</h2><p><img src="/Images/image-20240219141407201.png" alt="image-20240219141407201"></p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 进阶 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>VNCTF2024</title>
      <link href="/2024/02/19/VNCTF%E7%9A%84%E7%AD%BE%E5%88%B0%E9%A2%98/"/>
      <url>/2024/02/19/VNCTF%E7%9A%84%E7%AD%BE%E5%88%B0%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h2 id="0x01-TBXO"><a href="#0x01-TBXO" class="headerlink" title="0x01 TBXO"></a>0x01 TBXO</h2><p>只会看了这一道，应该也只会这一道了。</p><p><img src="../Images/5eabd65659bf0b96f62a129e0a95673.png" alt="5eabd65659bf0b96f62a129e0a95673"></p><p>打开后f5，发现全是这种无意义的也不是函数的东西，感觉是经过防止反汇编的处理，无奈只能看汇编代码。</p><p>shift+f12找有用的字符串，发现有一个welcome 和wrong right等字眼的字符，点进去查找引用看看，能很快定位到main函数，当然是没法f5的，动调一步一步调试看会去哪里</p><p><img src="../Images/image-20240218134920902.png" alt="image-20240218134920902"></p><p>发现这个是scanf函数，要输入flag，不知道flag是多少位，发现输入错误后程序会直接中断。当时在调试的时候无意间发现了一些类似加密函数的汇编代码，因为就在这个scanf函数下面，也是多看了几眼，然后发现是一个tea加密，不过f5后的代码是有问题的，不够全面，而且有很多差错。</p><p><img src="../Images/image-20240218135144035.png" alt="image-20240218135144035"></p><p>如图，首先先不谈这些v1，v4，v2的是什么东西，关是这个a1 什么什么的就反汇编得很糟糕了，点进去这个unk_CC3004，发现是一个长度40char的数据，盲猜是enc密文，再动调试一下输入长度40 的flag，发现能调试到这一个函数了，直接看汇编。</p><p><img src="../Images/image-20240218135524860.png" alt="image-20240218135524860"></p><p>不难发现这个v1 就是 <em>(a - 1)，v4就是 </em>a，然后edi是存储sum 的 寄存器，每次循环加上 -0x61C88647，动调发现循环0x20轮，很典型的tea加密，就是多异或了一次0x33，这些信息看f5伪代码肯定是看不出来的，所以还是建议看汇编代码，比较准确。</p><p>解密的逻辑</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">__int32 key1 = <span class="number">0x67626463</span>, key2 = <span class="number">0x696D616E</span>, key3 = <span class="number">0x79645F65</span>, key4 = <span class="number">0x6B696C69</span>;</span><br><span class="line">__int32 delta = <span class="number">-0x61c88647</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">decrypt</span><span class="params">(<span class="type">unsigned</span> __int32 &amp;esi,<span class="type">unsigned</span> __int32 &amp;eax)</span></span>&#123;</span><br><span class="line">__int32 sum = delta *<span class="number">32</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; <span class="number">32</span>; i++)&#123;</span><br><span class="line">eax -= (esi + sum) ^ (key3 + (esi &lt;&lt; <span class="number">4</span>)) ^ (key4 + (esi &gt;&gt; <span class="number">5</span>)) ^ <span class="number">0x33</span>;</span><br><span class="line">esi -= (eax + sum) ^ (key1 + (eax &lt;&lt; <span class="number">4</span>)) ^ (key2 + (eax &gt;&gt; <span class="number">5</span>)) ^ <span class="number">0x33</span>;</span><br><span class="line">sum -= delta;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>完整脚本，只要把40位密文分成10份然后两两加密就好了</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line">__int32 key1 = <span class="number">0x67626463</span>, key2 = <span class="number">0x696D616E</span>, key3 = <span class="number">0x79645F65</span>, key4 = <span class="number">0x6B696C69</span>;</span><br><span class="line">__int32 delta = <span class="number">-0x61c88647</span>;</span><br><span class="line"><span class="type">unsigned</span> __int32 enc[<span class="number">40</span>] = &#123;<span class="number">0x10</span>, <span class="number">0x30</span>, <span class="number">0x36</span>, <span class="number">0x31</span>, <span class="number">0x23</span>, <span class="number">0x86</span>, <span class="number">0x93</span>, <span class="number">0xAD</span>, <span class="number">0xC5</span>, <span class="number">0xD4</span>, </span><br><span class="line">  <span class="number">0x92</span>, <span class="number">0x84</span>, <span class="number">0x66</span>, <span class="number">0xE3</span>, <span class="number">0x67</span>, <span class="number">0x75</span>, <span class="number">0x6B</span>, <span class="number">0x69</span>, <span class="number">0x86</span>, <span class="number">0xC7</span>, </span><br><span class="line">  <span class="number">0x31</span>, <span class="number">0x2E</span>, <span class="number">0x09</span>, <span class="number">0xA0</span>, <span class="number">0x33</span>, <span class="number">0x57</span>, <span class="number">0x69</span>, <span class="number">0xDB</span>, <span class="number">0x93</span>, <span class="number">0xA8</span>, </span><br><span class="line">  <span class="number">0x13</span>, <span class="number">0xDD</span>, <span class="number">0x3E</span>, <span class="number">0xA5</span>, <span class="number">0xD8</span>, <span class="number">0x88</span>, <span class="number">0x37</span>, <span class="number">0x54</span>, <span class="number">0x84</span>, <span class="number">0x7E</span>&#125;;</span><br><span class="line"><span class="type">unsigned</span> __int32 enc2[<span class="number">10</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="comment">//解密逻辑</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">decrypt</span><span class="params">(<span class="type">unsigned</span> __int32 &amp;esi,<span class="type">unsigned</span> __int32 &amp;eax)</span></span>&#123;</span><br><span class="line">__int32 sum = delta *<span class="number">32</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; <span class="number">32</span>; i++)&#123;</span><br><span class="line">eax -= (esi + sum) ^ (key3 + (esi &lt;&lt; <span class="number">4</span>)) ^ (key4 + (esi &gt;&gt; <span class="number">5</span>)) ^ <span class="number">0x33</span>;</span><br><span class="line">esi -= (eax + sum) ^ (key1 + (eax &lt;&lt; <span class="number">4</span>)) ^ (key2 + (eax &gt;&gt; <span class="number">5</span>)) ^ <span class="number">0x33</span>;</span><br><span class="line">sum -= delta;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//合并密文</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">trans</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; <span class="number">10</span>; i++)&#123;</span><br><span class="line">enc2[i] = (enc[<span class="number">4</span> * i]) | (enc[<span class="number">4</span> * i + <span class="number">1</span>] &lt;&lt; <span class="number">8</span>) | (enc[<span class="number">4</span> * i + <span class="number">2</span>] &lt;&lt; <span class="number">16</span>) | (enc[<span class="number">4</span> * i + <span class="number">3</span>] &lt;&lt; <span class="number">24</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//拆分密文</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">trans2</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; <span class="number">10</span>; i++)&#123;</span><br><span class="line">enc[<span class="number">4</span> * i] = enc2[i] &amp; <span class="number">0xff</span>;</span><br><span class="line">enc[<span class="number">4</span> * i + <span class="number">1</span>] = (enc2[i] &gt;&gt; <span class="number">8</span>) &amp; <span class="number">0xff</span>;</span><br><span class="line">enc[<span class="number">4</span> * i + <span class="number">2</span>] = (enc2[i] &gt;&gt; <span class="number">16</span>) &amp; <span class="number">0xff</span>;</span><br><span class="line">enc[<span class="number">4</span> * i + <span class="number">3</span>] = (enc2[i] &gt;&gt; <span class="number">24</span>) &amp; <span class="number">0xff</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">trans</span>();</span><br><span class="line"><span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(i &lt; <span class="number">10</span>)&#123;</span><br><span class="line"><span class="built_in">decrypt</span>(enc2[i],enc2[i+<span class="number">1</span>]);</span><br><span class="line">i = i + <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">trans2</span>();</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; <span class="number">40</span>;i ++)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>,enc[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//VNCTF&#123;Box_obfuscation_and_you_ar_socool&#125;</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Re-wp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基础 </tag>
            
            <tag> 逆向 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>广义表和二叉树的性质</title>
      <link href="/2024/02/15/%E5%B9%BF%E4%B9%89%E8%A1%A8%E5%92%8C%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%80%A7%E8%B4%A8/"/>
      <url>/2024/02/15/%E5%B9%BF%E4%B9%89%E8%A1%A8%E5%92%8C%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%80%A7%E8%B4%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="0x01-广义表的定义"><a href="#0x01-广义表的定义" class="headerlink" title="0x01 广义表的定义"></a>0x01 广义表的定义</h2><p>广义表是n（n&gt;=0）个元素的有限序列，其中每一个元素或者是原子，或者是一个广义表。</p><p>广义表通常记为</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LS = (a1,a2,...,an)</span><br></pre></td></tr></table></figure><p>其中LS为表名，n为表的长度，每一个ai为表的元素</p><p>习惯上用大写字母表示广义表，小写字母表示原子</p><p>表头：若LS非空，则其中第一个元素a1就是表头，记为</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">head(LS) = a1</span><br></pre></td></tr></table></figure><p>表头可以是原子也可以是子表</p><p>表尾：除表头之外的其他元素组成的表</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tail(LS) = (a2,...,an)</span><br></pre></td></tr></table></figure><p>表尾表示最后一个元素，而是一个子表</p><h2 id="0x02-广义表的性质"><a href="#0x02-广义表的性质" class="headerlink" title="0x02 广义表的性质"></a>0x02 广义表的性质</h2><p>广义表中的数据有相对次序，一个直接前驱和一个直接后继</p><p>广义表的长度定义位最外层所包含的元素的个数</p><p>广义表的深度定义为该广义表展开后所含括号的重数</p><p>广义表可以为其他广义表共享</p><p>广义表可以是一个递归的表，递归表的深度是无穷值</p><p>广义表是多层次结构，可以用图形象地表示</p><h2 id="0x03-树的定义"><a href="#0x03-树的定义" class="headerlink" title="0x03 树的定义"></a>0x03 树的定义</h2><p>树(Tree) 是n (n≥0) 个结点的有限集。</p><p>若n=0，称为空树</p><p>若n&gt;0，则它满足如下两个条件：</p><p>​    有且仅有一个特定的称为根(Root)的结点</p><p>​    其余结点可分为 m(m≥0)个互不相交的有限集 T1,T2,T3,…,Tm，其中每一个集合本身又是一棵树，并称为根的子树(SubTree)</p><p><img src="/Images/image-20240215140407003.png" alt="image-20240215140407003"></p><p>由图可见，显然，树是一个递归的定义</p><h2 id="0x04-树的基本术语"><a href="#0x04-树的基本术语" class="headerlink" title="0x04 树的基本术语"></a>0x04 树的基本术语</h2><p><img src="/Images/image-20240215141325521.png" alt="image-20240215141325521"></p><p>根结点：非空树中无前驱结点的结点（第一个）</p><p>结点的度：结点拥有的子树数</p><p>树的度：树内各结点的度的最大值</p><p>叶子：该结点的度为0，也叫作终端结点</p><p>分支结点：度不为0（非终端结点）</p><p>内部结点：根结点以外的分支结点</p><p>孩子和双亲：结点的子树的根称为该结点的孩子，该结点称为孩子的双亲</p><p>堂兄弟和兄弟：双亲在同一层的结点是堂兄弟，有同一个双亲的结点是兄弟</p><p>结点的祖先：从根到该结点所经分支上的所有结点</p><p>结点的子孙：以某结点为根的子树中的任一结点</p><p>树的深度（高度）：树中结点的最大层次</p><p><img src="/Images/image-20240215142127761.png" alt="image-20240215142127761"></p><p>森林：是m棵互不相交的树的集合，把根结点删除树就变成了森林，一棵树可以看成是一个特殊的森林，反过来，给森林的各子树加上一个双亲结点，森林就变成了树。</p><p>归纳得出，树一定是森林，森林不一定是树</p><h2 id="0x05-二叉树的定义"><a href="#0x05-二叉树的定义" class="headerlink" title="0x05 二叉树的定义"></a>0x05 二叉树的定义</h2><h3 id="为什么要研究二叉树"><a href="#为什么要研究二叉树" class="headerlink" title="为什么要研究二叉树"></a>为什么要研究二叉树</h3><p>普通树（多叉树）若不转化为二叉树，则运算很难实现，因为</p><p>​    二叉树的结构最简单，规律性最强</p><p>​    可以证明，所有树都能转化为唯一对应的二叉树</p><h3 id="二叉树的定义"><a href="#二叉树的定义" class="headerlink" title="二叉树的定义"></a>二叉树的定义</h3><p>二叉树是n(n≥0)个结点的有限集，它或者是空集(n = 0)或者由一个根结点及两棵互不相交的分别称作这个根的左子树和右子树的二又树组成。</p><h3 id="二叉树的特点"><a href="#二叉树的特点" class="headerlink" title="二叉树的特点"></a>二叉树的特点</h3><p>每个结点最多有俩孩子(二又树中不存在度大于 2 的结点)</p><p>子树有左右之分，其次序不能颠倒。</p><p>二叉树可以是空集合，根可以有空的左子树或空的右子树</p><h3 id="二叉树和树的区别"><a href="#二叉树和树的区别" class="headerlink" title="二叉树和树的区别"></a>二叉树和树的区别</h3><p>二叉树不是数的特殊情，他们是两个概念</p><p>二叉树结点的子树要区分左子树和右子树，即使只有一颗子树也要进行区分，说明它是左子树还是右子树</p><p>树当结点只有一个孩子时，就无须区分左右次序，这是二叉树和树最主要的区别。</p><p><img src="/Images/image-20240215144243805.png" alt="image-20240215144243805"></p><p><img src="/Images/image-20240215144313378.png" alt="image-20240215144313378"></p><p>也就是二叉树每个结点位置或者说次序都是固定的，可以是空，但是不可以说它没有位置，而树的结点位置是相对于别的结点来说的，没有别的结点时，它就无所谓左右了</p><p><img src="/Images/image-20240215144622162.png" alt="image-20240215144622162"></p><h2 id="0x06-二叉树的性质"><a href="#0x06-二叉树的性质" class="headerlink" title="0x06 二叉树的性质"></a>0x06 二叉树的性质</h2><h3 id="三个普遍性质"><a href="#三个普遍性质" class="headerlink" title="三个普遍性质"></a>三个普遍性质</h3><p>性质1：在二叉树的第 i 层上至多有 2的i-1次方个结点（i&gt;=1)</p><p>性质2：深度为k的二叉树至多有 2的k次方 - 1 个结点（k&gt;=1）</p><p>性质3：对于任意一颗二叉树，如果其叶子数为n0，度为2的结点数为n2，则n0 = n2 + 1</p><p>推导性质3：</p><p>每一个二叉树，记边数为B。</p><p><img src="/Images/image-20240215152429945.png" alt="image-20240215152429945"></p><p>联立两个式子，n = 2 * n2 + n1 + 1，其中n = n0 + n1 + n2</p><p>化简得 n0 = n2 + 1</p><h3 id="满二叉树"><a href="#满二叉树" class="headerlink" title="满二叉树"></a>满二叉树</h3><p>根据性质二，一颗深度为k且有2的k次方 - 1 个结点的二叉树称为满二叉树</p><p>特点：每一层的结点数都是最大结点数，叶子结点全部在最底层（同一层）</p><p>对满二叉树结点位置进行编号，从根结点开始，从上到下，从左到右，每一个结点位置都有元素。</p><p><img src="/Images/image-20240215153337883.png" alt="image-20240215153337883"></p><h3 id="完全二叉树"><a href="#完全二叉树" class="headerlink" title="完全二叉树"></a>完全二叉树</h3><p>深度为k的具有 n 个结点的二叉树，当且仅当其每一个结点都与深度为k的满二叉树中编号为1~n的结点一一对应时，成为完全二叉树。</p><p><img src="/Images/image-20240215154257860.png" alt="image-20240215154257860"></p><p>叶子只可能分布在层次最大的两层上。对于任一结点，如果其右子树的最大层次为 i ，则其左子树的最大层次必定为 i 或 i + 1 。</p><h3 id="完全二叉树的性质"><a href="#完全二叉树的性质" class="headerlink" title="完全二叉树的性质"></a>完全二叉树的性质</h3><p>性质4：具有n个结点的完全二叉树深度为[log2 n] + 1 （[ ]是高斯函数）</p><p><img src="/Images/image-20240215162726370.png" alt="image-20240215162726370"></p><p>性质4表明了完全二叉树结点数n与深度k的关系</p><p>性质5：如图，阐述了完全二叉树中双亲结点编号与孩子结点编号之间的关系</p><p><img src="/Images/image-20240215163131554.png" alt="image-20240215163131554"></p>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基础 </tag>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hgame_wp</title>
      <link href="/2024/02/14/hagme-week2/"/>
      <url>/2024/02/14/hagme-week2/</url>
      
        <content type="html"><![CDATA[<h2 id="0x01-babyre"><a href="#0x01-babyre" class="headerlink" title="0x01 babyre"></a>0x01 babyre</h2><p>这个程序的关键在于几个线程的调用，和key的值。</p><p>首先key 的值在主函数的异或前是先赋值过的，不是原本静态存储的那个值，可以通过动调得到</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0x77, 0x74, 0x78, 0x66, 0x65, 0x69</span><br></pre></td></tr></table></figure><p>然后关于这个线程的调用我也不是很懂，大概就是创建四个线程，每个线程里存有各自的函数的地址，然后按顺序依次调用，调用了一个线程后该线程对应的信号量减一（wait），下一个线程的信号量加一（post），这时就调用下一个线程的函数，依次循环，直到全局变量 i 为31停止，最后退出线程，四个线程总共循环8次（按理来说，因为flag是32位，全部加密一轮需要8*4=32次），按照这个思路写出逆向脚本，结果也是没问题的。</p><p>一开始做题的时候是通过调试发现四个线程一轮只调用一次，于是猜测是逐个逐个进行。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line">__int32 enc[<span class="number">33</span>] = &#123;<span class="number">12052</span>,<span class="number">78</span>,<span class="number">20467</span>,<span class="number">109</span>,<span class="number">13016</span>,<span class="number">109</span>,<span class="number">27467</span>,<span class="number">-110</span>,</span><br><span class="line">        <span class="number">9807</span>,<span class="number">91</span>,<span class="number">21243</span>,<span class="number">-100</span>,<span class="number">11121</span>,<span class="number">20</span>,<span class="number">10863</span>,<span class="number">-107</span>,<span class="number">10490</span>,<span class="number">29</span>,<span class="number">10633</span>,<span class="number">-101</span>,</span><br><span class="line">        <span class="number">10420</span>,<span class="number">78</span>,<span class="number">17670</span>,<span class="number">-38</span>,<span class="number">6011</span>,<span class="number">-4</span>,<span class="number">16590</span>,<span class="number">125</span>,<span class="number">10723</span>,</span><br><span class="line">        <span class="number">15</span>,<span class="number">7953</span>,<span class="number">255</span> , <span class="number">250</span>&#125;;</span><br><span class="line">__int32 key[<span class="number">6</span>] = &#123;<span class="number">0x77</span>, <span class="number">0x74</span>, <span class="number">0x78</span>, <span class="number">0x66</span>, <span class="number">0x65</span>, <span class="number">0x69</span>&#125;;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="type">int</span> i = <span class="number">31</span>;</span><br><span class="line">    <span class="keyword">while</span>(i &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">        enc[i] ^= (enc[i + <span class="number">1</span>] - key[(i + <span class="number">1</span>) % <span class="number">6</span>]);</span><br><span class="line">        i--;</span><br><span class="line">        enc[i] /= (enc[i + <span class="number">1</span>] + key[(i + <span class="number">1</span>) % <span class="number">6</span>]);</span><br><span class="line">        i--;</span><br><span class="line">        enc[i] += (key[(i + <span class="number">1</span>) % <span class="number">6</span>] ^ enc[i + <span class="number">1</span>]);</span><br><span class="line">        i--;</span><br><span class="line">        enc[i] -= (key[(i + <span class="number">1</span>) % <span class="number">6</span>] * enc[i + <span class="number">1</span>]);</span><br><span class="line">        i--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;<span class="number">32</span>;j++)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>,enc[j]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>hgame{you_are_3o_c1ever2_3Olve!}</p><h2 id="0x02-ezcpp"><a href="#0x02-ezcpp" class="headerlink" title="0x02 ezcpp"></a>0x02 ezcpp</h2><p>一进去看了一眼就是TEA加密，不过这个TEA加密和普通的不太一样，他是依次分别取input（char类型）（用户输入值）的下标为0和4,1和5,2和6,3和7的首地址，然依此地址为最低位，向后取3个char值和自己本身拼合成32位的int数，比如0x11,0x22，0x33，0x44，就以小端序存储成0x44332211。</p><p>在这个加密里，取flag[0]的地址解引用，然后传入某个变量v，其实就是将flag0,1,2,3 的值以上述方式拼合成int类型然后传入变量v，知道这个后，其实不难发现该加密只加密了前11个字符（因为以flag[7]的地址加密，最多拼合7到10，总共4个字符成int，也就是最多加密到flag[10]也就是第11的字符）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="comment">//密文flag</span></span><br><span class="line"><span class="type">int</span> flag[<span class="number">32</span>] = &#123;<span class="number">0x88</span>, <span class="number">0x6A</span>, <span class="number">0xB0</span>, <span class="number">0xC9</span>, <span class="number">0xAD</span>, <span class="number">0xF1</span>, <span class="number">0x33</span>, <span class="number">0x33</span>, <span class="number">0x94</span>, <span class="number">0x74</span>, </span><br><span class="line">                <span class="number">0xB5</span>, <span class="number">0x69</span>, <span class="number">0x73</span>, <span class="number">0x5F</span>, <span class="number">0x30</span>, <span class="number">0x62</span>, <span class="number">0x4A</span>, <span class="number">0x33</span>, <span class="number">0x63</span>, <span class="number">0x54</span>, </span><br><span class="line">                <span class="number">0x5F</span>, <span class="number">0x30</span>, <span class="number">0x72</span>, <span class="number">0x31</span>, <span class="number">0x65</span>, <span class="number">0x6E</span>, <span class="number">0x54</span>, <span class="number">0x65</span>, <span class="number">0x44</span>, <span class="number">0x3F</span>, </span><br><span class="line">                <span class="number">0x21</span>, <span class="number">0x7D</span>&#125;;</span><br><span class="line"><span class="type">int</span> v20,v21,v18,v19,v10,v9,v5,v6,sum,delta;</span><br><span class="line"><span class="comment">//四个密钥</span></span><br><span class="line"><span class="type">int</span> key1 = <span class="number">2341</span>, key2 = <span class="number">1234</span>, key3 = <span class="number">4123</span>, key4 = <span class="number">3412</span>;</span><br><span class="line"><span class="comment">//将int类型拆分成字符的函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">trans</span><span class="params">(<span class="type">int</span> v,<span class="type">int</span> i)</span></span>&#123;</span><br><span class="line">    flag[i] = v &amp; <span class="number">0xff</span>;</span><br><span class="line">    flag[i+<span class="number">1</span>] = (v&gt;&gt;<span class="number">8</span>) &amp; <span class="number">0xff</span>;</span><br><span class="line">    flag[i+<span class="number">2</span>] = (v&gt;&gt;<span class="number">16</span>) &amp; <span class="number">0xff</span>;</span><br><span class="line">    flag[i+<span class="number">3</span>] = (v&gt;&gt;<span class="number">24</span>) &amp; <span class="number">0xff</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//按照原加密的顺序逆过来</span></span><br><span class="line">    delta = <span class="number">-559038737</span>;</span><br><span class="line">    <span class="comment">//first</span></span><br><span class="line">    sum = delta * <span class="number">32</span>;</span><br><span class="line">    <span class="comment">//将字符拼合成int的整数</span></span><br><span class="line">    v20 = flag[<span class="number">3</span>]|(flag[<span class="number">4</span>]&lt;&lt;<span class="number">8</span>)|(flag[<span class="number">5</span>]&lt;&lt;<span class="number">16</span>)|(flag[<span class="number">6</span>]&lt;&lt;<span class="number">24</span>);</span><br><span class="line">    v21 = flag[<span class="number">7</span>]|(flag[<span class="number">8</span>]&lt;&lt;<span class="number">8</span>)|(flag[<span class="number">9</span>]&lt;&lt;<span class="number">16</span>)|(flag[<span class="number">10</span>]&lt;&lt;<span class="number">24</span>);</span><br><span class="line">    <span class="comment">//TEA加密的部分</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; <span class="number">32</span>;i++)&#123;</span><br><span class="line">        v21 -= (sum + v20) ^ (key3 + <span class="number">32</span> * v20) ^ (key4 + <span class="number">16</span> * v20);</span><br><span class="line">        v20 -= (sum + v21) ^ (key1 + <span class="number">32</span> * v21) ^ (key2 + <span class="number">16</span> * v21);</span><br><span class="line">        sum -= delta;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//调用函数将int拆分成原来的字符</span></span><br><span class="line">    <span class="built_in">trans</span>(v20,<span class="number">3</span>);</span><br><span class="line">    <span class="built_in">trans</span>(v21,<span class="number">7</span>);</span><br><span class="line">    <span class="comment">//second</span></span><br><span class="line">    sum = delta * <span class="number">32</span>;</span><br><span class="line">    v18 = flag[<span class="number">2</span>]|(flag[<span class="number">3</span>]&lt;&lt;<span class="number">8</span>)|(flag[<span class="number">4</span>]&lt;&lt;<span class="number">16</span>)|(flag[<span class="number">5</span>]&lt;&lt;<span class="number">24</span>);</span><br><span class="line">    v19 = flag[<span class="number">6</span>]|(flag[<span class="number">7</span>]&lt;&lt;<span class="number">8</span>)|(flag[<span class="number">8</span>]&lt;&lt;<span class="number">16</span>)|(flag[<span class="number">9</span>]&lt;&lt;<span class="number">24</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; <span class="number">32</span>;i++)&#123;</span><br><span class="line">        v19 -= (sum + v18) ^ (key3 + <span class="number">32</span> * v18) ^ (key4 + <span class="number">16</span> * v18);</span><br><span class="line">        v18 -= (sum + v19) ^ (key1 + <span class="number">32</span> * v19) ^ (key2 + <span class="number">16</span> * v19);  </span><br><span class="line">        sum -= delta;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">trans</span>(v18,<span class="number">2</span>);</span><br><span class="line">    <span class="built_in">trans</span>(v19,<span class="number">6</span>);</span><br><span class="line">    <span class="comment">//third</span></span><br><span class="line">    sum = delta * <span class="number">32</span>;</span><br><span class="line">    v9 = flag[<span class="number">1</span>]|(flag[<span class="number">2</span>]&lt;&lt;<span class="number">8</span>)|(flag[<span class="number">3</span>]&lt;&lt;<span class="number">16</span>)|(flag[<span class="number">4</span>]&lt;&lt;<span class="number">24</span>);</span><br><span class="line">    v10 = flag[<span class="number">5</span>]|(flag[<span class="number">6</span>]&lt;&lt;<span class="number">8</span>)|(flag[<span class="number">7</span>]&lt;&lt;<span class="number">16</span>)|(flag[<span class="number">8</span>]&lt;&lt;<span class="number">24</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; <span class="number">32</span>;i++)&#123;</span><br><span class="line">        v10 -= (sum + v9) ^ (key3 + <span class="number">32</span> * v9) ^ (key4 + <span class="number">16</span> * v9);</span><br><span class="line">        v9 -= (sum + v10) ^ (key1 + <span class="number">32</span> * v10) ^ (key2 + <span class="number">16</span> * v10);</span><br><span class="line">        sum -= delta;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">trans</span>(v9,<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">trans</span>(v10,<span class="number">5</span>);</span><br><span class="line">    <span class="comment">//forth</span></span><br><span class="line">    sum = delta * <span class="number">32</span>;</span><br><span class="line">    v5 = flag[<span class="number">0</span>]|(flag[<span class="number">1</span>]&lt;&lt;<span class="number">8</span>)|(flag[<span class="number">2</span>]&lt;&lt;<span class="number">16</span>)|(flag[<span class="number">3</span>]&lt;&lt;<span class="number">24</span>);</span><br><span class="line">    v6 = flag[<span class="number">4</span>]|(flag[<span class="number">5</span>]&lt;&lt;<span class="number">8</span>)|(flag[<span class="number">6</span>]&lt;&lt;<span class="number">16</span>)|(flag[<span class="number">7</span>]&lt;&lt;<span class="number">24</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; <span class="number">32</span>;i++)&#123;</span><br><span class="line">        v6 -= (sum + v5) ^ (<span class="number">16</span> * v5 + key4) ^ (<span class="number">32</span> * v5 + key3);</span><br><span class="line">        v5 -= (sum + v6) ^ (<span class="number">16</span> * v6 + key2) ^ (<span class="number">32</span> * v6 + key1);</span><br><span class="line">        sum -= delta;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">trans</span>(v5,<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">trans</span>(v6,<span class="number">4</span>);</span><br><span class="line">    <span class="comment">//print</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; <span class="number">32</span>;i++)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>,flag[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//hgame&#123;#Cpp_is_0bJ3cT_0r1enTeD?!&#125;</span></span><br></pre></td></tr></table></figure><h2 id="0x03-arithmetic"><a href="#0x03-arithmetic" class="headerlink" title="0x03 arithmetic"></a>0x03 arithmetic</h2><p>先upx脱壳，由于被改了特征值导致没法用工具upx -d脱壳，用010editor打开，然后修改，将3E0h行的首四个十六进制数改成55 50  58 21，对应字符UPX！，若没有这个特征值将无法upx -d脱壳。</p><p><a href="https://blog.csdn.net/whatday/article/details/99709317">关于upx加壳的文章</a></p><p>之后便是求解数塔问题了，根据提示是求最大路径和，左1右2，在大佬朋友的帮助下也是把脚本弄出来了。</p><p>out里面存着数塔的数据，500行，粘贴到崩溃。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="comment">//dp数塔</span></span><br><span class="line"><span class="type">int</span> a[<span class="number">1000</span>][<span class="number">1000</span>];</span><br><span class="line"><span class="comment">//存放着最大路径</span></span><br><span class="line"><span class="type">int</span> step[<span class="number">1000</span>];</span><br><span class="line"><span class="comment">//原数塔</span></span><br><span class="line"><span class="type">int</span> b[<span class="number">1000</span>][<span class="number">1000</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">cin &gt;&gt; n;</span><br><span class="line"><span class="comment">//读取数塔</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= i; j++)&#123;</span><br><span class="line">cin &gt;&gt; a[i][j];</span><br><span class="line">b[i][j] = a[i][j];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//计算最大和</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = n - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= i; j++)&#123;</span><br><span class="line">a[i][j] += <span class="built_in">max</span>(a[i + <span class="number">1</span>][j], a[i + <span class="number">1</span>][j + <span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//求最长路径</span></span><br><span class="line"><span class="type">int</span> x = <span class="number">0</span>, y = <span class="number">0</span>;</span><br><span class="line"><span class="comment">//根据a数组来求，a数组是已经被修改过的数组，每一层的值是从底层开始求和的最优解</span></span><br><span class="line">step[<span class="number">0</span>] = b[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++)&#123;</span><br><span class="line"><span class="comment">//若左边大时</span></span><br><span class="line"><span class="keyword">if</span> (a[x + <span class="number">1</span>][y] &gt; a[x + <span class="number">1</span>][y + <span class="number">1</span>])&#123;</span><br><span class="line">step[i + <span class="number">1</span>] = b[x + <span class="number">1</span>][y];</span><br><span class="line">x++;</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;1&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//右边的数据较大时</span></span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">step[i + <span class="number">1</span>] = b[x + <span class="number">1</span>][y + <span class="number">1</span>];</span><br><span class="line">x++;</span><br><span class="line">y++;</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;2&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>得出1，2串后，再去在线网站md5加密一下就是flag值了</p><p><a href="https://www.cmd5.org/">在线md5加密解密网站</a></p><p>hgame{934f7f68145038b3b81482b3d9f3a355}</p><h2 id="0x04-findme"><a href="#0x04-findme" class="headerlink" title="0x04 findme"></a>0x04 findme</h2><p>文件用ida打开，两个fake_flag，然后就不知道该怎么做了，经过式神的hint，才知道put（buffer）的端倪。</p><p>上网查MZ，出现dos头和pe文件等的东西，可以找这篇文件了解一下，讲的很好：<a href="https://www.cnblogs.com/liert/p/17089779.html">PE文件详解</a></p><p>用010editor打开文件，果不其然，文件的前面果然有mz头等数据文件</p><p><img src="/Images/image-20240217012122559.png" alt="image-20240217012122559"></p><p>记住这些东西对接下来的逆向有很大的帮助。</p><p>上文提到buffer，从这个地址开始，有M…Z等字符，猜测是把一个可执行PE文件用某些方式藏在了数据段里，在010editor里查找4D 00 00 00 5A 00 00 00，果不其然，确实有这样一个东西。</p><p><img src="/Images/image-20240217012417034.png" alt="image-20240217012417034"></p><p>而且我惊喜地发现，这些数据文件竟然就是dos头的那些数据，只不过把原本8位的数据用32位的方式存储了，也就是这里显示出来的，一个有用十六进制数再加6个0。从上往下，搜寻一下这种存储方式的所有数据，把他们全部复制到新的文件里（注意要复制直到没有这种存储规则的数据），我这里命名为 1 。（随便名的），接下来就是用个脚本删去这些无意义的00 00 00了。</p><p>由于不会写修改二进制文件的脚本，我干脆用python把他读取出来，然后再把读出来的文件粘贴到一个十六进制文本文件里。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">cnt = <span class="number">0</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">r&quot;C:\Users\28382\Desktop\1&quot;</span>,<span class="string">&#x27;rb&#x27;</span>) <span class="keyword">as</span> file:</span><br><span class="line">    content = file.read()</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> content:</span><br><span class="line">        <span class="comment">#用这个方法筛掉00 00 00</span></span><br><span class="line">        <span class="keyword">if</span> cnt % <span class="number">4</span> == <span class="number">0</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="built_in">hex</span>(i)[<span class="number">2</span>:])</span><br><span class="line">        cnt += <span class="number">1</span></span><br></pre></td></tr></table></figure><p>运行后的十六进制数直接粘贴到010editor里新建的十六进制文本文件就好了。</p><p>注意：粘贴十六进制数要用shift+ctrl+V，不然就会粘贴成文本</p><p>然后保存，用die查一下文件类型，</p><p><img src="/Images/image-20240217013008652.png" alt="image-20240217013008652"></p><p>真是非常amazing啊，变成了应该PE文件，这下就可以用ida开始逆向了。</p><p>打开后去除一堆花指令，（这里只有jz和jnz），然后f5看看伪代码。有两个函数，看着像是rc4加密。</p><p>直到我发现有负数下标的数组，我就知道这东西不简单，</p><p><img src="/Images/51bb215441e3538249c21cd3da60511.png" alt="51bb215441e3538249c21cd3da60511"></p><p>以input的首地址为基准，负数代表向后取地址，调试后发现input后面存放的便是key数组，由此推断result的取值和你input什么东西是没有任何关系的，因为result 的值都来自于key数组，而且向后取地址的多少也取决于key，也就是这个-(v4+ key[v1]) 的值，只和key数组有关系。动调把result 的值都跑出来，然后用enc减去他就好了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="type">int</span> enc[<span class="number">32</span>] = &#123;<span class="number">0x7D</span>, <span class="number">0x2B</span>, <span class="number">0x43</span>, <span class="number">0xA9</span>, <span class="number">0xB9</span>, <span class="number">0x6B</span>, <span class="number">0x93</span>, <span class="number">0x2D</span>, <span class="number">0x9A</span>, <span class="number">0xD0</span>,</span><br><span class="line">       <span class="number">0x48</span>, <span class="number">0xC8</span>, <span class="number">0xEB</span>, <span class="number">0x51</span>, <span class="number">0x59</span>, <span class="number">0xE9</span>, <span class="number">0x74</span>, <span class="number">0x68</span>, <span class="number">0x8A</span>, <span class="number">0x45</span>,</span><br><span class="line">       <span class="number">0x6B</span>, <span class="number">0xBA</span>, <span class="number">0xA7</span>, <span class="number">0x16</span>, <span class="number">0xF1</span>, <span class="number">0x10</span>, <span class="number">0x74</span>, <span class="number">0xD5</span>, <span class="number">0x41</span>, <span class="number">0x3C</span>,</span><br><span class="line">       <span class="number">0x67</span>, <span class="number">0x7D</span>&#125;;</span><br><span class="line"><span class="type">int</span> result[<span class="number">32</span>] = &#123;<span class="number">0x15</span>,<span class="number">0xC4</span>,<span class="number">0xe2</span>,<span class="number">0x3c</span>,<span class="number">0x54</span>,<span class="number">0xf0</span>,<span class="number">0x4d</span>,<span class="number">0xc1</span>,</span><br><span class="line"><span class="number">0x6a</span>,<span class="number">0x59</span>,<span class="number">0x15</span>,<span class="number">0x56</span>,<span class="number">0x78</span>,<span class="number">0xf2</span>,<span class="number">0x18</span>,<span class="number">0x77</span>,<span class="number">0x41</span>,<span class="number">0x09</span>,</span><br><span class="line"><span class="number">0x34</span>,<span class="number">0xe0</span>,<span class="number">0xf9</span>,<span class="number">0x41</span>,<span class="number">0x48</span>,<span class="number">0xb0</span>,<span class="number">0x7f</span>,<span class="number">0xdc</span>,<span class="number">0xd</span>,<span class="number">0x63</span>,<span class="number">0xe0</span>,</span><br><span class="line"><span class="number">0xce</span>,<span class="number">0xf3</span>,<span class="number">0x0</span>&#125;;</span><br><span class="line"><span class="type">int</span> temp;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt;<span class="number">32</span>;i++)&#123;</span><br><span class="line">temp = enc[i] - result[i];</span><br><span class="line"><span class="keyword">if</span>(temp &lt; <span class="number">0</span>)&#123;</span><br><span class="line">temp += <span class="number">256</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>,temp);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//hgame&#123;Fl0w3rs_Ar3_Very_fr4grant&#125;</span></span><br></pre></td></tr></table></figure><h2 id="0x05-mystery"><a href="#0x05-mystery" class="headerlink" title="0x05 mystery"></a>0x05 mystery</h2><p>这题一打开就发现是个RC4加密。</p><p><img src="/Images/image-20240222132959481.png" alt="image-20240222132959481"></p><p>这里的key实际上被修改过，按x查找引用，</p><p><img src="/Images/image-20240222133036979.png" alt="image-20240222133036979"></p><p>这些全都不管，反正大概知道这么个事情，然后直接点开sub_1500 的加密函数，和rc4相差的地方在于最后一步是减法而不是异或，原理一样，直接开虚拟机动调把每一轮的result跑出来，然后直接和密文相加就能得到flag了。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">result = [<span class="number">0x18</span>,<span class="number">0x25</span>,<span class="number">0x29</span>,<span class="number">0x20</span>,<span class="number">0x19</span>,</span><br><span class="line">          <span class="number">0x27</span>,<span class="number">0xb9</span>,<span class="number">0xc9</span>,<span class="number">0x34</span>,<span class="number">0xc7</span>,</span><br><span class="line">          <span class="number">0x71</span>,<span class="number">0xc9</span>,<span class="number">0xac</span>,<span class="number">0x17</span>,<span class="number">0xb4</span>,</span><br><span class="line">          <span class="number">0x1e</span>,<span class="number">0xe5</span>,<span class="number">0xe9</span>,<span class="number">0xfc</span>,<span class="number">0x2a</span>,</span><br><span class="line">          <span class="number">0x4a</span>,<span class="number">0x01</span>,<span class="number">0xea</span>,<span class="number">0x79</span>,<span class="number">0xc7</span>,</span><br><span class="line">          <span class="number">0x82</span>,<span class="number">0xfe</span>,<span class="number">0x51</span>,<span class="number">0xe7</span>,<span class="number">0xb1</span>,</span><br><span class="line">          <span class="number">0xae</span>,<span class="number">0x28</span>]</span><br><span class="line">enc = [<span class="number">0x50</span>, <span class="number">0x42</span>, <span class="number">0x38</span>, <span class="number">0x4D</span>, <span class="number">0x4C</span>, <span class="number">0x54</span>, <span class="number">0x90</span>, <span class="number">0x6F</span>, <span class="number">0xFE</span>, <span class="number">0x6F</span>,</span><br><span class="line">       <span class="number">0xBC</span>, <span class="number">0x69</span>, <span class="number">0xB9</span>, <span class="number">0x22</span>, <span class="number">0x7C</span>, <span class="number">0x16</span>, <span class="number">0x8F</span>, <span class="number">0x44</span>, <span class="number">0x38</span>, <span class="number">0x4A</span>,</span><br><span class="line">       <span class="number">0xEF</span>, <span class="number">0x37</span>, <span class="number">0x43</span>, <span class="number">0xC0</span>, <span class="number">0xA2</span>, <span class="number">0xB6</span>, <span class="number">0x34</span>, <span class="number">0x2C</span>]</span><br><span class="line">flag = <span class="string">&#x27;&#x27;</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">28</span>):</span><br><span class="line">    flag += <span class="built_in">chr</span>((enc[i] + result[i]) &amp; <span class="number">0xff</span>)</span><br><span class="line"><span class="built_in">print</span>(flag)</span><br><span class="line"><span class="comment">#hgame&#123;I826-2e904t-4t98-9i82&#125;</span></span><br></pre></td></tr></table></figure><h2 id="0x06-change"><a href="#0x06-change" class="headerlink" title="0x06 change"></a>0x06 change</h2><p>其实这题挺简单的，但是加了很多混淆视听的东西。</p><p><img src="/Images/image-20240226163834401.png" alt="image-20240226163834401"></p><p>题目里有大量的这种函数，一开始看着懵懵的，后面调试才发现这是一个取地址的函数，第一个参数是地址，第二个参数是偏移量，返回偏移后的地址，实际上就是一个数组enc[i]。</p><p><img src="/Images/image-20240226164002861.png" alt="image-20240226164002861" style="zoom: 80%;" /></p><p>加密函数里也一堆这种逻辑的函数，这里简化后就是分别取input[i]和key[i%key_len]，然后进去beep加密，对，按理来说应该是这样的，不过不知道为什么，这个beep函数里面调用的那个函数里面啥也没有，静态上是一个变量，没有被赋值。这里猜测是使用了函数指针，在之前给这个beep里面的变量赋值了一个函数指针，向上查找还真有，这里的sub_7FF7A…的函数，点进去，将传入的函数指针，也就是这个sub…443650，赋值给了beep里面的变量，然后通过函数指针调用这个加密函数。</p><p><img src="/Images/image-20240226164656792.png" alt="image-20240226164656792"></p><p>点进sub…443650就能发现是什么了，另外一个是a2 ^ a1，没有加10，判断一下i的奇偶就行了。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">enc = [<span class="number">0x13</span>, <span class="number">0x0A</span>, <span class="number">0x5D</span>, <span class="number">0x1C</span>, <span class="number">0x0E</span>, <span class="number">0x08</span>, <span class="number">0x23</span>, <span class="number">0x06</span>, <span class="number">0x0B</span>, <span class="number">0x4B</span>,</span><br><span class="line">       <span class="number">0x38</span>, <span class="number">0x22</span>, <span class="number">0x0D</span>, <span class="number">0x1C</span>, <span class="number">0x48</span>, <span class="number">0x0C</span>, <span class="number">0x66</span>, <span class="number">0x15</span>, <span class="number">0x48</span>, <span class="number">0x1B</span>,</span><br><span class="line">       <span class="number">0x0D</span>, <span class="number">0x0E</span>, <span class="number">0x10</span>, <span class="number">0x4F</span>]</span><br><span class="line">key = <span class="string">&quot;am2qasl&quot;</span></span><br><span class="line">flag = <span class="string">&quot;&quot;</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">24</span>):</span><br><span class="line">       <span class="keyword">if</span> i % <span class="number">2</span> == <span class="number">0</span>:</span><br><span class="line">              enc[i] -= <span class="number">10</span></span><br><span class="line">       flag += <span class="built_in">chr</span>(<span class="built_in">ord</span>(key[i%<span class="number">7</span>])^enc[i])</span><br><span class="line"><span class="built_in">print</span>(flag)</span><br><span class="line"><span class="comment">#hgame&#123;ugly_Cpp_and_hook&#125;</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Re-wp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基础 </tag>
            
            <tag> 逆向 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>picoCTF</title>
      <link href="/2024/02/14/picoCTF/"/>
      <url>/2024/02/14/picoCTF/</url>
      
        <content type="html"><![CDATA[<h2 id="0x01-packer"><a href="#0x01-packer" class="headerlink" title="0x01 packer"></a>0x01 packer</h2><p>elf的upx打包，我用windows的upx解不出来，开了个虚拟机在linux下就可以解包了，一开始就有flag串，十六进制转一下字符串就得到了。</p><p>picoCTF{U9X_UnP4ck1N6_B1n4Ri3S_1a5a3f39}</p><h2 id="0x02-FactCheck"><a href="#0x02-FactCheck" class="headerlink" title="0x02 FactCheck"></a>0x02 FactCheck</h2><p>cpp程序，反编译出来很多很长，看了一下逻辑就是创建很多个字符变量，然后根据最后的逻辑按一定顺序的将这些字符append到半成品flag上，耐心看看就好了。</p><p>picoCTF{wELF_d0N3_mate_2394047a}</p><h2 id="0x03-WinAntiDbg0x100"><a href="#0x03-WinAntiDbg0x100" class="headerlink" title="0x03 WinAntiDbg0x100"></a>0x03 WinAntiDbg0x100</h2><p>介绍说是一个反调试，点进去我感觉是这个阻碍我调试了，被调试时这个函数返回result=1，外部有个if接收了这个1后会导致程序退出，我们单步调试时在外部那个if前停下，然后修改ZF标志位，就能使程序跑向解密的二进制文件的代码了，直接查看内存里的密文就能得到flag。</p><p><img src="../../../Hexo_Blog/blog-demo/source/Images/image-20240314112708882.png" alt="image-20240314112708882"></p><p>picoCTF{d3bug_for_th3_Win_0x100_e70398c9}</p><h2 id="0x04-Classic-Crackme-0x100"><a href="#0x04-Classic-Crackme-0x100" class="headerlink" title="0x04 Classic Crackme 0x100"></a>0x04 Classic Crackme 0x100</h2><p>elf程序用ida打开后是一串50个字符串的有与运算和位移运算的加密代码，总共加密三轮，每轮算出一个参数，我在脚本里命名为temp，是random2和secret3得出来的，然后每轮明文加这个temp再模26，我在脚本里直接写成加3倍temp模26，等价的。</p><p>代码里用0-25代替a-z，得先把密文转化成数字格式，最后再转化成字母格式。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">enc = <span class="string">&quot;mpknnphjngbhgzydttvkahppevhkmpwgdzxsykkokriepfnrdm&quot;</span></span><br><span class="line">enc1 = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(enc)):</span><br><span class="line">    enc1.append(<span class="built_in">ord</span>(enc[i])-<span class="number">97</span>)</span><br><span class="line">i = <span class="number">0</span></span><br><span class="line">secret1 = <span class="number">0x55</span></span><br><span class="line">secret2 = <span class="number">0x33</span></span><br><span class="line">secret3 = <span class="number">0xF</span></span><br><span class="line">fix = <span class="number">97</span></span><br><span class="line">flag = <span class="string">&quot;&quot;</span></span><br><span class="line"><span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(enc1)):</span><br><span class="line">    random1 = (secret1 &amp; (j % <span class="number">255</span>)) + (secret1 &amp; ((j % <span class="number">255</span>) &gt;&gt; <span class="number">1</span>))</span><br><span class="line">    random2 = (random1 &amp; secret2) + (secret2 &amp; (random1 &gt;&gt; <span class="number">2</span>))</span><br><span class="line">    temp = (random2 &amp; secret3) + (secret3 &amp; (random2 &gt;&gt; <span class="number">4</span>))</span><br><span class="line">    <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,<span class="number">26</span>):</span><br><span class="line">        <span class="keyword">if</span> (k + <span class="number">3</span>*temp) % <span class="number">26</span> == enc1[j]:</span><br><span class="line">            flag += <span class="built_in">chr</span>(k+<span class="number">97</span>)</span><br><span class="line"><span class="built_in">print</span>(flag)</span><br><span class="line"><span class="comment">#mmhhkjbakavyaqprqnpbuygdymyyddkratrjsbbceizsgtbcxd</span></span><br></pre></td></tr></table></figure><p>开个kali虚拟机连接靶机，就能得到flag了。</p><p><img src="../../../Hexo_Blog/blog-demo/source/Images/e7addc20847c375ec7ee3b052729983.png" alt="e7addc20847c375ec7ee3b052729983"></p><p>picoCTF{s0lv3_angry_symb0ls_ddcc130f}</p><h2 id="0x05-weirdSnake"><a href="#0x05-weirdSnake" class="headerlink" title="0x05 weirdSnake"></a>0x05 weirdSnake</h2><p>这题打开是一个二进制文件，然后用010editor打开发现是python字节码，python字节码类似于在python的虚拟机里执行的代码，各种操作码的详情可以见<a href="https://docs.python.org/zh-cn/3.8/library/dis.html">中文官网</a></p><p>LOAD_CONST是入栈，然后STORE_NAME是把栈顶元素赋值给key_str，LOAD _NAME是把key_str入栈。分析下图的过程，尝试翻译成简单的过程。（这里的BINARY_ADD均指str重载的加法，即字符串拼接）</p><p><img src="../../../Hexo_Blog/blog-demo/source/Images/image-20240314201406973.png" alt="image-20240314201406973" style="zoom: 67%;" /></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">key = <span class="string">&quot;t_Jo3&quot;</span> </span><br><span class="line">enc = [<span class="number">4</span>,<span class="number">54</span>,<span class="number">41</span>,<span class="number">0</span>,<span class="number">112</span>,<span class="number">32</span>,<span class="number">25</span>,<span class="number">49</span>,<span class="number">33</span>,<span class="number">3</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">57</span>,<span class="number">32</span>,<span class="number">108</span>,<span class="number">23</span>,<span class="number">48</span>,<span class="number">4</span>,<span class="number">9</span>,<span class="number">70</span>,<span class="number">7</span>,</span><br><span class="line">       <span class="number">110</span>,<span class="number">36</span>,<span class="number">8</span>,<span class="number">108</span>,<span class="number">7</span>,<span class="number">49</span>,<span class="number">10</span>,<span class="number">4</span>,<span class="number">86</span>,<span class="number">43</span>,<span class="number">106</span>,<span class="number">123</span>,<span class="number">89</span>,<span class="number">87</span>,<span class="number">18</span>,<span class="number">62</span>,<span class="number">47</span>,<span class="number">10</span>,<span class="number">78</span>]</span><br><span class="line">flag = <span class="string">&quot;&quot;</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(enc)):</span><br><span class="line">       flag += <span class="built_in">chr</span>(<span class="built_in">ord</span>(key[i % <span class="number">5</span>]) ^ enc[i])</span><br><span class="line"><span class="built_in">print</span>(flag)</span><br><span class="line"><span class="comment">#picoCTF&#123;N0t_sO_coNfus1ng_sn@ke_516dfaee&#125;</span></span><br></pre></td></tr></table></figure><h2 id="0x06-WinAntiDbg0x200"><a href="#0x06-WinAntiDbg0x200" class="headerlink" title="0x06 WinAntiDbg0x200"></a>0x06 WinAntiDbg0x200</h2><p>和第一题dbg一样的做法，直接调试进去就好了。</p><p>picoCTF{0x200_debug_f0r_Win_c6db2768}</p><h2 id="0x07-WinAntiDbg0x300"><a href="#0x07-WinAntiDbg0x300" class="headerlink" title="0x07 WinAntiDbg0x300"></a>0x07 WinAntiDbg0x300</h2><p>升级版，进入主程序，在开头处下个断点一步步调试，进如图下面的函数，f7进入，这个是判断你有没有用管理员启动该程序的函数，进去后通过改ZF标志位绕过检测。</p><p><img src="../../../Hexo_Blog/blog-demo/source/Images/image-20240314194216397.png" alt="image-20240314194216397" style="zoom: 50%;" /></p><p>接着往下调试，这里有个创建线程的函数，进去下个断点，f9跑进去。</p><p><img src="../../../Hexo_Blog/blog-demo/source/Images/image-20240314194347174.png" alt="image-20240314194347174" style="zoom:50%;" /></p><p>进去后发现下面有个You got flag的字符串，直接跑进去！！！！！看看图形化界面就弹出了flag窗口。</p><p><img src="../../../Hexo_Blog/blog-demo/source/Images/image-20240314194444698.png" alt="image-20240314194444698"></p><p>picoCTF{Wind0ws_antid3bg_0x300_09b94ee8}</p>]]></content>
      
      
      <categories>
          
          <category> Re-wp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基础 </tag>
            
            <tag> 逆向 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++类模板</title>
      <link href="/2024/02/08/%E7%B1%BB%E6%A8%A1%E6%9D%BF/"/>
      <url>/2024/02/08/%E7%B1%BB%E6%A8%A1%E6%9D%BF/</url>
      
        <content type="html"><![CDATA[<h2 id="类模板语法"><a href="#类模板语法" class="headerlink" title="类模板语法"></a>类模板语法</h2><p>和函数模板的写法一样，在template<class T>的下一行紧跟一个类，就是类模板。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">typeAge</span>,<span class="keyword">class</span> <span class="title class_">typeName</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">Person</span>(typeAge age,typeName name)&#123;</span><br><span class="line">            <span class="keyword">this</span>-&gt;_age = age;</span><br><span class="line">            <span class="keyword">this</span>-&gt;_name = name;</span><br><span class="line">        &#125;</span><br><span class="line">        typeAge _age;</span><br><span class="line">        typeName _name;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function">Person&lt;<span class="type">int</span>, string&gt; <span class="title">p</span><span class="params">(<span class="number">20</span>,<span class="string">&quot;Tom&quot;</span>)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="类模板特点"><a href="#类模板特点" class="headerlink" title="类模板特点"></a>类模板特点</h2><p>类模板没有自动类型推导的使用方式。</p><p>类模板在模板参数列表中可以有默认参数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">typeAge</span>,<span class="keyword">class</span> <span class="title class_">typeName</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">Person</span>(typeAge age,typeName name = string)&#123;</span><br><span class="line">            <span class="keyword">this</span>-&gt;_age = age;</span><br><span class="line">            <span class="keyword">this</span>-&gt;_name = name;</span><br><span class="line">        &#125;</span><br><span class="line">        typeAge _age;</span><br><span class="line">        typeName _name;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function">Person&lt;<span class="type">int</span>&gt; <span class="title">p</span><span class="params">(<span class="number">20</span>,<span class="string">&quot;Tom&quot;</span>)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>例子中，name的默认参数是string。（默认参数的设置和函数默认参数的规则类似，默认参数必须要在非默认参数后面出现）</p><h2 id="类模板中成员函数的创建时机"><a href="#类模板中成员函数的创建时机" class="headerlink" title="类模板中成员函数的创建时机"></a>类模板中成员函数的创建时机</h2><p>类模板中的成员函数在调用时才创建，一开始无法确定成员变量的数据类型，只有当调用了类模板后才能确定成员变量的数据类型，类模板中的成员函数在这个时机，才创建</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">showPerson</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;show&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">test</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        T obj;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">fun</span><span class="params">()</span></span>&#123;</span><br><span class="line">            obj.<span class="built_in">showPerson</span>();</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    test&lt;Person&gt; m;</span><br><span class="line">    <span class="comment">//这个时候才创建fun()</span></span><br><span class="line">    m.<span class="built_in">fun</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出show</span></span><br></pre></td></tr></table></figure><p>例子中类模板class中的fun( )只有当接收了T的数据类型才能创建，若数据类型T不是Person，无法调用fun( )函数，还会报错。创建的时机是被调用后。</p><h2 id="类模板对象做函数参数"><a href="#类模板对象做函数参数" class="headerlink" title="类模板对象做函数参数"></a>类模板对象做函数参数</h2><p>一共有三种传入方式：</p><p>1、指定传入的类型： 直接显示对象的数据类型</p><p>事先定义好函数要传入的类型，如这里的<int，string></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T1</span>,<span class="keyword">class</span> <span class="title class_">T2</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">test</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">test</span>(T1 age, T2 name)&#123;</span><br><span class="line">            <span class="keyword">this</span>-&gt;age = age;</span><br><span class="line">            <span class="keyword">this</span>-&gt;name = name;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;show&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        T1 age;</span><br><span class="line">        T2 name;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//指定传入类型</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">showfunc</span><span class="params">(test&lt;<span class="type">int</span>, string&gt; &amp;p)</span></span>&#123;</span><br><span class="line">    p.<span class="built_in">show</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function">test&lt;<span class="type">int</span>, string&gt; <span class="title">person</span><span class="params">(<span class="number">20</span>,<span class="string">&quot;Tom&quot;</span>)</span></span>;</span><br><span class="line">    <span class="built_in">showfunc</span>(person);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2、参数模板化：将对象中的参数变为模板进行传递</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//参数模板化</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T1, <span class="keyword">class</span> T2&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">showfunc</span><span class="params">(test&lt;T1, T2&gt; &amp;p)</span></span>&#123;</span><br><span class="line">    p.<span class="built_in">show</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3、整个类模板化：将这个对象类型 模板化进行传递</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//整个类模板化</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">showfunc</span><span class="params">(T &amp;p)</span></span>&#123;</span><br><span class="line">    p.<span class="built_in">show</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第一种比较实用</p><h2 id="类模板与继承"><a href="#类模板与继承" class="headerlink" title="类模板与继承"></a>类模板与继承</h2><p>当子类继承的父类是一个类模板时，子类在声明的时候，要指定出父类中T的类型</p><p>如果不指定，编译器无法给子类分配内存</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span>&#123;</span><br><span class="line">    T m;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//指定父类里T的类型为int</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son</span>: <span class="keyword">public</span> Base&lt;<span class="type">int</span>&gt;&#123;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>如果想灵活指定出父类中T的类型，子类也需变为类模板‘</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        T m;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//指定父类里T的类型为int</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T1</span>, <span class="keyword">class</span> <span class="title class_">T2</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son</span>: <span class="keyword">public</span> Base&lt;T2&gt;&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        T1 one;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//这里的int经过子类T2传递到父类的T</span></span><br><span class="line">    <span class="comment">//父类char m，子类中int one</span></span><br><span class="line">    Son&lt;<span class="type">char</span>, <span class="type">int</span>&gt; m;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="类模板成员函数类外实现"><a href="#类模板成员函数类外实现" class="headerlink" title="类模板成员函数类外实现"></a>类模板成员函数类外实现</h2><p>假设有一个类Person</p><p>构造函数类外实现</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    T1 name;</span><br><span class="line">    T2 age;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//构造函数类外实现</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T1</span>,<span class="keyword">class</span> <span class="title class_">T2</span>&gt;</span><br><span class="line">Person&lt;T1,T2&gt;::<span class="built_in">Person</span>(T1 name,T2 age)&#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;name = name;</span><br><span class="line">    <span class="keyword">this</span>-&gt;age = age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>成员函数的类外实现（假设Person类存在）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T1</span>,<span class="keyword">class</span> <span class="title class_">T2</span>&gt;</span><br><span class="line"><span class="type">void</span> Person&lt;T1,T2&gt;::<span class="built_in">showPerson</span>()&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="类模板分文件编写"><a href="#类模板分文件编写" class="headerlink" title="类模板分文件编写"></a>类模板分文件编写</h2><p>讲.h和.cpp 中的内容写到一起，再将后缀名改为.hpp（约定俗成的）</p><p>将类模板和调用编写到一起，否则会导致链接不到类模板中的成员函数（因为该函数是在被调用时才生成）</p><p>解决方法：将声明和实现写到同一个.hpp文件中。</p><h2 id="类模板和友元"><a href="#类模板和友元" class="headerlink" title="类模板和友元"></a>类模板和友元</h2><p>全局函数 类内实现</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T1</span>, <span class="keyword">class</span> <span class="title class_">T2</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line">    <span class="comment">//类内直接用friend关键字声明</span></span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">printPerson</span><span class="params">(Person&lt;T1,T2&gt; &amp;p)</span></span>&#123;</span><br><span class="line">        cout&lt;&lt;p.name&lt;&lt;endl;</span><br><span class="line">        cout&lt;&lt;p.age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">Person</span>(T1 name, T2 age)&#123;</span><br><span class="line">            <span class="keyword">this</span>-&gt;age = age;</span><br><span class="line">            <span class="keyword">this</span>-&gt;name = name;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">private</span>:     </span><br><span class="line">        T1 name;</span><br><span class="line">        T2 age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function">Person&lt;string,<span class="type">int</span>&gt; <span class="title">p</span><span class="params">(<span class="string">&quot;Tom&quot;</span>,<span class="number">20</span>)</span></span>;</span><br><span class="line">    <span class="built_in">printPerson</span>(p);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>全局函数 类外实现（比较复杂）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//提前让编译器知道Person类的存在</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T1</span>, <span class="keyword">class</span> <span class="title class_">T2</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>;</span><br><span class="line"><span class="comment">//类外实现全局函数（模板函数）</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T1</span>, <span class="function"><span class="keyword">class</span> T2</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printPerson</span><span class="params">(Person&lt;T1,T2&gt; &amp;p)</span></span>&#123;</span><br><span class="line">        cout&lt;&lt;p.name&lt;&lt;endl;</span><br><span class="line">        cout&lt;&lt;p.age;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T1</span>, <span class="keyword">class</span> <span class="title class_">T2</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line">    <span class="comment">//加空模板参数列表让编译器知道这是一个模板函数</span></span><br><span class="line">    <span class="keyword">friend</span> <span class="type">void</span> printPerson&lt;&gt;(Person&lt;T1,T2&gt; &amp;p)</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">Person</span>(T1 name, T2 age)&#123;</span><br><span class="line">            <span class="keyword">this</span>-&gt;age = age;</span><br><span class="line">            <span class="keyword">this</span>-&gt;name = name;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">private</span>:     </span><br><span class="line">        T1 name;</span><br><span class="line">        T2 age;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>总结：建议写类内实现</p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 进阶 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++函数模板</title>
      <link href="/2024/02/08/%E6%A8%A1%E6%9D%BF/"/>
      <url>/2024/02/08/%E6%A8%A1%E6%9D%BF/</url>
      
        <content type="html"><![CDATA[<h2 id="模板的概念"><a href="#模板的概念" class="headerlink" title="模板的概念"></a>模板的概念</h2><p>模板就是建立通用的模具，大大提高复用性。</p><p>模板不可以直接使用，他只是一个框架，模板的通用并不是万能的。</p><h2 id="函数模板"><a href="#函数模板" class="headerlink" title="函数模板"></a>函数模板</h2><p>函数模板的作用：建立一个通用函数，其返回值和形参类型可以不具体制定，用一个虚拟的类型来代表。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">函数声明或定义</span><br></pre></td></tr></table></figure><p>template ：声明创建模板</p><p>typename：表示其后面的符号是一种数据类型，可以用class替代</p><p>T ：通用的数据类型，名称可以替换，通常大写字母</p><p>写一个swap的函数模板</p><p>1、自动推导类型</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//函数模板</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MySwap</span><span class="params">(T &amp;a,T &amp;b)</span></span>&#123;</span><br><span class="line">    T temp = a;</span><br><span class="line">    a = b;</span><br><span class="line">    b = temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> a=<span class="number">10</span>,b=<span class="number">20</span>;</span><br><span class="line"><span class="built_in">MySwap</span>(a,b);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//自动推导类型</span></span><br></pre></td></tr></table></figure><p>2、显示指定类型</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//函数模板</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MySwap</span><span class="params">(T &amp;a,T &amp;b)</span></span>&#123;</span><br><span class="line">    T temp = a;</span><br><span class="line">    a = b;</span><br><span class="line">    b = temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> a=<span class="number">10</span>,b=<span class="number">20</span>;</span><br><span class="line"><span class="built_in">MySwap</span>&lt;<span class="type">int</span>&gt;(a,b);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//显示指定类型</span></span><br></pre></td></tr></table></figure><h2 id="函数模板的注意事项"><a href="#函数模板的注意事项" class="headerlink" title="函数模板的注意事项"></a>函数模板的注意事项</h2><p>使用自动类型推导时，必须推导出一致的数据类型T,才可以使用，T的数据类型只有一种</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fun</span><span class="params">(T &amp;a,T &amp;b)</span></span>&#123;</span><br><span class="line"><span class="comment">//函数</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//错误的案例!!!!!!!</span></span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">    <span class="type">char</span> b;</span><br><span class="line">    <span class="built_in">fun</span>(a,b);</span><br><span class="line">    <span class="comment">//T的数据类型不一致!!!!!!</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>模板必须要确定出T的数据类型，才可以使用</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fun</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//函数</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//这里必须要确定出T的数据类型，由于不传入参数没法自动类型推导</span></span><br><span class="line"><span class="built_in">fun</span>&lt;<span class="type">int</span>&gt;()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="普通函数与函数模板的区别"><a href="#普通函数与函数模板的区别" class="headerlink" title="普通函数与函数模板的区别"></a>普通函数与函数模板的区别</h2><p>普通函数与函数模板区别：</p><p>​    普通函数调用时可以发生自动类型转换(隐式类型转换)</p><p>​    函数模板调用时，如果利用自动类型推导，不会发生隐式类型转换</p><p>​    如果利用显示指定类型的方式，可以发生隐式类型转换</p><p>（有关隐式类型转化的异同）</p><h2 id="普通函数与函数模板的调用规则"><a href="#普通函数与函数模板的调用规则" class="headerlink" title="普通函数与函数模板的调用规则"></a>普通函数与函数模板的调用规则</h2><p>1、如果函数模板和普通函数都可以调用，优先调用普通函数</p><p>2、可以通过空模板参数列表 强制调用 函数模板</p><p>通过空模板  &lt;&gt;  实现</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//函数模板</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Print</span><span class="params">(T a,T b)</span></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;调用模板&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//普通函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Print</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;调用普通&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//强制优先调用模板函数</span></span><br><span class="line">    <span class="type">int</span> a,b;</span><br><span class="line">    Print&lt;&gt;(a,b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3、函数模板可以发生函数重载</p><p>4、如果函数模板可以产生更好的匹配，优先调用函数模板</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//函数模板</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Print</span><span class="params">(T a,T b)</span></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;muban&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//普通函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Print</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;putong&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//强制优先调用模板函数</span></span><br><span class="line">    <span class="type">char</span> a,b;</span><br><span class="line">    <span class="built_in">Print</span>(a,b);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出muban</span></span><br></pre></td></tr></table></figure><p>这里传入char类型，编译器优先调用模板，省去了类型转换的步骤。</p><p>注意：提供了函数模板后最好不要提供普通函数，否则容易出现二义性</p><h2 id="模板的局限性"><a href="#模板的局限性" class="headerlink" title="模板的局限性"></a>模板的局限性</h2><p>模板不是万能的，有些特定数据类型，需要用具体化方式做特殊实现</p><p>举个例子，写了一个bool类型的比较模板函数，当传入入int，double等的单个数据的数据类型时能正常使用，可是当传入自定义数据类型，如类时，模板无法正常使用，这时用具体化某个特定数据类型的版本实现代码，具体化会优先调用。</p><p>具体化，以template&lt;&gt;开头，通过名称来指出类型，优先于普通模板</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">Person</span>(<span class="type">int</span> age,string name)&#123;</span><br><span class="line">            <span class="keyword">this</span>-&gt;_age = age;</span><br><span class="line">            <span class="keyword">this</span>-&gt;_name = name;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> _age;</span><br><span class="line">        string _name;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">myCompare</span><span class="params">(T &amp;a,T &amp;b)</span></span>&#123;</span><br><span class="line">    <span class="comment">//通用实现</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;&gt; <span class="function"><span class="type">bool</span> <span class="title">myCompare</span><span class="params">(Person &amp;a,Person &amp;b)</span></span>&#123;</span><br><span class="line">    <span class="comment">//具体实现</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>学习模板是为了在STL中能够运用系统提供的模板</p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 进阶 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++多态和文件读写</title>
      <link href="/2024/02/08/%E5%A4%9A%E6%80%81%E5%92%8C%E6%96%87%E4%BB%B6%E8%AF%BB%E5%86%99/"/>
      <url>/2024/02/08/%E5%A4%9A%E6%80%81%E5%92%8C%E6%96%87%E4%BB%B6%E8%AF%BB%E5%86%99/</url>
      
        <content type="html"><![CDATA[<h1 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h1><p>多态是C++面向对象三大特效之一</p><h2 id="多态的基本概念"><a href="#多态的基本概念" class="headerlink" title="多态的基本概念"></a>多态的基本概念</h2><p>多态分为两类：</p><p>​    静态多态：如函数重载，运算符重载</p><p>​    动态多态：派生类和虚函数实现运行时多态</p><p>静态多态和动态多态的区别：</p><p>​    静态多态的函数地址早绑定，编译阶段确定函数地址</p><p>​    动态多态的函数地址晚绑定，运行阶段确定函数地址</p><p>补充：子类可以成为父类的引用，例如当一个函数传入父类的引用时，在调用函数时可以传入子类。</p><p>举个例子讲讲什么是动态多态，什么又是地址晚绑定。例如，当我们创建一个动物类（父类）时，在类内写了一个void函数void what( )，输出I am animal，这时我们再写一个子类猫，在猫类内也写一个同名的函数输出I am cat。这时写一个传入父类引用的函数，调用函数时传入子类猫。正常来说，此时函数会输出I am animal，这个属于静态多态，函数what 的地址早在编译阶段就绑定animal.what( )里的I am animal了。</p><p>我们自然是想要输出I am cat 的，这时候就要用动态多态，让地址晚绑定，在运行阶段时绑定地址，根据具体的子类执行对应的函数。</p><p>要满足动态多态的条件有：</p><p>有继承关系    </p><p>子类重写父类的虚函数（函数返回值，函数名，参数列表都完全相同）</p><p>父类的指针或者引用执行子类对象，例如例子里的cat子类对象，由父类的引用对象animal执行。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//加上virtual关键字</span></span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">what</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;I am animal&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cat</span>: <span class="keyword">public</span> Animal&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//子类的重写函数的virtual可写可不写</span></span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">what</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;I am cat&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ShowWhat</span><span class="params">(Animal &amp;animal)</span></span>&#123;</span><br><span class="line">    animal.<span class="built_in">what</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Cat cat;</span><br><span class="line">    <span class="built_in">ShowWhat</span>(cat);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>I am cat</p><h2 id="多态的原理剖析"><a href="#多态的原理剖析" class="headerlink" title="多态的原理剖析"></a>多态的原理剖析</h2><p><img src="/Images/image-20240207234523854.png" alt="image-20240207234523854"></p><p>如图，当类内定义虚函数时，会产生一个虚函数指针和虚函数表，指针指向表，子类会继承父类的虚函数指针，但是当子类重写父类虚函数时，子类的虚函数地址会覆盖继承下来的虚函数表里面的父类的虚函数地址，这时当父类的指针或引用指向子类对象时，会发生多态。若对象是cat（子类），vfptr（从父类继承下来的）就指向Cat类（子类）的vftable。</p><h2 id="纯虚函数和抽象类"><a href="#纯虚函数和抽象类" class="headerlink" title="纯虚函数和抽象类"></a>纯虚函数和抽象类</h2><p>在多态中，通常父类中虚函数的实现是毫无意义的，主要都是调用子类的重写的内容</p><p>因此可以将虚函数改为纯虚函数</p><p>纯虚函数语法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">virtual</span> 返回值类型 函数名 (参数列表) = <span class="number">0</span>;</span><br></pre></td></tr></table></figure><p>当类中有了纯虚函数，这个类称为抽象类，有以下特点：</p><p>​    无法实例化对象</p><p>​    子类必须重写抽象类中的纯虚函数，否则子类也属于抽象类</p><h2 id="虚析构和纯虚析构"><a href="#虚析构和纯虚析构" class="headerlink" title="虚析构和纯虚析构"></a>虚析构和纯虚析构</h2><p>多态使用时，如果子类中有属性开辟到堆区，那么父类指针在释放时无法调用到子类的析构代码</p><p>解决方式 :  将父类中的析构函数改为虚析构或者纯虚析构</p><p>虚析构和纯虚析构共性：</p><p>​    可以解决父类指针释放子类对象</p><p>​    都需要有具体的函数实现</p><p>虚析构和纯虚析构区别：</p><p>​    如果是纯虚析构，该类属于抽象类，无法实例化对象</p><p>纯虚析构</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Speak</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">virtual</span> ~<span class="built_in">Animal</span>() = <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line">Animal::~<span class="built_in">Animal</span>()&#123;</span><br><span class="line">    <span class="comment">//纯虚析构函数调用</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cat</span>: <span class="keyword">public</span> Animal&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">Cat</span>(string name)&#123;</span><br><span class="line">            <span class="comment">//Cat构造函数</span></span><br><span class="line">            Name = <span class="keyword">new</span> <span class="built_in">string</span>(name);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">Speak</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Cat is saying!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        ~<span class="built_in">Cat</span>()&#123;</span><br><span class="line">            <span class="comment">//Cat的析构函数</span></span><br><span class="line">            <span class="keyword">if</span>(<span class="keyword">this</span>-&gt;Name != <span class="literal">NULL</span>)&#123;</span><br><span class="line">                <span class="keyword">delete</span> Name;</span><br><span class="line">                Name = <span class="literal">NULL</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        string *Name;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>虚析构</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Speak</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">virtual</span> ~<span class="built_in">Animal</span>()&#123;</span><br><span class="line">            <span class="comment">//虚析构调用</span></span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cat</span>: <span class="keyword">public</span> Animal&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">Cat</span>(string name)&#123;</span><br><span class="line">            <span class="comment">//Cat构造函数</span></span><br><span class="line">            Name = <span class="keyword">new</span> <span class="built_in">string</span>(name);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">Speak</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Cat is saying!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        ~<span class="built_in">Cat</span>()&#123;</span><br><span class="line">            <span class="comment">//Cat的析构函数</span></span><br><span class="line">            <span class="keyword">if</span>(<span class="keyword">this</span>-&gt;Name != <span class="literal">NULL</span>)&#123;</span><br><span class="line">                <span class="keyword">delete</span> Name;</span><br><span class="line">                Name = <span class="literal">NULL</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        string *Name;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>基本一致</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Animal *animal = <span class="keyword">new</span> <span class="built_in">Cat</span>(<span class="string">&quot;Tom&quot;</span>);</span><br><span class="line">    animal-&gt;<span class="built_in">Speak</span>();</span><br><span class="line">    <span class="keyword">delete</span> animal;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="多态的案例"><a href="#多态的案例" class="headerlink" title="多态的案例"></a>多态的案例</h2><p>多态的优点：</p><p>​    代码组织结构清晰</p><p>​    可读性强</p><p>​    利于前期和后期的扩展以及维护</p><h3 id="案例1-计算机类"><a href="#案例1-计算机类" class="headerlink" title="案例1 计算机类"></a>案例1 计算机类</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//先实现一个计算机抽象类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Calculator</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="type">int</span> <span class="title">result</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Error!!&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> num1,num2;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//加法计算器</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Add</span>: <span class="keyword">public</span> Calculator&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="type">int</span> <span class="title">result</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> num1 + num2;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//减法计算器</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Sub</span>: <span class="keyword">public</span> Calculator&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="type">int</span> <span class="title">result</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> num1 - num2;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>以此类推，能一直扩展计算器的运算功能，以此创建一个对象试着计算一下</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//实现加法运算</span></span><br><span class="line">Calculator *ptr = <span class="keyword">new</span> Add;</span><br><span class="line">ptr-&gt;num1 = <span class="number">100</span>;</span><br><span class="line">ptr-&gt;num2 = <span class="number">100</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, ptr-&gt;<span class="built_in">result</span>());</span><br><span class="line"><span class="keyword">delete</span> ptr;</span><br><span class="line"><span class="comment">//输出200</span></span><br></pre></td></tr></table></figure><h1 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h1><p>程序运行时产生的数据都属于临时数据，程序一旦运行结束都会被释放</p><p>通过文件可以将数据持久化</p><p>C++中对文件操作需要包含头文件 <fstream></p><p>文件类型分为两种!：</p><p>​    文本文件：文件以文本的ASCII码形式存储在计算机中</p><p>​    二进制文件：文件以文本的二进制形式存储在计算机中，用户一般不能直接读懂它们</p><p>操作文件的三大类：<br>    ofstream：写操作</p><p>​    ifstream：读操作</p><p>​    fstream：读写操作</p><h2 id="文本文件"><a href="#文本文件" class="headerlink" title="文本文件"></a>文本文件</h2><h3 id="写文件"><a href="#写文件" class="headerlink" title="写文件"></a>写文件</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//创建流对象</span></span><br><span class="line">    ofstream ofs;</span><br><span class="line">    <span class="comment">//打开文件</span></span><br><span class="line">    ofs.<span class="built_in">open</span>(<span class="string">&quot;文件路径&quot;</span>，打开方式);</span><br><span class="line">    <span class="comment">//写数据</span></span><br><span class="line">    ofs&lt;&lt;<span class="string">&quot;写入的数据&quot;</span>;</span><br><span class="line">    <span class="comment">//关闭文件</span></span><br><span class="line">    ofs.<span class="built_in">close</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="文件打开方式"><a href="#文件打开方式" class="headerlink" title="文件打开方式"></a>文件打开方式</h3><p><img src="/Images/image-20240208014845434.png" alt="image-20240208014845434"></p><p>注意：文件打开方式可以配合使用，利用  |  操作符</p><p>例如：用二进制方式写文件</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ios::binary|ios::out</span><br></pre></td></tr></table></figure><h3 id="读文件"><a href="#读文件" class="headerlink" title="读文件"></a>读文件</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//创建流对象</span></span><br><span class="line">    ifstream ifs;</span><br><span class="line">    <span class="comment">//打开文件并判断文件是否打开成功</span></span><br><span class="line">    ifs.<span class="built_in">open</span>(<span class="string">&quot;文件路径&quot;</span>，打开方式);</span><br><span class="line">    <span class="keyword">if</span>(!ifs.<span class="built_in">is_open</span>())&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;打开失败&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">//读数据（四种方式）</span></span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">//关闭文件</span></span><br><span class="line">    ifs.<span class="built_in">close</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>读数据的四种方式（介绍一下常见的）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">string buf;</span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">getline</span>(ifs,buf))&#123;</span><br><span class="line">cout&lt;&lt;buf&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> buf[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">while</span>(ifs.<span class="built_in">getline</span>(buf, <span class="built_in">sizeof</span>(buf)))&#123;</span><br><span class="line">cout&lt;&lt;buf&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> buf[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">while</span>(ifs&gt;&gt;buf)&#123;</span><br><span class="line">cout&lt;&lt;buf&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//一个一个读</span></span><br><span class="line"><span class="type">char</span> c;</span><br><span class="line"><span class="keyword">while</span>((c = ifs.<span class="built_in">get</span>()) != EOF)&#123;</span><br><span class="line">cout &lt;&lt; c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="二进制文件"><a href="#二进制文件" class="headerlink" title="二进制文件"></a>二进制文件</h2><p>打开方式要指定ios: :binary</p><h3 id="写文件-1"><a href="#写文件-1" class="headerlink" title="写文件"></a>写文件</h3><p>二进制方式写文件主要是利用流对象调用成员函数write</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ostream&amp; <span class="title">write</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *buffer, <span class="type">int</span> len)</span></span>;</span><br></pre></td></tr></table></figure><p>buffer指向内存中的一段存储空间，len是读取的字节数</p><h3 id="读文件-1"><a href="#读文件-1" class="headerlink" title="读文件"></a>读文件</h3><p>二进制方式读文件主要利用流对象调用成员函数read</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">istream&amp; <span class="title">read</span><span class="params">(<span class="type">char</span> *buffer,<span class="type">int</span> len)</span></span>;</span><br></pre></td></tr></table></figure><p>字符指针buffer指向内存中一段存储空间。len是读写的字节数</p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基础 </tag>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>beginCTF</title>
      <link href="/2024/02/06/beingCTF-WP/"/>
      <url>/2024/02/06/beingCTF-WP/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>这次不太好评价，感觉对我来说是降维打击，首先感谢队里的所有朋友们，是你们的陪伴和互助我才能坚持下去。</p><h2 id="0x01红白机"><a href="#0x01红白机" class="headerlink" title="0x01红白机"></a>0x01红白机</h2><p>看文件标题，猜测是6052汇编语言，作为上世纪的古老汇编，我自然是看不懂的，这里有个网址能运行<a href="https://codediy.github.io/nes-zh/easy6502/index.html">6052汇编</a></p><p>如果感兴趣还有教学，该博客对6052汇编的介绍还是有理有据的。</p><p><img src="/Images/ec51921f958fc86b6271cd70b5f3152.png" alt="ec51921f958fc86b6271cd70b5f3152"></p><p>flag{6502_I_LOVE_u}</p><h2 id="0x02xor"><a href="#0x02xor" class="headerlink" title="0x02xor"></a>0x02xor</h2><p>出题人说是简单的异或，我点进去一看一坨，不想看了，既然说是异或那就用异或试试看。</p><p><img src="/Images/f67244fb95a69b6dbc8707cf453fb9d.png" alt="f67244fb95a69b6dbc8707cf453fb9d"></p><p>找到这个极其可疑的字符串</p><p><img src="/Images/image-20240201132103590.png" alt="image-20240201132103590"></p><p>点进去打个断点调试，要你输入flag时，就把这串字符串输入进去，结果肯定是错的，但是由于异或的可逆性，这时候查看enc的值，就是正确的flag，手抄下来得到答案（偷懒取巧的做法，不可取:( ）</p><p><img src="/Images/image-20240201132331372.png" alt="image-20240201132331372"></p><p>flag{Virus_gonna_be_terminated!}</p><h2 id="0x03real-checkin-xor"><a href="#0x03real-checkin-xor" class="headerlink" title="0x03real checkin xor"></a>0x03real checkin xor</h2><p>借这又一道异或题记录一下静态做法，这题的函数相比之下就人性化许多了，一眼能看出加密过程</p><p>记录一下源码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">verify_func</span>(<span class="params">ciper,key</span>):</span><br><span class="line">    encrypted = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(ciper)):</span><br><span class="line">        encrypted.append(<span class="built_in">ord</span>(ciper[i])^<span class="built_in">ord</span>(key[i%<span class="built_in">len</span>(key)]))</span><br><span class="line">    <span class="keyword">return</span> encrypted</span><br><span class="line"></span><br><span class="line">secret = [<span class="number">7</span>, <span class="number">31</span>, <span class="number">56</span>, <span class="number">25</span>, <span class="number">23</span>, <span class="number">15</span>, <span class="number">91</span>, <span class="number">21</span>, <span class="number">49</span>, <span class="number">15</span>, <span class="number">33</span>, <span class="number">88</span>, <span class="number">26</span>, <span class="number">48</span>, <span class="number">60</span>, <span class="number">58</span>, <span class="number">4</span>, <span class="number">86</span>, <span class="number">36</span>, <span class="number">64</span>, <span class="number">23</span>, <span class="number">54</span>, <span class="number">63</span>, <span class="number">0</span>, <span class="number">54</span>, <span class="number">22</span>, <span class="number">6</span>, <span class="number">55</span>, <span class="number">59</span>, <span class="number">38</span>, <span class="number">108</span>, <span class="number">39</span>, <span class="number">45</span>, <span class="number">23</span>, <span class="number">102</span>, <span class="number">27</span>, <span class="number">11</span>, <span class="number">56</span>, <span class="number">32</span>, <span class="number">0</span>, <span class="number">82</span>, <span class="number">24</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;这是一个保险箱,你能输入相关的key来进行解密吗?&quot;</span>)</span><br><span class="line">input_line = <span class="built_in">input</span>(<span class="string">&quot;请输入key &gt; &quot;</span>)</span><br><span class="line"><span class="keyword">if</span> verify_func(input_line,<span class="string">&quot;ez_python_xor_reverse&quot;</span>) == secret:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;密码正确&quot;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;密码错误&quot;</span>)</span><br></pre></td></tr></table></figure><p>根据这个verify_func函数，复制过来改一下，就能得到解密脚本了捏</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">secret = [<span class="number">7</span>, <span class="number">31</span>, <span class="number">56</span>, <span class="number">25</span>, <span class="number">23</span>, <span class="number">15</span>, <span class="number">91</span>, <span class="number">21</span>, <span class="number">49</span>, <span class="number">15</span>, <span class="number">33</span>, <span class="number">88</span>,</span><br><span class="line">          <span class="number">26</span>, <span class="number">48</span>, <span class="number">60</span>, <span class="number">58</span>, <span class="number">4</span>, <span class="number">86</span>, <span class="number">36</span>, <span class="number">64</span>, <span class="number">23</span>, <span class="number">54</span>, <span class="number">63</span>, <span class="number">0</span>, <span class="number">54</span>, <span class="number">22</span>,</span><br><span class="line">          <span class="number">6</span>, <span class="number">55</span>, <span class="number">59</span>, <span class="number">38</span>, <span class="number">108</span>, <span class="number">39</span>, <span class="number">45</span>, <span class="number">23</span>, <span class="number">102</span>, <span class="number">27</span>, <span class="number">11</span>, <span class="number">56</span>, <span class="number">32</span>,</span><br><span class="line">          <span class="number">0</span>, <span class="number">82</span>, <span class="number">24</span>]</span><br><span class="line">key = <span class="string">&quot;ez_python_xor_reverse&quot;</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">decry</span>(<span class="params">enc, key</span>):</span><br><span class="line">    ans = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(enc)):</span><br><span class="line">        ans.append(enc[i] ^ <span class="built_in">ord</span>(key[i%<span class="built_in">len</span>(key)]))</span><br><span class="line">    <span class="keyword">return</span> ans</span><br><span class="line">flag=<span class="string">&quot;&quot;</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> decry(secret ,key):</span><br><span class="line">    flag += <span class="built_in">chr</span>(i)</span><br><span class="line"><span class="built_in">print</span>(flag)</span><br></pre></td></tr></table></figure><p>begin{3z_PY7hoN_r3V3rSE_For_TH3_Be9inNEr!}</p><h2 id="0x04俄语学习"><a href="#0x04俄语学习" class="headerlink" title="0x04俄语学习"></a>0x04俄语学习</h2><p>先找到主要的逻辑函数，观察后发现这个程序的主要逻辑是，先答对30道俄语题目然后输入flag并验证，为了便捷地动态调试这个程序，我先把前面三十道题目关于正误的判断全patch，变成答错能前进。</p><p><img src="/Images/image-20240202002450710.png" alt="image-20240202002450710"></p><p>if 判断里有个主要的函数，这个函数接收input（不是原本输入的），然后和encry后的enc比较，这里的enc能直接调试得到</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">enc = [ <span class="number">0x38</span>, <span class="number">0x9A</span>, <span class="number">0xFA</span>, <span class="number">0xC3</span>, <span class="number">0x5B</span>, <span class="number">0x89</span>, <span class="number">0xA5</span>, <span class="number">0xE6</span>, <span class="number">0xD0</span>, <span class="number">0xAB</span>,</span><br><span class="line">        <span class="number">0x42</span>, <span class="number">0x58</span>, <span class="number">0x57</span>, <span class="number">0x09</span>, <span class="number">0x42</span>, <span class="number">0xAB</span>, <span class="number">0x33</span>, <span class="number">0x2F</span>, <span class="number">0x98</span>, <span class="number">0x42</span>,</span><br><span class="line">        <span class="number">0x2E</span>, <span class="number">0x59</span>, <span class="number">0x6D</span>, <span class="number">0x41</span>]</span><br></pre></td></tr></table></figure><p>然后按X查看input的引用</p><p><img src="/Images/image-20240202002718359.png" alt="image-20240202002718359"></p><p>发现这样一个函数，input是put和need_shuzu计算得到的（这些数组都被我改过名字），最后再encry。查找put 的引用不难发现是输入的用来验证的flag，encry函数的逻辑很简单，key可以直接调试得到</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">key = [ <span class="number">0x35</span>, <span class="number">0xF1</span>, <span class="number">0xDA</span>, <span class="number">0x19</span>, <span class="number">0x7A</span>, <span class="number">0xF6</span>, <span class="number">0x31</span>, <span class="number">0x9C</span>, <span class="number">0xD9</span>, <span class="number">0x2C</span>,</span><br><span class="line">  <span class="number">0xC1</span>, <span class="number">0xFC</span>, <span class="number">0xE2</span>, <span class="number">0xD8</span>, <span class="number">0x1D</span>, <span class="number">0x8D</span>, <span class="number">0x4F</span>, <span class="number">0x97</span>, <span class="number">0x81</span>, <span class="number">0x26</span>,</span><br><span class="line">  <span class="number">0xC0</span>, <span class="number">0xB8</span>, <span class="number">0x96</span>, <span class="number">0x27</span>, <span class="number">0xD5</span>, <span class="number">0x5B</span>, <span class="number">0xAA</span>, <span class="number">0x18</span>, <span class="number">0x85</span>, <span class="number">0xFA</span>,</span><br><span class="line">  <span class="number">0x61</span>, <span class="number">0xE4</span>, <span class="number">0xA1</span>, <span class="number">0xBC</span>, <span class="number">0xF8</span>, <span class="number">0xA4</span>, <span class="number">0x56</span>, <span class="number">0x37</span>, <span class="number">0x43</span>, <span class="number">0x58</span>,</span><br><span class="line">  <span class="number">0x2B</span>, <span class="number">0xC9</span>, <span class="number">0x77</span>, <span class="number">0x64</span>, <span class="number">0xCC</span>, <span class="number">0x6B</span>, <span class="number">0x98</span>, <span class="number">0x65</span>, <span class="number">0x75</span>, <span class="number">0x38</span>,</span><br><span class="line">  <span class="number">0x80</span>, <span class="number">0x09</span>, <span class="number">0x11</span>, <span class="number">0x3D</span>, <span class="number">0xD0</span>, <span class="number">0xE6</span>, <span class="number">0x8F</span>, <span class="number">0xA9</span>, <span class="number">0x57</span>, <span class="number">0x99</span>,</span><br><span class="line">  <span class="number">0x06</span>, <span class="number">0x10</span>, <span class="number">0x5D</span>, <span class="number">0xC5</span>, <span class="number">0x69</span>, <span class="number">0xBD</span>, <span class="number">0x2D</span>, <span class="number">0x68</span>, <span class="number">0x7E</span>, <span class="number">0xE3</span>,</span><br><span class="line">  <span class="number">0x67</span>, <span class="number">0xD1</span>, <span class="number">0xFF</span>, <span class="number">0x5E</span>, <span class="number">0xF9</span>, <span class="number">0xF5</span>, <span class="number">0x41</span>, <span class="number">0x8C</span>, <span class="number">0xDD</span>, <span class="number">0x21</span>,</span><br><span class="line">  <span class="number">0x4B</span>, <span class="number">0xA7</span>, <span class="number">0x47</span>, <span class="number">0x86</span>, <span class="number">0x6D</span>, <span class="number">0xC3</span>, <span class="number">0x2A</span>, <span class="number">0x9A</span>, <span class="number">0x9F</span>, <span class="number">0x20</span>,</span><br><span class="line">  <span class="number">0x48</span>, <span class="number">0xBB</span>, <span class="number">0x94</span>, <span class="number">0xB9</span>, <span class="number">0xB4</span>, <span class="number">0x92</span>, <span class="number">0x02</span>, <span class="number">0x74</span>, <span class="number">0x7D</span>, <span class="number">0x1B</span>,</span><br><span class="line">  <span class="number">0x1E</span>, <span class="number">0x5F</span>, <span class="number">0xBA</span>, <span class="number">0x49</span>, <span class="number">0xD6</span>, <span class="number">0xE7</span>, <span class="number">0x53</span>, <span class="number">0x04</span>, <span class="number">0xCB</span>, <span class="number">0x28</span>,</span><br><span class="line">  <span class="number">0x3F</span>, <span class="number">0xE8</span>, <span class="number">0x33</span>, <span class="number">0x3E</span>, <span class="number">0x00</span>, <span class="number">0x9B</span>, <span class="number">0x6A</span>, <span class="number">0xFD</span>, <span class="number">0xBE</span>, <span class="number">0x1C</span>,</span><br><span class="line">  <span class="number">0x90</span>, <span class="number">0xED</span>, <span class="number">0xDF</span>, <span class="number">0x4D</span>, <span class="number">0x25</span>, <span class="number">0x6F</span>, <span class="number">0xB5</span>, <span class="number">0x13</span>, <span class="number">0x70</span>, <span class="number">0x3C</span>,</span><br><span class="line">  <span class="number">0x9E</span>, <span class="number">0x16</span>, <span class="number">0x0C</span>, <span class="number">0x05</span>, <span class="number">0x4A</span>, <span class="number">0x73</span>, <span class="number">0xDE</span>, <span class="number">0xB1</span>, <span class="number">0x8A</span>, <span class="number">0x51</span>,</span><br><span class="line">  <span class="number">0x3B</span>, <span class="number">0x54</span>, <span class="number">0x14</span>, <span class="number">0xE0</span>, <span class="number">0x5A</span>, <span class="number">0xDC</span>, <span class="number">0x91</span>, <span class="number">0x62</span>, <span class="number">0xA3</span>, <span class="number">0x95</span>,</span><br><span class="line">  <span class="number">0xD3</span>, <span class="number">0x3A</span>, <span class="number">0x17</span>, <span class="number">0xEE</span>, <span class="number">0x32</span>, <span class="number">0xF2</span>, <span class="number">0x7C</span>, <span class="number">0xAF</span>, <span class="number">0xB3</span>, <span class="number">0x88</span>,</span><br><span class="line">  <span class="number">0xEC</span>, <span class="number">0x0E</span>, <span class="number">0xAE</span>, <span class="number">0x9D</span>, <span class="number">0x5C</span>, <span class="number">0x0D</span>, <span class="number">0x55</span>, <span class="number">0x4E</span>, <span class="number">0xFB</span>, <span class="number">0x46</span>,</span><br><span class="line">  <span class="number">0x22</span>, <span class="number">0x44</span>, <span class="number">0x45</span>, <span class="number">0xBF</span>, <span class="number">0x52</span>, <span class="number">0x12</span>, <span class="number">0x66</span>, <span class="number">0x07</span>, <span class="number">0xD2</span>, <span class="number">0x36</span>,</span><br><span class="line">  <span class="number">0x93</span>, <span class="number">0x6E</span>, <span class="number">0x42</span>, <span class="number">0x1A</span>, <span class="number">0x0F</span>, <span class="number">0xE9</span>, <span class="number">0x60</span>, <span class="number">0xCA</span>, <span class="number">0xB2</span>, <span class="number">0x6C</span>,</span><br><span class="line">  <span class="number">0x83</span>, <span class="number">0xF0</span>, <span class="number">0x03</span>, <span class="number">0x76</span>, <span class="number">0xA8</span>, <span class="number">0x1F</span>, <span class="number">0x63</span>, <span class="number">0xEF</span>, <span class="number">0xA5</span>, <span class="number">0xCD</span>,</span><br><span class="line">  <span class="number">0x79</span>, <span class="number">0x7B</span>, <span class="number">0x0A</span>, <span class="number">0x0B</span>, <span class="number">0xAB</span>, <span class="number">0xDB</span>, <span class="number">0xD4</span>, <span class="number">0x7F</span>, <span class="number">0x01</span>, <span class="number">0x34</span>,</span><br><span class="line">  <span class="number">0x23</span>, <span class="number">0x59</span>, <span class="number">0xE1</span>, <span class="number">0x29</span>, <span class="number">0xC6</span>, <span class="number">0xAC</span>, <span class="number">0xA2</span>, <span class="number">0x40</span>, <span class="number">0xC8</span>, <span class="number">0xAD</span>,</span><br><span class="line">  <span class="number">0xC4</span>, <span class="number">0x89</span>, <span class="number">0xC2</span>, <span class="number">0xB6</span>, <span class="number">0x71</span>, <span class="number">0xA0</span>, <span class="number">0xEB</span>, <span class="number">0x2F</span>, <span class="number">0x78</span>, <span class="number">0xF3</span>,</span><br><span class="line">  <span class="number">0xB0</span>, <span class="number">0xFE</span>, <span class="number">0xCE</span>, <span class="number">0xF7</span>, <span class="number">0x84</span>, <span class="number">0x72</span>, <span class="number">0xF4</span>, <span class="number">0xCF</span>, <span class="number">0xC7</span>, <span class="number">0xD7</span>,</span><br><span class="line">  <span class="number">0xB7</span>, <span class="number">0x8E</span>, <span class="number">0x4C</span>, <span class="number">0x82</span>, <span class="number">0x30</span>, <span class="number">0x50</span>, <span class="number">0x2E</span>, <span class="number">0x24</span>, <span class="number">0x87</span>, <span class="number">0x08</span>,</span><br><span class="line">  <span class="number">0x39</span>, <span class="number">0xE5</span>, <span class="number">0xEA</span>, <span class="number">0xA6</span>, <span class="number">0x8B</span>, <span class="number">0x15</span>]</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">decry</span>(<span class="params">key, enc</span>):</span><br><span class="line">        v7 = <span class="number">0</span></span><br><span class="line">        v6 = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(enc)):</span><br><span class="line">                v7 = (v7+<span class="number">1</span>)%<span class="number">256</span></span><br><span class="line">                v6 = (v6 + key[v7])%<span class="number">256</span></span><br><span class="line">                key[v7], key[v6] = key[v6], key[v7]</span><br><span class="line">                enc[i] ^= key[(key[v6]+key[v7]) % <span class="number">256</span>]</span><br><span class="line">        <span class="keyword">return</span> enc</span><br></pre></td></tr></table></figure><p>这下只需知道need_shuzu，就能写出逆向脚本解了。</p><p>查找一下need_shuzu 的引用</p><p><img src="/Images/image-20240202002957047.png" alt="image-20240202002957047"></p><p><img src="/Images/image-20240202003018010.png" alt="image-20240202003018010"></p><p>不难发现，need_shuzu定义于这个sub_C4B4B4( )函数，且从未被修改，那么这就好办了，直接调试进去找到need_shuzu的值</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">need = [<span class="number">0x35</span>, <span class="number">0x6D</span>, <span class="number">0x35</span>, <span class="number">0x64</span>, <span class="number">0x35</span>, <span class="number">0x77</span>, <span class="number">0x35</span>, <span class="number">0x64</span>, <span class="number">0x35</span>, <span class="number">0x62</span>,</span><br><span class="line">        <span class="number">0x35</span>, <span class="number">0x6E</span>, <span class="number">0x35</span>, <span class="number">0x6D</span>, <span class="number">0x35</span>, <span class="number">0x64</span>, <span class="number">0x35</span>, <span class="number">0x77</span>, <span class="number">0x35</span>, <span class="number">0x64</span>,</span><br><span class="line">        <span class="number">0x35</span>, <span class="number">0x62</span>, <span class="number">0x35</span>, <span class="number">0x6E</span>, <span class="number">0x35</span>, <span class="number">0x6D</span>, <span class="number">0x35</span>, <span class="number">0x64</span>, <span class="number">0x35</span>, <span class="number">0x77</span>,</span><br><span class="line">        <span class="number">0x35</span>, <span class="number">0x64</span>, <span class="number">0x35</span>, <span class="number">0x62</span>, <span class="number">0x35</span>, <span class="number">0x6E</span>, <span class="number">0x8E</span>]</span><br></pre></td></tr></table></figure><p>最终脚本</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">key1 = [ <span class="number">0x35</span>, <span class="number">0xF1</span>, <span class="number">0xDA</span>, <span class="number">0x19</span>, <span class="number">0x7A</span>, <span class="number">0xF6</span>, <span class="number">0x31</span>, <span class="number">0x9C</span>, <span class="number">0xD9</span>, <span class="number">0x2C</span>,</span><br><span class="line">  <span class="number">0xC1</span>, <span class="number">0xFC</span>, <span class="number">0xE2</span>, <span class="number">0xD8</span>, <span class="number">0x1D</span>, <span class="number">0x8D</span>, <span class="number">0x4F</span>, <span class="number">0x97</span>, <span class="number">0x81</span>, <span class="number">0x26</span>,</span><br><span class="line">  <span class="number">0xC0</span>, <span class="number">0xB8</span>, <span class="number">0x96</span>, <span class="number">0x27</span>, <span class="number">0xD5</span>, <span class="number">0x5B</span>, <span class="number">0xAA</span>, <span class="number">0x18</span>, <span class="number">0x85</span>, <span class="number">0xFA</span>,</span><br><span class="line">  <span class="number">0x61</span>, <span class="number">0xE4</span>, <span class="number">0xA1</span>, <span class="number">0xBC</span>, <span class="number">0xF8</span>, <span class="number">0xA4</span>, <span class="number">0x56</span>, <span class="number">0x37</span>, <span class="number">0x43</span>, <span class="number">0x58</span>,</span><br><span class="line">  <span class="number">0x2B</span>, <span class="number">0xC9</span>, <span class="number">0x77</span>, <span class="number">0x64</span>, <span class="number">0xCC</span>, <span class="number">0x6B</span>, <span class="number">0x98</span>, <span class="number">0x65</span>, <span class="number">0x75</span>, <span class="number">0x38</span>,</span><br><span class="line">  <span class="number">0x80</span>, <span class="number">0x09</span>, <span class="number">0x11</span>, <span class="number">0x3D</span>, <span class="number">0xD0</span>, <span class="number">0xE6</span>, <span class="number">0x8F</span>, <span class="number">0xA9</span>, <span class="number">0x57</span>, <span class="number">0x99</span>,</span><br><span class="line">  <span class="number">0x06</span>, <span class="number">0x10</span>, <span class="number">0x5D</span>, <span class="number">0xC5</span>, <span class="number">0x69</span>, <span class="number">0xBD</span>, <span class="number">0x2D</span>, <span class="number">0x68</span>, <span class="number">0x7E</span>, <span class="number">0xE3</span>,</span><br><span class="line">  <span class="number">0x67</span>, <span class="number">0xD1</span>, <span class="number">0xFF</span>, <span class="number">0x5E</span>, <span class="number">0xF9</span>, <span class="number">0xF5</span>, <span class="number">0x41</span>, <span class="number">0x8C</span>, <span class="number">0xDD</span>, <span class="number">0x21</span>,</span><br><span class="line">  <span class="number">0x4B</span>, <span class="number">0xA7</span>, <span class="number">0x47</span>, <span class="number">0x86</span>, <span class="number">0x6D</span>, <span class="number">0xC3</span>, <span class="number">0x2A</span>, <span class="number">0x9A</span>, <span class="number">0x9F</span>, <span class="number">0x20</span>,</span><br><span class="line">  <span class="number">0x48</span>, <span class="number">0xBB</span>, <span class="number">0x94</span>, <span class="number">0xB9</span>, <span class="number">0xB4</span>, <span class="number">0x92</span>, <span class="number">0x02</span>, <span class="number">0x74</span>, <span class="number">0x7D</span>, <span class="number">0x1B</span>,</span><br><span class="line">  <span class="number">0x1E</span>, <span class="number">0x5F</span>, <span class="number">0xBA</span>, <span class="number">0x49</span>, <span class="number">0xD6</span>, <span class="number">0xE7</span>, <span class="number">0x53</span>, <span class="number">0x04</span>, <span class="number">0xCB</span>, <span class="number">0x28</span>,</span><br><span class="line">  <span class="number">0x3F</span>, <span class="number">0xE8</span>, <span class="number">0x33</span>, <span class="number">0x3E</span>, <span class="number">0x00</span>, <span class="number">0x9B</span>, <span class="number">0x6A</span>, <span class="number">0xFD</span>, <span class="number">0xBE</span>, <span class="number">0x1C</span>,</span><br><span class="line">  <span class="number">0x90</span>, <span class="number">0xED</span>, <span class="number">0xDF</span>, <span class="number">0x4D</span>, <span class="number">0x25</span>, <span class="number">0x6F</span>, <span class="number">0xB5</span>, <span class="number">0x13</span>, <span class="number">0x70</span>, <span class="number">0x3C</span>,</span><br><span class="line">  <span class="number">0x9E</span>, <span class="number">0x16</span>, <span class="number">0x0C</span>, <span class="number">0x05</span>, <span class="number">0x4A</span>, <span class="number">0x73</span>, <span class="number">0xDE</span>, <span class="number">0xB1</span>, <span class="number">0x8A</span>, <span class="number">0x51</span>,</span><br><span class="line">  <span class="number">0x3B</span>, <span class="number">0x54</span>, <span class="number">0x14</span>, <span class="number">0xE0</span>, <span class="number">0x5A</span>, <span class="number">0xDC</span>, <span class="number">0x91</span>, <span class="number">0x62</span>, <span class="number">0xA3</span>, <span class="number">0x95</span>,</span><br><span class="line">  <span class="number">0xD3</span>, <span class="number">0x3A</span>, <span class="number">0x17</span>, <span class="number">0xEE</span>, <span class="number">0x32</span>, <span class="number">0xF2</span>, <span class="number">0x7C</span>, <span class="number">0xAF</span>, <span class="number">0xB3</span>, <span class="number">0x88</span>,</span><br><span class="line">  <span class="number">0xEC</span>, <span class="number">0x0E</span>, <span class="number">0xAE</span>, <span class="number">0x9D</span>, <span class="number">0x5C</span>, <span class="number">0x0D</span>, <span class="number">0x55</span>, <span class="number">0x4E</span>, <span class="number">0xFB</span>, <span class="number">0x46</span>,</span><br><span class="line">  <span class="number">0x22</span>, <span class="number">0x44</span>, <span class="number">0x45</span>, <span class="number">0xBF</span>, <span class="number">0x52</span>, <span class="number">0x12</span>, <span class="number">0x66</span>, <span class="number">0x07</span>, <span class="number">0xD2</span>, <span class="number">0x36</span>,</span><br><span class="line">  <span class="number">0x93</span>, <span class="number">0x6E</span>, <span class="number">0x42</span>, <span class="number">0x1A</span>, <span class="number">0x0F</span>, <span class="number">0xE9</span>, <span class="number">0x60</span>, <span class="number">0xCA</span>, <span class="number">0xB2</span>, <span class="number">0x6C</span>,</span><br><span class="line">  <span class="number">0x83</span>, <span class="number">0xF0</span>, <span class="number">0x03</span>, <span class="number">0x76</span>, <span class="number">0xA8</span>, <span class="number">0x1F</span>, <span class="number">0x63</span>, <span class="number">0xEF</span>, <span class="number">0xA5</span>, <span class="number">0xCD</span>,</span><br><span class="line">  <span class="number">0x79</span>, <span class="number">0x7B</span>, <span class="number">0x0A</span>, <span class="number">0x0B</span>, <span class="number">0xAB</span>, <span class="number">0xDB</span>, <span class="number">0xD4</span>, <span class="number">0x7F</span>, <span class="number">0x01</span>, <span class="number">0x34</span>,</span><br><span class="line">  <span class="number">0x23</span>, <span class="number">0x59</span>, <span class="number">0xE1</span>, <span class="number">0x29</span>, <span class="number">0xC6</span>, <span class="number">0xAC</span>, <span class="number">0xA2</span>, <span class="number">0x40</span>, <span class="number">0xC8</span>, <span class="number">0xAD</span>,</span><br><span class="line">  <span class="number">0xC4</span>, <span class="number">0x89</span>, <span class="number">0xC2</span>, <span class="number">0xB6</span>, <span class="number">0x71</span>, <span class="number">0xA0</span>, <span class="number">0xEB</span>, <span class="number">0x2F</span>, <span class="number">0x78</span>, <span class="number">0xF3</span>,</span><br><span class="line">  <span class="number">0xB0</span>, <span class="number">0xFE</span>, <span class="number">0xCE</span>, <span class="number">0xF7</span>, <span class="number">0x84</span>, <span class="number">0x72</span>, <span class="number">0xF4</span>, <span class="number">0xCF</span>, <span class="number">0xC7</span>, <span class="number">0xD7</span>,</span><br><span class="line">  <span class="number">0xB7</span>, <span class="number">0x8E</span>, <span class="number">0x4C</span>, <span class="number">0x82</span>, <span class="number">0x30</span>, <span class="number">0x50</span>, <span class="number">0x2E</span>, <span class="number">0x24</span>, <span class="number">0x87</span>, <span class="number">0x08</span>,</span><br><span class="line">  <span class="number">0x39</span>, <span class="number">0xE5</span>, <span class="number">0xEA</span>, <span class="number">0xA6</span>, <span class="number">0x8B</span>, <span class="number">0x15</span>]</span><br><span class="line"></span><br><span class="line">enc = [ <span class="number">0x38</span>, <span class="number">0x9A</span>, <span class="number">0xFA</span>, <span class="number">0xC3</span>, <span class="number">0x5B</span>, <span class="number">0x89</span>, <span class="number">0xA5</span>, <span class="number">0xE6</span>, <span class="number">0xD0</span>, <span class="number">0xAB</span>,</span><br><span class="line">        <span class="number">0x42</span>, <span class="number">0x58</span>, <span class="number">0x57</span>, <span class="number">0x09</span>, <span class="number">0x42</span>, <span class="number">0xAB</span>, <span class="number">0x33</span>, <span class="number">0x2F</span>, <span class="number">0x98</span>, <span class="number">0x42</span>,</span><br><span class="line">        <span class="number">0x2E</span>, <span class="number">0x59</span>, <span class="number">0x6D</span>, <span class="number">0x41</span>]</span><br><span class="line">need = [<span class="number">0x35</span>, <span class="number">0x6D</span>, <span class="number">0x35</span>, <span class="number">0x64</span>, <span class="number">0x35</span>, <span class="number">0x77</span>, <span class="number">0x35</span>, <span class="number">0x64</span>, <span class="number">0x35</span>, <span class="number">0x62</span>,</span><br><span class="line">        <span class="number">0x35</span>, <span class="number">0x6E</span>, <span class="number">0x35</span>, <span class="number">0x6D</span>, <span class="number">0x35</span>, <span class="number">0x64</span>, <span class="number">0x35</span>, <span class="number">0x77</span>, <span class="number">0x35</span>, <span class="number">0x64</span>,</span><br><span class="line">        <span class="number">0x35</span>, <span class="number">0x62</span>, <span class="number">0x35</span>, <span class="number">0x6E</span>, <span class="number">0x35</span>, <span class="number">0x6D</span>, <span class="number">0x35</span>, <span class="number">0x64</span>, <span class="number">0x35</span>, <span class="number">0x77</span>,</span><br><span class="line">        <span class="number">0x35</span>, <span class="number">0x64</span>, <span class="number">0x35</span>, <span class="number">0x62</span>, <span class="number">0x35</span>, <span class="number">0x6E</span>, <span class="number">0x8E</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">decry</span>(<span class="params">key, enc</span>):</span><br><span class="line">        v7 = <span class="number">0</span></span><br><span class="line">        v6 = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(enc)):</span><br><span class="line">                v7 = (v7+<span class="number">1</span>)%<span class="number">256</span></span><br><span class="line">                v6 = (v6 + key[v7])%<span class="number">256</span></span><br><span class="line">                key[v7], key[v6] = key[v6], key[v7]</span><br><span class="line">                enc[i] ^= key[(key[v6]+key[v7]) % <span class="number">256</span>]</span><br><span class="line">        <span class="keyword">return</span> enc</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">        flag = []</span><br><span class="line">        <span class="built_in">input</span> = decry(key1, enc)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">24</span>):</span><br><span class="line">              flag.append(<span class="built_in">input</span>[i] + <span class="number">112</span> - need[i])</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> flag:</span><br><span class="line">                <span class="built_in">print</span>(<span class="built_in">chr</span>(i), end = <span class="string">&quot;&quot;</span>)</span><br></pre></td></tr></table></figure><p>主要逻辑就是，由enc，反推回去input，然后input再反推回去put，很好理解，其中的need_shuzu，和key通过调试能得到。这个做法看起来挺冗杂的，应该有更好的办法</p><p>flag{Russian_is_so_easy}</p><h2 id="0x05-stick-game"><a href="#0x05-stick-game" class="headerlink" title="0x05 stick game"></a>0x05 stick game</h2><p>一个网页小游戏，根据之前搭载博客时对网页的一点点理解，觉得主要的逻辑函数应该在js文件里面。</p><p>先看看游戏，说达到1337427分就能获得flag，当然正常是不能去玩的，如果js文件没有加变量名字混淆的话，存储着分数的变量应该叫score，打开文件ctrl+F找一下score变量</p><p><img src="/Images/d3ac6c2abfae882ecb8eed2305f1165.png" alt="d3ac6c2abfae882ecb8eed2305f1165"></p><p>喜报，代码没有经过格式化，一坨。后面请教大佬朋友在vscode扩展下载了一个插件Prettier - Code formatter ，下载后选中格式化。</p><p><img src="/Images/image-20240204182828372.png" alt="image-20240204182828372"></p><p>继续查找score，发现有个疑似修改分数的代码，这里的_0x3c8400作为一个变量名暂存分数，然后这个0x3a2009是一个判断是否双倍得分的参数，若为True就加2分，false就加1分，那一坨0x10a5….计算出来是2，下面-0x257…算出来是1，手动给他们后面加上1337426，这样一来，如果加一分，就相当于加了1337427分。不过这些都是建立在这个代码就是控制得分的代码的基础上的假设。</p><p><img src="/Images/image-20240204183632727.png" alt="image-20240204183632727"></p><p>下面还有一个疑似修改分数的代码，不过这个算出来score = 0，应该不太可能是加分的代码，更像是重置分数的代码。修改完后打开游戏试试，果然成功一次就加了1337427分，这时候直接跳崖，让游戏在1337427分结束，网页弹窗显示出了flag。</p><p>完全不懂javascript，静态分析对我来说太难了，如果懂的话找下弹窗函数，和其他flag的加密函数或许能解出来，不过由于代码变量名混淆，我也看不出flag在js文件里到底长什么样。</p><p>begin{y0u_re4l1y_g07_1337427_66f1ebde263de1e039063aa402d22977}</p><h2 id="0x06-ezpython"><a href="#0x06-ezpython" class="headerlink" title="0x06 ezpython"></a>0x06 ezpython</h2><p>这题真的坑，题干一直在说key有问题，我也尝试过去找有没有函数修改了key，没想到竟然是gmssl库的sm4加密解密函数里，一个叫set_key的函数被修改了，key在填入前先做了和37的异或，确实搞到我了，flag也搞我，唉，采购。除了这个就是正常的py解包反编译，不过要用3.8python解包，不然会丢失文件（因为这题是3.8python写的）（<a href="https://www.beihaihaihai.top/2024/01/29/GeekChallenge/">py解包反编译梗概</a>）。</p><p>反编译出他的ezpython文件，加以修改就能出flag了，早该如此，key 的错误一直卡死我了，唉。</p><p>ezpython.py</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># visit https://tool.lu/pyc/ for more information</span></span><br><span class="line"><span class="comment"># Version: Python 3.8</span></span><br><span class="line"><span class="keyword">from</span> secret <span class="keyword">import</span> enc,key</span><br><span class="line"><span class="keyword">from</span> gmssl <span class="keyword">import</span> sm4</span><br><span class="line"><span class="keyword">import</span> base64</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">pad_pkcs7</span>(<span class="params">data</span>):</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;PKCS#7填充&#x27;&#x27;&#x27;</span></span><br><span class="line">    padding_len = <span class="number">16</span> - <span class="built_in">len</span>(data) % <span class="number">16</span></span><br><span class="line">    padding = <span class="built_in">bytes</span>([</span><br><span class="line">        padding_len] * padding_len)</span><br><span class="line">    <span class="keyword">return</span> data + padding</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">unpad_pkcs7</span>(<span class="params">padded_data</span>):</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;PKCS#7去填充&#x27;&#x27;&#x27;</span></span><br><span class="line">    padding_len = padded_data[-<span class="number">1</span>]</span><br><span class="line">    <span class="keyword">return</span> padded_data[:-padding_len]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SM4</span>:</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.gmsm4 = sm4.CryptSM4()</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">encryptSM4</span>(<span class="params">self, encrypt_key, value</span>):</span><br><span class="line">        gmsm4 = self.gmsm4</span><br><span class="line">        gmsm4.set_key(encrypt_key.encode(), sm4.SM4_ENCRYPT)</span><br><span class="line">        padded_value = pad_pkcs7(value.encode())</span><br><span class="line">        encrypt_value = gmsm4.crypt_ecb(padded_value)</span><br><span class="line">        <span class="keyword">return</span> base64.b64encode(encrypt_value)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">decryptSM4</span>(<span class="params">self, key, value</span>):</span><br><span class="line">        gmsm4 = self.gmsm4</span><br><span class="line">        gmsm4.set_key(key.encode(), sm4.SM4_DECRYPT)</span><br><span class="line">        padded_value = base64.b64decode(value)</span><br><span class="line">        decrypted_data = gmsm4.crypt_ecb(padded_value)</span><br><span class="line">        <span class="keyword">return</span> unpad_pkcs7(decrypted_data).decode()</span><br><span class="line"></span><br><span class="line">        <span class="comment"># decrypted_data = unpad_pkcs7(value.decode())</span></span><br><span class="line">        <span class="comment"># decrypted_data = gmsm4.crypt_ecb(decrypted_data)</span></span><br><span class="line">        <span class="comment"># return base64.b64decode(decrypted_data)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="comment"># print(&#x27;请输入你的flag:&#x27;)</span></span><br><span class="line">    <span class="comment"># flag = input()</span></span><br><span class="line">    <span class="comment"># sm4_instance = SM4()</span></span><br><span class="line">    <span class="comment"># flag_1 = sm4_instance.encryptSM4(key, flag)</span></span><br><span class="line">    <span class="comment"># if flag_1 != enc:</span></span><br><span class="line">    <span class="comment">#     print(&#x27;flag错误!!&#x27;)</span></span><br><span class="line">    <span class="comment"># else:</span></span><br><span class="line">    <span class="comment">#     print(&#x27;恭喜你获得flag😊😀&#x27;)</span></span><br><span class="line">    key2 = <span class="string">&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(key)):</span><br><span class="line">        key2 += <span class="built_in">chr</span>(<span class="built_in">ord</span>(key[i]) ^ <span class="number">37</span>)</span><br><span class="line">    sm4_instance = SM4()</span><br><span class="line">    flag_1 = sm4_instance.decryptSM4(key2, enc)</span><br><span class="line">    <span class="built_in">print</span>(flag_1)</span><br></pre></td></tr></table></figure><p>secret.py</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">key = <span class="string">&#x27;BeginCTFBeginCTF&#x27;</span></span><br><span class="line">enc = <span class="string">b&#x27;JmjJEAJGMT6F9bmC+Vyxy8Z1lpfaJzdEX6BGG/qgqUjUpQaYSON1CnZyX9YXTEClSRYm7PFZtGxmJw6LPuw1ww==&#x27;</span></span><br></pre></td></tr></table></figure><p>flag{Pay_M0re_@ttention_to_th3_key!!}</p><h2 id="0x07-出题人的密码"><a href="#0x07-出题人的密码" class="headerlink" title="0x07 出题人的密码"></a>0x07 出题人的密码</h2><p>一开始做的时候被一坨看不懂的东西卡住了，后面才发现那个是没用的，引以为戒。</p><p>程序点进去无法f5，一步一步看，后面才发现是有花指令，把那些call的脏字节和无意义的jnz和jn全部都nop掉，然后反编译就能看到main函数了。</p><p><img src="/Images/image-20240207152800382.png" alt="image-20240207152800382"></p><p>正常来说这里有很多sub函数，混淆我们找加密函数，我做的时候直接找了最后拿来比较的input和enc（input 是我自己命名的）中input 的引用，反解回去两个加密函数的</p><p>encry1</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">sub_C98090</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span> result; <span class="comment">// eax</span></span><br><span class="line">  <span class="type">int</span> i; <span class="comment">// [esp+D0h] [ebp-8h]</span></span><br><span class="line"></span><br><span class="line">  result = __CheckForDebuggerJustMyCode(&amp;unk_D0D0F4);</span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt; <span class="number">48</span>; ++i )</span><br><span class="line">  &#123;</span><br><span class="line">    input[i] = (put[i] + <span class="number">5</span>) ^ <span class="number">0x25</span>;</span><br><span class="line">    result = i + <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>encry2</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sub_C97F10</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> v0; <span class="comment">// edx</span></span><br><span class="line">  <span class="type">int</span> result; <span class="comment">// eax</span></span><br><span class="line">  __int64 v2; <span class="comment">// [esp+D0h] [ebp-58h]</span></span><br><span class="line">  <span class="type">size_t</span> v3; <span class="comment">// [esp+ECh] [ebp-3Ch]</span></span><br><span class="line">  <span class="type">int</span> j; <span class="comment">// [esp+F8h] [ebp-30h]</span></span><br><span class="line">  <span class="type">int</span> i; <span class="comment">// [esp+104h] [ebp-24h]</span></span><br><span class="line">  __int64 v6; <span class="comment">// [esp+110h] [ebp-18h]</span></span><br><span class="line">  <span class="type">char</span> *v7; <span class="comment">// [esp+120h] [ebp-8h]</span></span><br><span class="line"></span><br><span class="line">  __CheckForDebuggerJustMyCode(&amp;unk_D0D0F4);</span><br><span class="line">  v3 = j__strlen(Buffer);                       <span class="comment">// 612995005</span></span><br><span class="line">  <span class="keyword">if</span> ( v3 )</span><br><span class="line">    j__srand(byte_D09FD7[v3]);</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    j__srand(<span class="number">0x123456</span>u);</span><br><span class="line">  v0 = j__rand() % <span class="number">7</span>;</span><br><span class="line">  result = unk_D09000[<span class="number">2</span> * v0];</span><br><span class="line">  LODWORD(v2) = result;</span><br><span class="line">  HIDWORD(v2) = dword_D09004[<span class="number">2</span> * v0];           <span class="comment">// 0x33077D</span></span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt; <span class="number">6</span>; ++i )</span><br><span class="line">  &#123;</span><br><span class="line">    v7 = &amp;put[<span class="number">8</span> * i];</span><br><span class="line">    v6 = *v7;</span><br><span class="line">    <span class="keyword">for</span> ( j = <span class="number">0</span>; j &lt; <span class="number">64</span>; ++j )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> ( v6 &lt; <span class="number">0</span> )</span><br><span class="line">        v6 = v2 ^ (<span class="number">2</span> * v6);</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        v6 *= <span class="number">2</span>i64;</span><br><span class="line">    &#125;</span><br><span class="line">    *v7 = v6;</span><br><span class="line">    result = i + <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中encry1不多讲了，encry2是一个主要的加密函数，他的主要逻辑就是，将enc（48个字节），按小端序存储分为6个8字节大小的长整形，然后判断整形是否为负数（其实就是看最高位是否为1），若为负数，在左移一位的基础上再异或v2（v2是用魔法得到的），若不为负数，则就只是左移1位。</p><p>这个加密的难点在于根据加密后的数才判断加密前的数是正数还是负数，因为符号位在左移一位后已经丢失了。但是由此同时左移一位后的数的最低位变成了 0，恰v2的最低位也是0。因此，若加密后的数最低位是1，说明最低位经过0 ^ 0 =1 的异或，说明加密前的数是负数（因为经过异或），若加密后的数最低位是0，说明左移后没有和v2异或过，加密前是正数。</p><p>有了这个思路，逆向思路就很明了了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> enc[] =</span><br><span class="line">&#123;</span><br><span class="line">  <span class="number">0xB4</span>, <span class="number">0xBB</span>, <span class="number">0xD8</span>, <span class="number">0xEB</span>, <span class="number">0xD0</span>, <span class="number">0x6E</span>, <span class="number">0xAB</span>, <span class="number">0xCA</span>, <span class="number">0x65</span>, <span class="number">0x8E</span>, </span><br><span class="line">  <span class="number">0x4B</span>, <span class="number">0xE9</span>, <span class="number">0x4D</span>, <span class="number">0xD4</span>, <span class="number">0x4A</span>, <span class="number">0xF3</span>, <span class="number">0x7D</span>, <span class="number">0x29</span>, <span class="number">0xC2</span>, <span class="number">0xF9</span>, </span><br><span class="line">  <span class="number">0x95</span>, <span class="number">0x89</span>, <span class="number">0xA4</span>, <span class="number">0x85</span>, <span class="number">0x9D</span>, <span class="number">0xCD</span>, <span class="number">0xDF</span>, <span class="number">0x77</span>, <span class="number">0xFD</span>, <span class="number">0x45</span>, </span><br><span class="line">  <span class="number">0xCB</span>, <span class="number">0x5D</span>, <span class="number">0x7D</span>, <span class="number">0xFD</span>, <span class="number">0x93</span>, <span class="number">0x4B</span>, <span class="number">0xBC</span>, <span class="number">0xF6</span>, <span class="number">0x7C</span>, <span class="number">0xF3</span>, </span><br><span class="line">  <span class="number">0x24</span>, <span class="number">0x42</span>, <span class="number">0xF5</span>, <span class="number">0xD2</span>, <span class="number">0xDD</span>, <span class="number">0xE3</span>, <span class="number">0x56</span>, <span class="number">0xAE</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> enc1[<span class="number">48</span>];  </span><br><span class="line"><span class="type">unsigned</span> __int64 enc2[<span class="number">6</span>];</span><br><span class="line">__int64 v2 = <span class="number">0x000000000033077D</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//encry1</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; <span class="number">48</span>; i++)&#123;</span><br><span class="line">        enc1[i] = (enc[i] ^ <span class="number">0x25</span>) - <span class="number">5</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//encry2</span></span><br><span class="line">    <span class="comment">//小端序合并字节</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">6</span>; i++)&#123;</span><br><span class="line">        enc2[i] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">8</span>; j++)&#123;</span><br><span class="line">            enc2[i] |= (__int64)enc1[<span class="number">8</span> * i + j] &lt;&lt; (<span class="number">8</span> * j);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> k = <span class="number">0</span>; k &lt; <span class="number">64</span> ; k++)&#123;</span><br><span class="line">            <span class="comment">//如果enc2[i] &amp; 1为1，说明最后一位是1，说明被异或过了，因为</span></span><br><span class="line">            <span class="comment">//移位后最后一位是0，而v2的最后一位也是0，若没有异或过，最后</span></span><br><span class="line">            <span class="comment">//一位应该是0，所以看最后一位判断之前有无异或过</span></span><br><span class="line">            <span class="keyword">if</span>(enc2[i] &amp; <span class="number">1</span>)&#123;</span><br><span class="line">                enc2[i] ^= v2;</span><br><span class="line">                enc2[i] &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">                <span class="comment">//由于题目里的判断是小于0，即第一位是1时异或v2，这时左移</span></span><br><span class="line">                <span class="comment">//会丢失数据1，应该右移后补上</span></span><br><span class="line">                enc2[i] |= <span class="number">0x8000000000000000</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                enc2[i] &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//小端序分离</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">6</span>; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">8</span>;j++)&#123;</span><br><span class="line">            enc[<span class="number">8</span> * i + j] = (enc2[i] &gt;&gt; (<span class="number">8</span> * j)) &amp; <span class="number">0xFF</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//输出flag</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; <span class="number">48</span>; i++)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>,enc[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>由于涉及到数据的溢出和大小长度，建议还是用C写脚本</p><p>begin{Th1s_reverse_pr0blem_may_t@ke_some_time#!}</p><h2 id="0x08-superguesser"><a href="#0x08-superguesser" class="headerlink" title="0x08 superguesser"></a>0x08 superguesser</h2><p>其实这题我动调了半天都不知道意义何在，一来随便点点就看到了疑似加密的主函数</p><p><img src="/Images/image-20240207161553428.png" alt="image-20240207161553428"></p><p>这里的静态代码真的看不懂，不过大概率是while循环那里，给明文依次加密，最后再比较，把一大坨密文抄一下，（v0-48）就是输入input开始的地址，长度为（v0-24）=37；然后(v0-20)=0（类似于循环里的i），(v0-25)=0x33（调试出来的）。下面那个loc_46EEF4猜测就是cmp函数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> ( *(v0 - <span class="number">20</span>) &lt; *(v0 - <span class="number">24</span>) )</span><br><span class="line">  *(*(v0 - <span class="number">48</span>) + (*(v0 - <span class="number">20</span>))++) ^= *(v0 - <span class="number">20</span>) + *(v0 - <span class="number">25</span>) + <span class="number">17</span> * *(v0 - <span class="number">26</span>);</span><br></pre></td></tr></table></figure><p>这里有个疑点，就是这个(v0-26)动调出来是1，但是实际计算根据这个1算不出来。</p><p>动调研究一下原本的汇编代码，看看哪里是有问题的。看完汇编代码发现计算时找不到这个17 *(v0-26)的操作，反而 +0x33 的操作变成了 +0x44，原因是(v0-26) = 1这一步经过位移操作后变成0x11与0x33相加，导致结果变成了0x44，感觉被反调试过了，动调出来的东西不太可信。</p><p>一位一位爆破试出来(v0-26) = 0，写出脚本就很简单了</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">enc = [<span class="number">81</span>,<span class="number">81</span>,<span class="number">82</span>,<span class="number">95</span>,<span class="number">89</span>,<span class="number">67</span>,<span class="number">93</span>,<span class="number">95</span>,<span class="number">89</span>,<span class="number">73</span>,</span><br><span class="line">       <span class="number">90</span>,<span class="number">89</span>,<span class="number">86</span>,<span class="number">46</span>,<span class="number">38</span>,<span class="number">29</span>,<span class="number">42</span>,<span class="number">55</span>,<span class="number">26</span>,<span class="number">39</span>,</span><br><span class="line">       <span class="number">41</span>,<span class="number">23</span>,<span class="number">40</span>,<span class="number">36</span>,<span class="number">42</span>,<span class="number">56</span>,<span class="number">37</span>,<span class="number">33</span>,<span class="number">61</span>,<span class="number">15</span>,</span><br><span class="line">       <span class="number">50</span>,<span class="number">58</span>,<span class="number">60</span>,<span class="number">61</span>,<span class="number">54</span>,<span class="number">51</span>,<span class="number">42</span>]</span><br><span class="line">d = <span class="number">1</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">37</span>):</span><br><span class="line">    enc[i] ^= (i + <span class="number">0x33</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">chr</span>(enc[i]),end = <span class="string">&quot;&quot;</span>)</span><br></pre></td></tr></table></figure><p>begin{debugging_is_an_anathor_choice}</p>]]></content>
      
      
      <categories>
          
          <category> Re-wp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基础 </tag>
            
            <tag> 逆向 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++继承</title>
      <link href="/2024/01/30/C-%E7%BB%A7%E6%89%BF/"/>
      <url>/2024/01/30/C-%E7%BB%A7%E6%89%BF/</url>
      
        <content type="html"><![CDATA[<h1 id="C-继承"><a href="#C-继承" class="headerlink" title="C++继承"></a>C++继承</h1><p>本节介绍C++的继承和多态的语法</p><h2 id="继承方法"><a href="#继承方法" class="headerlink" title="继承方法"></a>继承方法</h2><p>一图解</p><p><img src="Images/20200221123718539.png" alt="20200221123718539"></p><h2 id="继承中的对象模型"><a href="#继承中的对象模型" class="headerlink" title="继承中的对象模型"></a>继承中的对象模型</h2><p>一句话，在继承中，父类的私有成员只是被隐藏了，占存储空间，还是会被继承下去。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">int</span> a;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line"><span class="type">int</span> b;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">int</span> c;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son</span>: <span class="keyword">public</span> Base&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">int</span> d;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">std::cout&lt;&lt;<span class="built_in">sizeof</span>(Son)&lt;&lt;endl;</span><br><span class="line"><span class="comment">//输出16 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="构造和析构的顺序"><a href="#构造和析构的顺序" class="headerlink" title="构造和析构的顺序"></a>构造和析构的顺序</h2><p>构造和析构的顺序，先构造父类，再构造子类；先析构子类，最后再析构父类</p><h2 id="同名成员处理"><a href="#同名成员处理" class="headerlink" title="同名成员处理"></a>同名成员处理</h2><p>当子类和父类出现同名的成员时：</p><p>若访问子类同名成员，直接访问即可；若访问父类同名成员，需要加作用域。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Base</span>()&#123;</span><br><span class="line">a=<span class="number">100</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> a;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son</span>: <span class="keyword">public</span> Base&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Son</span>()&#123;</span><br><span class="line">a=<span class="number">200</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> a;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">Son s;</span><br><span class="line">std::cout&lt;&lt;s.a&lt;&lt;endl;</span><br><span class="line"><span class="comment">//输出200</span></span><br><span class="line">std::cout&lt;&lt;s.Base::a&lt;&lt;endl;</span><br><span class="line"><span class="comment">//输出100 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>子父类同名函数调用也是同理，但需要注意的是：</p><p>当子类中出现与父类同名的成员函数时，子类的同名成员会隐藏掉父类中所有的同名成员函数（各种重载函数），如果想访问到父类中被隐藏的同名成员函数，需要加作用域（作用域原理同同名成员变量）</p><h2 id="同名静态成员处理方式"><a href="#同名静态成员处理方式" class="headerlink" title="同名静态成员处理方式"></a>同名静态成员处理方式</h2><p>静态成员和非静态成员出现同名，处理方式一致</p><p>若访问子类同名成员，直接访问即可；若访问父类同名成员，需要加作用域。</p><p>静态成员能够通过类名访问，详细语法在之前的CPP类的基础中的静态成员已经提及过，——-&gt;<a href="https://www.beihaihaihai.top/2024/01/29/cpp%E7%B1%BB%E5%9F%BA%E7%A1%80/">传送门</a></p><p>(类名: :成员名，来访问静态成员)</p><h2 id="多继承语法"><a href="#多继承语法" class="headerlink" title="多继承语法"></a>多继承语法</h2><p>C++允许一个类继承多个类</p><p>语法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> 子类 : 继承方式 父类<span class="number">1</span> , 继承方式 父类<span class="number">2</span> ...</span><br></pre></td></tr></table></figure><p>多继承可能会引发父类中有同名成员出现，需要加作用域区分</p><p>（C++实际开发中不建议使用多继承）</p><p>总而言之，多继承中如果父类中出现了同名情况，子类使用时候要加作用域加以区分</p><h2 id="菱形继承"><a href="#菱形继承" class="headerlink" title="菱形继承"></a>菱形继承</h2><h3 id="菱形继承概念"><a href="#菱形继承概念" class="headerlink" title="菱形继承概念"></a>菱形继承概念</h3><p>两个派生类继承同一个基类，某个类同时继承这两个派生类，这种继承称为菱形继承，又称钻石继承。</p><h3 id="菱形继承问题"><a href="#菱形继承问题" class="headerlink" title="菱形继承问题"></a>菱形继承问题</h3><p><img src="Images/1706619988650.jpg" alt="1706619988650"></p><p>举个例子：</p><p>在这张图里面，羊继承了动物的数据，同意驼也继承了一份同样的数据，当羊驼使用数据时，就会产生二义性，解决这个问题的关键在于羊驼取动物的数据时，只从羊或者驼中之一取一份。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> :<span class="keyword">public</span> A&#123;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> :<span class="keyword">public</span> A&#123;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Bc</span> :<span class="keyword">public</span> B, <span class="keyword">public</span> C&#123;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">Bc s;</span><br><span class="line">s.B::age=<span class="number">18</span>;</span><br><span class="line">s.C::age=<span class="number">28</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>观察这个代码，虽然可以通过多继承的作用域加以区分，两个父类相同的数据，但是这样会在实际开发中产生歧义，浪费存储空间，如例子中的羊驼（Bc）的年龄是继承18还是28呢？</p><p>实际上，也应该是，这份数据，我们只要有一份就可以。</p><h3 id="解决菱形继承"><a href="#解决菱形继承" class="headerlink" title="解决菱形继承"></a>解决菱形继承</h3><p>利用虚继承，解决菱形继承的问题</p><p>继承之前加上关键字virtual，变为虚继承</p><p>在这个例子中，A类称为 虚基类</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> :<span class="keyword">virtual</span> <span class="keyword">public</span> A&#123;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> :<span class="keyword">virtual</span> <span class="keyword">public</span> A&#123;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Bc</span> :<span class="keyword">public</span> B, <span class="keyword">public</span> C&#123;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">Bc s;</span><br><span class="line">s.B::age=<span class="number">18</span>;</span><br><span class="line">s.C::age=<span class="number">28</span>;</span><br><span class="line">s.age=<span class="number">38</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>应用虚继承后，age只有一份。在上面代码的例子中，age先后被赋值为18，28，最后再被改为38，数据只有一份。虚基础是怎么实现只继承一份数据的？其实是用了虚基类指针和虚基类表</p><h3 id="虚基础原理"><a href="#虚基础原理" class="headerlink" title="虚基础原理"></a>虚基础原理</h3><p><img src="Images/3c6066e66608a29a50657a7cffc0d26.png" alt="3c6066e66608a29a50657a7cffc0d26"></p><p>在这张表中，ST从S和T类中继承了vbptr（virtual base pointer）虚基类指针，然后只有一份从虚基类（A）继承的值age。</p><p><img src="Images/c38ffa6b96452d3575201a5b78f25a4.png" alt="c38ffa6b96452d3575201a5b78f25a4"></p><p>vbptr指向vbtable（虚基类表），在这个例子中S的vbptr指向的vbtable里的偏移量为8，从vbptr地址处偏移8就能取到age的值，同理，T的vbptr指向的vbtable里的偏移量为4，从该vbptr地址处偏移4就同样能取到age的值，age的值唯一且是共享。</p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基础 </tag>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GeekChallenge 2023 re wp</title>
      <link href="/2024/01/29/GeekChallenge/"/>
      <url>/2024/01/29/GeekChallenge/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>感觉有点尴尬，这个wp并不全，因为本人打算在比赛结束后写出此文，然后发现靶场的题全下完了，然后自己也没有备份，呃呃怎么办呢？只能凭印象了，想到哪道题就写哪道题罢，然后Ida的界面的东西也没有（因为题目被我删了）只剩解密脚本了凑合着看。。。</p><h2 id="0x01-shiftjmp"><a href="#0x01-shiftjmp" class="headerlink" title="0x01 shiftjmp"></a>0x01 shiftjmp</h2><p><img src="Images/5847d3c5041d4cc9bbe0c4965dbe7367.png" alt="5847d3c5041d4cc9bbe0c4965dbe7367"></p><p>die查壳，发现是无壳的ELF64文件，直接拖入ida64</p><p><img src="Images/4f36ff36fa3d479ab15b23445ba8a9ca.png" alt="4f36ff36fa3d479ab15b23445ba8a9ca"></p><p>按tab发现无法生存伪代码，发现这里有两处错误。</p><p>这两处错误是花指令，花指令详情见<a href="https://ctf-wiki.org/reverse/obfuscate/junk-code/">花指令 - CTF Wiki (ctf-wiki.org)</a></p><p>第一处是无意义跳转，第二处是jmp造成的脏字节。</p><p>把jz和imp都nop掉。</p><p><img src="Images/5a7233f2ea1a4f72a7e4741ecb515f8c.png" alt="5a7233f2ea1a4f72a7e4741ecb515f8c"></p><p>undefine （U）然后按 c生存代码 按p生存函数main</p><p><img src="Images/23badc126cdd4ee5b8ebe570748b8172.png" alt="23badc126cdd4ee5b8ebe570748b8172"></p><p>非常简单的异或加密，写个python脚本解密</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">enc=<span class="string">&#x27;SXAxS6jd8doTxBQ&#123;x&quot;Ma&#x27;</span>+<span class="built_in">chr</span>(<span class="number">0x27</span>)+<span class="string">r&quot;csE-|El,o/&#123;^\\&quot;</span></span><br><span class="line">flag=<span class="string">&quot;&quot;</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">34</span>):</span><br><span class="line">    flag+=<span class="built_in">chr</span>(<span class="built_in">ord</span>(enc[i])^i^<span class="number">0</span>)</span><br><span class="line"><span class="built_in">print</span>(flag)</span><br></pre></td></tr></table></figure><p>flag：SYC{W3lc0me_tO_th3_r3veR5e_w0r1d~}</p><h2 id="0x02-点击就送的逆向题"><a href="#0x02-点击就送的逆向题" class="headerlink" title="0x02 点击就送的逆向题"></a>0x02 点击就送的逆向题</h2><p>没什么好说的，Linux.s文件编译，打开虚拟机按照下面步骤手动编译就好了</p><p>gcc -c test.s -o test.o</p><p>gcc test.o -o test</p><p>这里补充一下c语言编译步骤：</p><p>1、预处理                                               </p><p>gcc -E test.c -o test.i</p><p>2、用intel汇编代码来编译</p><p>gcc -s -masm=intel test.i -o test.s</p><p>3、汇编器将汇编代码转化为机器码</p><p>gcc -c test.s -o test.o</p><p>4、链接调用输出</p><p>gcc test.o -o test.out</p><p>之后拖到ida分析编译好的test文件，简单位移加密逆向后可以解出来。</p><h2 id="0x03-AES！！AES？"><a href="#0x03-AES！！AES？" class="headerlink" title="0x03 AES！！AES？"></a>0x03 AES！！AES？</h2><p>简化版的AES加密，没有列混合和生成多个子密钥进行轮密钥加</p><p><a href="https://www.bilibili.com/video/BV1i341187fK/?spm_id_from=333.337.search-card.all.click">【AES加密算法】| AES加密过程详解| 对称加密| Rijndael-128| 密码学| 信息安全_哔哩哔哩_  bilibili  </a>AES算法详细见这个视频）</p><p>照着ida里面的加密步骤逆出解密脚本就好了</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line">S=[<span class="number">0x63</span>, <span class="number">0x7C</span>, <span class="number">0x77</span>, <span class="number">0x7B</span>, <span class="number">0xF2</span>, <span class="number">0x6B</span>, <span class="number">0x6F</span>, <span class="number">0xC5</span>, <span class="number">0x30</span>, <span class="number">0x01</span>, <span class="number">0x67</span>, <span class="number">0x2B</span>, <span class="number">0xFE</span>, <span class="number">0xD7</span>, <span class="number">0xAB</span>,</span><br><span class="line">   <span class="number">0x76</span>, <span class="number">0xCA</span>, <span class="number">0x82</span>, <span class="number">0xC9</span>, <span class="number">0x7D</span>, <span class="number">0xFA</span>, <span class="number">0x59</span>, <span class="number">0x47</span>, <span class="number">0xF0</span>, <span class="number">0xAD</span>, <span class="number">0xD4</span>, <span class="number">0xA2</span>, <span class="number">0xAF</span>, <span class="number">0x9C</span>,</span><br><span class="line">   <span class="number">0xA4</span>, <span class="number">0x72</span>, <span class="number">0xC0</span>, <span class="number">0xB7</span>, <span class="number">0xFD</span>, <span class="number">0x93</span>, <span class="number">0x26</span>, <span class="number">0x36</span>, <span class="number">0x3F</span>, <span class="number">0xF7</span>, <span class="number">0xCC</span>, <span class="number">0x34</span>, <span class="number">0xA5</span>, <span class="number">0xE5</span>,</span><br><span class="line">   <span class="number">0xF1</span>, <span class="number">0x71</span>, <span class="number">0xD8</span>, <span class="number">0x31</span>, <span class="number">0x15</span>, <span class="number">0x04</span>, <span class="number">0xC7</span>, <span class="number">0x23</span>, <span class="number">0xC3</span>, <span class="number">0x18</span>, <span class="number">0x96</span>, <span class="number">0x05</span>, <span class="number">0x9A</span>,<span class="number">0x07</span>, <span class="number">0x12</span>, <span class="number">0x80</span>,</span><br><span class="line">   <span class="number">0xE2</span>, <span class="number">0xEB</span>, <span class="number">0x27</span>, <span class="number">0xB2</span>, <span class="number">0x75</span>, <span class="number">0x09</span>, <span class="number">0x83</span>, <span class="number">0x2C</span>, <span class="number">0x1A</span>, <span class="number">0x1B</span>, <span class="number">0x6E</span>, <span class="number">0x5A</span>, <span class="number">0xA0</span>, <span class="number">0x52</span>, <span class="number">0x3B</span>,</span><br><span class="line">   <span class="number">0xD6</span>, <span class="number">0xB3</span>,<span class="number">0x29</span>, <span class="number">0xE3</span>, <span class="number">0x2F</span>, <span class="number">0x84</span>, <span class="number">0x53</span>, <span class="number">0xD1</span>, <span class="number">0x00</span>, <span class="number">0xED</span>, <span class="number">0x20</span>, <span class="number">0xFC</span>, <span class="number">0xB1</span>, <span class="number">0x5B</span>, <span class="number">0x6A</span>,</span><br><span class="line">   <span class="number">0xCB</span>, <span class="number">0xBE</span>, <span class="number">0x39</span>, <span class="number">0x4A</span>, <span class="number">0x4C</span>, <span class="number">0x58</span>,<span class="number">0xCF</span>, <span class="number">0xD0</span>, <span class="number">0xEF</span>, <span class="number">0xAA</span>, <span class="number">0xFB</span>, <span class="number">0x43</span>, <span class="number">0x4D</span>, <span class="number">0x33</span>,</span><br><span class="line">   <span class="number">0x85</span>, <span class="number">0x45</span>, <span class="number">0xF9</span>, <span class="number">0x02</span>, <span class="number">0x7F</span>, <span class="number">0x50</span>, <span class="number">0x3C</span>, <span class="number">0x9F</span>, <span class="number">0xA8</span>, <span class="number">0x51</span>, <span class="number">0xA3</span>,<span class="number">0x40</span>, <span class="number">0x8F</span>, <span class="number">0x92</span>, <span class="number">0x9D</span>,</span><br><span class="line">   <span class="number">0x38</span>, <span class="number">0xF5</span>, <span class="number">0xBC</span>, <span class="number">0xB6</span>, <span class="number">0xDA</span>, <span class="number">0x21</span>, <span class="number">0x10</span>, <span class="number">0xFF</span>, <span class="number">0xF3</span>, <span class="number">0xD2</span>, <span class="number">0xCD</span>, <span class="number">0x0C</span>, <span class="number">0x13</span>,</span><br><span class="line">   <span class="number">0xEC</span>,<span class="number">0x5F</span>, <span class="number">0x97</span>, <span class="number">0x44</span>, <span class="number">0x17</span>, <span class="number">0xC4</span>, <span class="number">0xA7</span>, <span class="number">0x7E</span>, <span class="number">0x3D</span>, <span class="number">0x64</span>, <span class="number">0x5D</span>, <span class="number">0x19</span>, <span class="number">0x73</span>, <span class="number">0x60</span>, <span class="number">0x81</span>,</span><br><span class="line">   <span class="number">0x4F</span>, <span class="number">0xDC</span>, <span class="number">0x22</span>, <span class="number">0x2A</span>, <span class="number">0x90</span>,<span class="number">0x88</span>, <span class="number">0x46</span>, <span class="number">0xEE</span>, <span class="number">0xB8</span>, <span class="number">0x14</span>, <span class="number">0xDE</span>, <span class="number">0x5E</span>, <span class="number">0x0B</span>, <span class="number">0xDB</span>,</span><br><span class="line">   <span class="number">0xE0</span>, <span class="number">0x32</span>, <span class="number">0x3A</span>, <span class="number">0x0A</span>, <span class="number">0x49</span>, <span class="number">0x6</span>, <span class="number">0x24</span>, <span class="number">0x5C</span>, <span class="number">0xC2</span>, <span class="number">0xD3</span>,<span class="number">0xAC</span>, <span class="number">0x62</span>, <span class="number">0x91</span>, <span class="number">0x95</span>, <span class="number">0xE4</span>,</span><br><span class="line">   <span class="number">0x79</span>, <span class="number">0xE7</span>, <span class="number">0xC8</span>, <span class="number">0x37</span>, <span class="number">0x6D</span>, <span class="number">0x8D</span>, <span class="number">0xD5</span>, <span class="number">0x4E</span>, <span class="number">0xA9</span>, <span class="number">0x6C</span>, <span class="number">0x56</span>, <span class="number">0xF4</span>, <span class="number">0xEA</span>,<span class="number">0x65</span>,</span><br><span class="line">   <span class="number">0x7A</span>, <span class="number">0xAE</span>, <span class="number">0x08</span>, <span class="number">0xBA</span>, <span class="number">0x78</span>, <span class="number">0x25</span>, <span class="number">0x2E</span>, <span class="number">0x1C</span>, <span class="number">0xA6</span>, <span class="number">0xB4</span>, <span class="number">0xC6</span>, <span class="number">0xE8</span>, <span class="number">0xDD</span>, <span class="number">0x74</span>,</span><br><span class="line">   <span class="number">0x1F</span>, <span class="number">0x4B</span>, <span class="number">0xBD</span>, <span class="number">0x8B</span>,<span class="number">0x8A</span>, <span class="number">0x70</span>, <span class="number">0x3E</span>, <span class="number">0xB5</span>, <span class="number">0x66</span>, <span class="number">0x48</span>, <span class="number">0x03</span>, <span class="number">0xF6</span>, <span class="number">0x0E</span>, <span class="number">0x61</span>, <span class="number">0x35</span>,</span><br><span class="line">   <span class="number">0x57</span>, <span class="number">0xB9</span>, <span class="number">0x86</span>, <span class="number">0xC1</span>, <span class="number">0x1D</span>, <span class="number">0x9E</span>, <span class="number">0xE1</span>, <span class="number">0xF8</span>,<span class="number">0x98</span>, <span class="number">0x11</span>, <span class="number">0x69</span>, <span class="number">0xD9</span>, <span class="number">0x8E</span>, <span class="number">0x94</span>,</span><br><span class="line">   <span class="number">0x9B</span>, <span class="number">0x1E</span>, <span class="number">0x87</span>, <span class="number">0xE9</span>, <span class="number">0xCE</span>, <span class="number">0x55</span>, <span class="number">0x28</span>, <span class="number">0xDF</span>, <span class="number">0x8C</span>, <span class="number">0xA1</span>, <span class="number">0x89</span>, <span class="number">0x0D</span>, <span class="number">0xBF</span>,<span class="number">0xE6</span>,</span><br><span class="line">   <span class="number">0x42</span>, <span class="number">0x68</span>, <span class="number">0x41</span>, <span class="number">0x99</span>, <span class="number">0x2D</span>, <span class="number">0x0F</span>, <span class="number">0xB0</span>, <span class="number">0x54</span>, <span class="number">0xBB</span>, <span class="number">0x16</span>]</span><br><span class="line"><span class="comment">#字节代换S表</span></span><br><span class="line">key=[<span class="number">110</span>,<span class="number">121</span>,<span class="number">105</span>,-<span class="number">125</span>,<span class="number">121</span>,</span><br><span class="line">     <span class="number">127</span>,<span class="number">105</span>,<span class="number">117</span>,<span class="number">121</span>,<span class="number">120</span>,</span><br><span class="line">     -<span class="number">127</span>,<span class="number">105</span>,<span class="number">93</span>,<span class="number">99</span>,<span class="number">77</span>,<span class="number">73</span>]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">16</span>):</span><br><span class="line">    key[i]-=<span class="number">10</span></span><br><span class="line">    <span class="keyword">if</span> key[i]&lt;<span class="number">0</span>:</span><br><span class="line">        key[i]+=<span class="number">256</span></span><br><span class="line">    key[i] = key[i] &amp; <span class="number">0xff</span></span><br><span class="line"><span class="comment">#密钥：do_you_konw_SYC?</span></span><br><span class="line">key1=[]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">16</span>):</span><br><span class="line">    key1.append(key[i] ^ S[key[i]] &amp; <span class="number">0xff</span>)</span><br><span class="line"><span class="comment">#密钥扩展</span></span><br><span class="line">enc=[<span class="number">0xe0</span>,<span class="number">0x05</span>,<span class="number">0x6e</span>,<span class="number">0xc2</span>,<span class="number">0x6e</span>,</span><br><span class="line">     <span class="number">0x99</span>,<span class="number">0x68</span>,<span class="number">0x45</span>,<span class="number">0x7d</span>,<span class="number">0x1f</span>,</span><br><span class="line">     <span class="number">0x3f</span>,<span class="number">0xf9</span>,<span class="number">0x97</span>,<span class="number">0x76</span>,<span class="number">0x3b</span>,</span><br><span class="line">     <span class="number">0x92</span>,<span class="number">0x2f</span>,<span class="number">0x44</span>,<span class="number">0x06</span>,<span class="number">0x67</span>,</span><br><span class="line">     <span class="number">0xa8</span>,<span class="number">0xeb</span>,<span class="number">0xec</span>,<span class="number">0x4a</span>,<span class="number">0x6f</span>,</span><br><span class="line">     <span class="number">0xe8</span>,<span class="number">0x35</span>,<span class="number">0xf9</span>,<span class="number">0xac</span>,<span class="number">0xa7</span>,</span><br><span class="line">     <span class="number">0x8c</span>,<span class="number">0x71</span>]</span><br><span class="line"><span class="comment">#逆向行位移</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">re_shiftrow</span>(<span class="params">flag</span>):<span class="comment">#右移动</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="number">4</span>):</span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(i):</span><br><span class="line">            <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>):</span><br><span class="line">                flag[<span class="number">4</span> * i + <span class="number">3</span> - k], flag[<span class="number">4</span> * i + <span class="number">3</span> - k - <span class="number">1</span>] = flag[<span class="number">4</span> * i + <span class="number">3</span> - k - <span class="number">1</span>], flag[<span class="number">4</span> * i + <span class="number">3</span> - k]</span><br><span class="line">                flag[<span class="number">16</span>+<span class="number">4</span> * i + <span class="number">3</span> - k], flag[<span class="number">16</span>+<span class="number">4</span> * i + <span class="number">3</span> - k - <span class="number">1</span>] = flag[<span class="number">16</span>+<span class="number">4</span> * i + <span class="number">3</span> - k - <span class="number">1</span>], flag[<span class="number">16</span>+<span class="number">4</span> * i + <span class="number">3</span> - k]</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">re_tansform</span>(<span class="params">flag</span>):</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">32</span>):</span><br><span class="line">        flag[i] = S.index(flag[i])</span><br><span class="line">    v = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> flag:</span><br><span class="line">        v.append(i)</span><br><span class="line">    n = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">4</span>):</span><br><span class="line">        <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">4</span>):</span><br><span class="line">            flag[n] = v[<span class="number">4</span> * k + j]</span><br><span class="line">            flag[n + <span class="number">16</span>] = v[<span class="number">16</span> + <span class="number">4</span> * k + j]</span><br><span class="line">            n += <span class="number">1</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">byte_xor</span>(<span class="params">flag,key</span>):</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">32</span>):</span><br><span class="line">        flag[i] ^= key[i % <span class="number">0x10</span>]</span><br><span class="line"><span class="comment">#异或密钥</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">byte_trans</span>(<span class="params">flag</span>):</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">32</span>):</span><br><span class="line">        flag[i] = S.index(flag[i])</span><br><span class="line"><span class="comment">#字节代换</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">#下面是主函数</span></span><br><span class="line">byte_xor(enc,key1)</span><br><span class="line">re_shiftrow(enc)</span><br><span class="line">byte_trans(enc)</span><br><span class="line">byte_xor(enc,key)</span><br><span class="line">re_tansform(enc)</span><br><span class="line">re_shiftrow(enc)</span><br><span class="line">byte_trans(enc)</span><br><span class="line">flag=<span class="string">&#x27;&#x27;</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">32</span>):</span><br><span class="line">    <span class="keyword">if</span> i==<span class="number">5</span>:</span><br><span class="line">        enc[i]=<span class="number">46</span></span><br><span class="line">    <span class="keyword">if</span> i==<span class="number">10</span>:</span><br><span class="line">        enc[i]=<span class="number">108</span></span><br><span class="line">    <span class="keyword">if</span> i==<span class="number">17</span>:</span><br><span class="line">        enc[i]=<span class="number">48</span></span><br><span class="line">    flag += <span class="built_in">chr</span>(enc[i])</span><br><span class="line"><span class="built_in">print</span>(flag)</span><br></pre></td></tr></table></figure><p>（s表是手打的，当时不知道ida能快捷键Shift+E提取文本数据）</p><p>SYC{0.o_Thls_1s_n0t_A3s_(q^_^p)}</p><h2 id="0x04-miku"><a href="#0x04-miku" class="headerlink" title="0x04 miku"></a>0x04 miku</h2><p>这是一道golang逆向题，评价是完全看不懂，发现main函数里有一个叫rc4加密的函数，盲猜是rc4加密。传入的key通过静态分析很难找，直接Linux远程动调，运行程序后有一个输入初音未来色，经过百度查找是39c5bb，正确输入后经过动态调试发现生成了正确的key 0x43，手搓一个rc4对称解密脚本直接逆出flag</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#rc4对称加密流程</span></span><br><span class="line"></span><br><span class="line">enc=[<span class="number">0x25</span>,<span class="number">0x6f</span>,<span class="number">0x3d</span>,<span class="number">0x6c</span>,<span class="number">0xf9</span>,<span class="number">0xe0</span>,<span class="number">0xcf</span>,<span class="number">0x3f</span>,</span><br><span class="line">     <span class="number">0x2e</span>,<span class="number">0x24</span>,<span class="number">0xc6</span>,<span class="number">0x7b</span>,<span class="number">0x81</span>,<span class="number">0xbf</span>,<span class="number">0x55</span>,<span class="number">0x4f</span>,</span><br><span class="line">     <span class="number">0x0d</span>,<span class="number">0x99</span>,<span class="number">0x87</span>,<span class="number">0x47</span>,<span class="number">0x48</span>,<span class="number">0xf7</span>,<span class="number">0xb9</span>,<span class="number">0x98</span>,</span><br><span class="line">     <span class="number">0xfb</span>,<span class="number">0x1b</span>,<span class="number">0x22</span>,<span class="number">0xec</span>,<span class="number">0x84</span>,<span class="number">0x23</span>,<span class="number">0xfd</span>,<span class="number">0xb2</span>]</span><br><span class="line"><span class="comment">#key长度为18</span></span><br><span class="line"><span class="comment">#flag长度为32</span></span><br><span class="line">key=[<span class="number">0x43</span>]</span><br><span class="line"><span class="comment">#填充一个s_box,0到255</span></span><br><span class="line"><span class="comment">#key表待定</span></span><br><span class="line">s=[]</span><br><span class="line">k=[]</span><br><span class="line">xor=[<span class="number">0</span>]*<span class="number">32</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">256</span>):</span><br><span class="line">     s.append(i)</span><br><span class="line">     k.append(key[i%<span class="number">1</span>])</span><br><span class="line"><span class="comment">#初始化s_box</span></span><br><span class="line">j=<span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">256</span>):</span><br><span class="line">     j=(j+s[i]+k[i])%<span class="number">256</span></span><br><span class="line"></span><br><span class="line">     temp=s[i]</span><br><span class="line">     s[i]=s[j]</span><br><span class="line">     s[j]=temp</span><br><span class="line">i=<span class="number">0</span></span><br><span class="line">j=<span class="number">0</span></span><br><span class="line">t=<span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">32</span>):</span><br><span class="line">     i=(i+<span class="number">1</span>)%<span class="number">256</span></span><br><span class="line">     j=(j+s[i])%<span class="number">256</span></span><br><span class="line"></span><br><span class="line">     temp = s[i]</span><br><span class="line">     s[i] = s[j]</span><br><span class="line">     s[j] = temp</span><br><span class="line"></span><br><span class="line">     t=(s[i]+s[j])%<span class="number">256</span></span><br><span class="line">     xor[k]=s[t]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">flag=<span class="string">&#x27;&#x27;</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">32</span>):</span><br><span class="line">     flag+=<span class="built_in">chr</span>(xor[i]^enc[i])</span><br><span class="line"><span class="built_in">print</span>(flag)</span><br></pre></td></tr></table></figure><p>SYC{N0thing_1s_sEriOus_But_MIku}</p><h2 id="0x05-幸运数字"><a href="#0x05-幸运数字" class="headerlink" title="0x05 幸运数字"></a>0x05 幸运数字</h2><p>感觉没啥好说的，题目说0到999有存在幸运数字，经过分析只要找出任意一个luck丢进逆向脚本就能出flag，由于幸运数字的范围小，直接爆破出来就好了</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#前n项求和公式</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">result</span>(<span class="params">key</span>):</span><br><span class="line">    <span class="keyword">if</span> key!=<span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> result(key-<span class="number">1</span>)+key</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">enc=[<span class="number">0x0d</span>,<span class="number">7</span>,<span class="number">0x1d</span>,<span class="number">0x25</span>,<span class="number">0x1d</span>,<span class="number">0x6e</span>,<span class="number">0x30</span>,<span class="number">0x39</span>,<span class="number">0x2c</span>,<span class="number">0x3f</span>,<span class="number">0x2a</span>,</span><br><span class="line">     <span class="number">0x2b</span>,<span class="number">0x32</span>,<span class="number">0x3f</span>,<span class="number">0x2a</span>,<span class="number">0x37</span>,<span class="number">0x6e</span>,<span class="number">0x30</span>,<span class="number">0x30</span>,<span class="number">0x30</span>,<span class="number">0x30</span>,<span class="number">0x2d</span>,</span><br><span class="line">     <span class="number">1</span>,<span class="number">7</span>,<span class="number">0x31</span>,<span class="number">0x2b</span>,<span class="number">1</span>,<span class="number">0x39</span>,<span class="number">0x1f</span>,<span class="number">0x3b</span>,<span class="number">0x2d</span>,<span class="number">0x2d</span>,<span class="number">0x1b</span>,<span class="number">0x3a</span>,<span class="number">1</span>,</span><br><span class="line">     <span class="number">0x0c</span>,<span class="number">0x6f</span>,<span class="number">0x39</span>,<span class="number">0x36</span>,<span class="number">0x2a</span>,<span class="number">0x23</span>]</span><br><span class="line">key=[]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">999</span>):</span><br><span class="line">    <span class="keyword">if</span> result(i)%<span class="number">0xd3</span>==<span class="number">94</span>:</span><br><span class="line">        key.append(i)</span><br><span class="line"><span class="keyword">for</span> j <span class="keyword">in</span> key:</span><br><span class="line">    flag=<span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">41</span>):</span><br><span class="line">        v4=enc[i]</span><br><span class="line">        v5=result(j)</span><br><span class="line">        flag+=<span class="built_in">chr</span>(v4^(v5%<span class="number">0xd3</span>))</span><br><span class="line">    <span class="built_in">print</span>(flag)</span><br></pre></td></tr></table></figure><p>SYC{C0ngratulati0nnnns_You_gAessEd_R1ght}</p><h2 id="0x06-黄鸭"><a href="#0x06-黄鸭" class="headerlink" title="0x06 黄鸭"></a>0x06 黄鸭</h2><p>丢进die发现是PyInstaller封装的exe，py逆向，用pyinstxtractor 进行反编译</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python pyinstxtractor.py test.exe</span><br></pre></td></tr></table></figure><p><a href="https://github.com/extremecoders-re/pyinstxtractor">pyinstxtractor脚本主页</a></p><p>之后根据python的版本更改关键pyc文件的魔术头（PyObject_HEAD）魔术头的版本号可以通过查看struct文件了解。（不知道为什么我的pyin……弄出来后的pyc魔术头总是对不上号，这时可以用010editor去更改）</p><p><img src="Images/004bd73cd7694932bb6ce9353711dfd7.png" alt="004bd73cd7694932bb6ce9353711dfd7"></p><p>转自独奏の小屋</p><p>在线网站可以反编译pyc，<a href="https://tool.lu/pyc/">python反编译 - 在线工具 (tool.lu)</a></p><p>uncompyle也可以，详情见<a href="https://github.com/rocky/python-uncompyle6">uncompyle6</a></p><p><img src="Images/55efa10608db44838bb1f6968d1cf0b5-1706530201413-9.png" alt="55efa10608db44838bb1f6968d1cf0b5">找到关键的加密代码，看不懂是什么语法。。但也可以猜出来是一个向右移动13位的凯撒加密了，之后再将其他细节补全，逆出解密脚本</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">enc = <span class="string">&#x27;~h|p4gs`gJdN`thPwR`jDn`te1w`2|RNH&#x27;</span></span><br><span class="line">enc = enc[::-<span class="number">1</span>]</span><br><span class="line">flag = <span class="string">&#x27;&#x27;</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> enc:</span><br><span class="line">    <span class="keyword">if</span> i&gt;=<span class="string">&#x27;a&#x27;</span> <span class="keyword">and</span> i&lt;=<span class="string">&#x27;z&#x27;</span>:</span><br><span class="line">        i = <span class="built_in">chr</span>(<span class="built_in">ord</span>(i) - <span class="number">2</span>)</span><br><span class="line">        i = <span class="built_in">chr</span>(<span class="built_in">ord</span>(i)-<span class="number">13</span>)</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">ord</span>(i) &lt; <span class="number">97</span>:</span><br><span class="line">            i = <span class="built_in">chr</span>(<span class="built_in">ord</span>(i)+<span class="number">26</span>)</span><br><span class="line">        flag += i</span><br><span class="line">    <span class="keyword">elif</span> i&gt;=<span class="string">&#x27;A&#x27;</span> <span class="keyword">and</span> i&lt;=<span class="string">&#x27;Z&#x27;</span>:</span><br><span class="line">        i = <span class="built_in">chr</span>(<span class="built_in">ord</span>(i) - <span class="number">2</span>)</span><br><span class="line">        i=<span class="built_in">chr</span>(<span class="built_in">ord</span>(i)-<span class="number">13</span>)</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">ord</span>(i) &lt; <span class="number">65</span>:</span><br><span class="line">            i = <span class="built_in">chr</span>(<span class="built_in">ord</span>(i)+<span class="number">26</span>)</span><br><span class="line">        flag += i</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        flag += <span class="built_in">chr</span>(<span class="built_in">ord</span>(i)-<span class="number">1</span>)</span><br><span class="line"><span class="comment">#手动将倒数第三个的 &#x27;&#125;&#x27; 替换成 &#x27;m&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(flag)</span><br></pre></td></tr></table></figure><p>SYC{1_h0pe_yOu_ChAse_YoUr_dr3ams}</p><h2 id="0x07-砍树"><a href="#0x07-砍树" class="headerlink" title="0x07 砍树"></a>0x07 砍树</h2><p>砍树是一道安卓逆向题，但本质感觉还是ida。考察了apk文件的本质是一个压缩包，将.apk改成.zip后解压就能发现里面的函数library，找到一个像颜文字一样的函数。这个函数在jadx静态分析界面里面是找不到的，是调用了某个外部库，然后是此题的关键加密函数。</p><p>找到这个函数后，拖到ida里面分析出来是个什么玩意，找到key=“Sycloverforerver”，逆出解密脚本</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">enc=[<span class="number">0</span>,<span class="number">0x20</span>,<span class="number">0x20</span>,<span class="number">0x17</span>,<span class="number">0x1b</span>,<span class="number">0x36</span>,<span class="number">0x0e</span>,<span class="number">0x36</span>,<span class="number">0x26</span>,</span><br><span class="line">      <span class="number">0x17</span>,<span class="number">4</span>,<span class="number">0x2a</span>,<span class="number">0x29</span>,<span class="number">7</span>,<span class="number">0x26</span>,<span class="number">0x15</span>,<span class="number">0x52</span>,<span class="number">0x33</span>,<span class="number">0x2d</span>,</span><br><span class="line">      <span class="number">0x0f</span>,<span class="number">0x3a</span>,<span class="number">0x27</span>,<span class="number">0x11</span>,<span class="number">6</span>,<span class="number">0x33</span>,<span class="number">7</span>,<span class="number">0x46</span>,<span class="number">0x17</span>,<span class="number">0x3d</span>,</span><br><span class="line">      <span class="number">0x0a</span>,<span class="number">0x3c</span>,<span class="number">0x38</span>,<span class="number">0x2e</span>,<span class="number">0x22</span>,<span class="number">0x18</span>]</span><br><span class="line">flag=<span class="string">&quot;&quot;</span></span><br><span class="line">key=<span class="string">&quot;Sycloverforerver&quot;</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">35</span>):</span><br><span class="line">    flag+=<span class="built_in">chr</span>(<span class="built_in">ord</span>(key[i%<span class="number">7</span>])^enc[i])</span><br><span class="line"><span class="built_in">print</span>(flag)</span><br></pre></td></tr></table></figure><p>SYC{t@ke_thE_bul1_By_the_h0rns_TAT}</p><h2 id="0x08-扎针游戏"><a href="#0x08-扎针游戏" class="headerlink" title="0x08 扎针游戏"></a>0x08 扎针游戏</h2><p>此题是一个unity引擎的游戏，源自见缝插针。游戏引导玩家去扎30根针，可是扎完后发现还要再扎到40根。受不了这鸟气，在附带文件里面找到Assemble-Csharp.dll，丢进c#反汇编工具ILspy里面查看，查找相关字符串就可以定位到关键代码了，一个游戏流程控制代码，这里经过分析后会检测你鼠标点击的次数和扎针扎的分数，要达到100分。但是看不出解密方法。</p><p>问过大佬1k0ct后，他说用CE可以来修改score，改到100分。直接炫了一个Cheat Engine，找了一下修改方法将分数改到100，发现解出了错误flag。</p><p>后面分析发现前30次每次扎完针都会通过异或加密刷新一次密文，之后在score达到100时在游戏左上角显示出来。</p><p>之后手动扎30次针，再将score改到100，就出现了正确的flag。</p><h2 id="0x09-rainbow"><a href="#0x09-rainbow" class="headerlink" title="0x09 rainbow"></a>0x09 rainbow</h2><p>控制流平坦化，在ida里面导入了一个D-810的插件，可以将消去控制流平坦化，什么是控制流平坦化呢？？？？<a href="https://security.tencent.com/index.php/blog/msg/112">利用符号执行去除控制流平坦化 - 博客 - 腾讯安全应急响应中心 </a></p><p>自己看看吧，我也不知道。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">enc = [<span class="number">0x65</span>,<span class="number">0x58</span>,<span class="number">0x41</span>,<span class="number">0x8e</span>,<span class="number">0x50</span>,<span class="number">0x44</span>,<span class="number">0x7b</span>,<span class="number">0x62</span>,</span><br><span class="line">       <span class="number">0x57</span>,<span class="number">0x4a</span>,<span class="number">0x7e</span>,<span class="number">0x54</span>,<span class="number">0x49</span>,<span class="number">0x6c</span>,<span class="number">0x7d</span>,<span class="number">0x84</span>,</span><br><span class="line">       <span class="number">0x4f</span>,<span class="number">0x5b</span>,<span class="number">0x95</span>,<span class="number">0x60</span>,<span class="number">0x60</span>,<span class="number">0x64</span>,<span class="number">0x77</span>,<span class="number">0x48</span>,</span><br><span class="line">       <span class="number">0x7d</span>,<span class="number">0x4d</span>,<span class="number">0x7b</span>,<span class="number">0x9f</span>,<span class="number">0x68</span>,<span class="number">0x3c</span>,<span class="number">0x2d</span>,<span class="number">0x62</span>]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">32</span>):</span><br><span class="line">    enc[i] ^= i</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">32</span>):</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> i%<span class="number">3</span>:</span><br><span class="line">        enc[i] -= <span class="number">18</span></span><br><span class="line">flag = <span class="string">&quot;&quot;</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">32</span>):</span><br><span class="line">    flag += <span class="built_in">chr</span>(enc[i])</span><br><span class="line"><span class="built_in">print</span>(flag)</span><br></pre></td></tr></table></figure><p>SYC{TAke_1t_3asy_Just_a_STart!!}</p><h2 id="0x0A-TEA"><a href="#0x0A-TEA" class="headerlink" title="0x0A TEA"></a>0x0A TEA</h2><p>这是一道安卓逆向TEA，flag根据下标的奇数和偶数被分为两部分，偶数部分经过一次变种TEA加密后得到密文enc，奇数部分与enc异或得到密文enc1。</p><p>除了变种TEA外，本题的字符存储为int32位数据是是大端序存储的，注意这两点关键后就可以解出题目了（jadx里面的密文enc1被putExtra了，需要查找一个getExtra函数找到获取这个密文的代码文件，跳转过去后就能看到上面所说的enc1和异或加密操作了）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">enc2=[-<span class="number">107</span>, -<span class="number">106</span>, -<span class="number">95</span>, -<span class="number">115</span>, -<span class="number">119</span>, <span class="number">127</span>, <span class="number">26</span>, <span class="number">121</span>, -<span class="number">62</span>, -<span class="number">20</span>, <span class="number">86</span>, <span class="number">9</span>]<span class="comment">#奇数部分的密文</span></span><br><span class="line">enc=[-<span class="number">91</span>, -<span class="number">8</span>, -<span class="number">110</span>, -<span class="number">55</span>, -<span class="number">49</span>, <span class="number">75</span>, <span class="number">115</span>, <span class="number">13</span>, -<span class="number">76</span>, -<span class="number">113</span>, <span class="number">102</span>, <span class="number">80</span>]<span class="comment">#偶数部分经过TEA后的密文</span></span><br><span class="line">e=[]</span><br><span class="line"><span class="comment">#两者异或之后得到奇数部分的明文</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">12</span>):</span><br><span class="line">    enc2[i] &amp;= <span class="number">0xff</span></span><br><span class="line">    e.append(enc[i]^enc2[i])</span><br><span class="line">arr=[]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">12</span>):</span><br><span class="line">    <span class="keyword">if</span> enc[i]&lt;<span class="number">0</span>:</span><br><span class="line">        enc[i]+=<span class="number">256</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,<span class="number">12</span>,<span class="number">4</span>):</span><br><span class="line">    arr.append((enc[i]&lt;&lt;<span class="number">24</span>)|(enc[i+<span class="number">1</span>]&lt;&lt;<span class="number">16</span>)|(enc[i+<span class="number">2</span>]&lt;&lt;<span class="number">8</span>)|(enc[i+<span class="number">3</span>]))</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">hex</span>(arr[i]))</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> e:</span><br><span class="line">    <span class="keyword">if</span> i&lt;<span class="number">0</span>:</span><br><span class="line">        i+=<span class="number">256</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">chr</span>(i),end=<span class="string">&#x27;&#x27;</span>)</span><br></pre></td></tr></table></figure><p>得到密文enc的大端序存储数</p><p>0xa5f892c9<br>0xcf4b730d<br>0xb48f6650</p><p>这个是明文的奇数部分<br>0n3DF4itvc0Y</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> arr[<span class="number">3</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> byte[<span class="number">12</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> k0 = <span class="number">2023708229</span>, k1= <span class="number">-158607964</span>, k2= <span class="number">-2120859654</span>, k3 = <span class="number">1167043672</span>;</span><br><span class="line"><span class="comment">//密钥</span></span><br><span class="line"><span class="type">int</span> i;</span><br><span class="line"><span class="type">int</span> delta = <span class="number">1640531527</span>;</span><br><span class="line"><span class="type">int</span> i10= <span class="number">0xa5f892c9</span>, i11= <span class="number">0xb48f6650</span>, i12= <span class="number">0xcf4b730d</span>;</span><br><span class="line"><span class="type">int</span> sum = <span class="number">-64</span>*delta ;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">32</span>; i++) &#123;</span><br><span class="line">i11 -= (((i12 &lt;&lt; <span class="number">4</span>) + k2) ^ (i12 + sum)) ^ ((i12 &gt;&gt; <span class="number">5</span>) + k3);</span><br><span class="line">i12 -= (((i11 &lt;&lt; <span class="number">4</span>) + k0) ^ (i11 + sum)) ^ ((i11 &gt;&gt; <span class="number">5</span>) + k1);</span><br><span class="line">sum += delta;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">32</span>; i++) &#123;</span><br><span class="line">i11 -= (((i10 &lt;&lt; <span class="number">4</span>) + k2) ^ (i10 + sum)) ^ ((i10 &gt;&gt; <span class="number">5</span>) + k3);</span><br><span class="line">i10 -= (((i11 &lt;&lt; <span class="number">4</span>) + k0) ^ (i11 + sum)) ^ ((i11 &gt;&gt; <span class="number">5</span>) + k1);</span><br><span class="line">sum += delta ;</span><br><span class="line">&#125;</span><br><span class="line">arr[<span class="number">0</span>] = i10;</span><br><span class="line">arr[<span class="number">1</span>] = i11;</span><br><span class="line">arr[<span class="number">2</span>] = i12;</span><br><span class="line"><span class="type">int</span> i4 = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">12</span>; i += <span class="number">4</span>) &#123;</span><br><span class="line">byte[i] = (arr[i4] &gt;&gt; <span class="number">24</span>)&amp;<span class="number">0xff</span>;</span><br><span class="line">byte[i + <span class="number">1</span>] = (arr[i4] &gt;&gt; <span class="number">16</span>) &amp; <span class="number">0xff</span>;</span><br><span class="line">byte[i + <span class="number">2</span>] = (arr[i4] &gt;&gt; <span class="number">8</span>) &amp; <span class="number">0xff</span>;</span><br><span class="line">byte[i + <span class="number">3</span>] = (arr[i4]) &amp; <span class="number">0xff</span>;</span><br><span class="line">i4++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">const</span> <span class="type">char</span> *n =  <span class="string">&quot;0n3DF4itvc0Y&quot;</span> ;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;SYC&#123;&quot;</span>);</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">12</span>; i++) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, n[i]);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, byte[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;&#125;&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure><p>将上述密文enc和奇数部分明文输入脚本，再将密钥key啥的弄好，包裹一下SYC输出就好了</p><p>这里提一嘴int类型和unsigned int类型（简称uint），在做题时我把密文enc的数据类型设为了uint，导致后面输出的结果是错的后面查资料才发现，int类型和uint在按位运算时，前者是算术位移，后置是逻辑位移，举个例子：char a=1111 1111，&gt;&gt;2后是1111 1111，符号位不变</p><p>而uchar 1111 1111 ，&gt;&gt;2后是0011 1111，没有符号位，两者是有区别的，会影响到十六进制数的大小。</p><p>SYC{0Tn03VDtF343iTtnv0ci0tYr}</p><h2 id="0x0B-easymath"><a href="#0x0B-easymath" class="headerlink" title="0x0B easymath"></a>0x0B easymath</h2><p>看起来就像是一个平平无奇的阅读ida代码然后写脚本的题，但是好难逆啊，结合提示整了一个z3库来约束一下条件，正向爆破出flag。</p><p>下载一个z3的库</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install z3-solver</span><br></pre></td></tr></table></figure><p>下载完后我打开pycharm然后发现 怎么都用不了，没办法，只能搞一个vscode来写</p><p><a href="https://zhuanlan.zhihu.com/p/646649819">如何用vscode配置C语言环境？ - 知乎 (zhihu.com)</a>（这里放一个无关紧要的相关文章）</p><p>vscode写蟒蛇只要选个解释器就好了非常的简单。</p><p><img src="Images/082fdef6113444c8bb0faa58ccae7f41.png" alt="082fdef6113444c8bb0faa58ccae7f41"></p><p>ida里红色框框出的是核心的代码，需要爆破的关键。就是一个矩阵的乘法加法啥的，不用管当普通的加法乘法来算就好了。目的是求出last</p><p><img src="C:/Users/28382/Desktop/26e619187dde4933a0f0d20efcb53ebf.png" alt="26e619187dde4933a0f0d20efcb53ebf"></p><p>这里有几个给定的值， 把这些提前约束好，应该是防止爆破出多解的。</p><p><img src="Images/6ec0376b9364473290b5d7469d53cf45.png" alt="6ec0376b9364473290b5d7469d53cf45"></p><p>这几个函数大概的逻辑就是在flag的每一个字符，在table里面找到对应的值，并取下标然后储存到position里面，接着再用这个下标在number里面取值存到last里面，这几个步骤都是很好逆向的，所以只要求出last就好了。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> z3 <span class="keyword">import</span>*</span><br><span class="line"><span class="comment">#定义一个last列表[x1,x2,x3......x24]</span></span><br><span class="line">table=<span class="string">&quot;01234_asdzxcpoityumnbAOZWXGMY&quot;</span></span><br><span class="line">matrix=[<span class="number">18</span>,<span class="number">29</span>,<span class="number">16</span>,<span class="number">19</span>,<span class="number">27</span>,</span><br><span class="line">        <span class="number">8</span>,<span class="number">31</span>,<span class="number">8</span>,<span class="number">23</span>,<span class="number">30</span>,</span><br><span class="line">        <span class="number">29</span>,<span class="number">3</span>,<span class="number">28</span>,<span class="number">10</span>,<span class="number">21</span>,</span><br><span class="line">        <span class="number">18</span>,<span class="number">29</span>,<span class="number">8</span>,<span class="number">16</span>,<span class="number">28</span>,</span><br><span class="line">        <span class="number">11</span>,<span class="number">30</span>,<span class="number">7</span>,<span class="number">20</span>,<span class="number">7</span>]</span><br><span class="line">num=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>,</span><br><span class="line">     <span class="number">11</span>,<span class="number">12</span>,<span class="number">13</span>,<span class="number">14</span>,<span class="number">16</span>,<span class="number">19</span>,</span><br><span class="line">     <span class="number">22</span>,<span class="number">26</span>,<span class="number">27</span>,<span class="number">28</span>,<span class="number">29</span>,<span class="number">31</span>,<span class="number">32</span>,</span><br><span class="line">     <span class="number">50</span>,<span class="number">51</span>,<span class="number">52</span>,<span class="number">53</span>,<span class="number">54</span>,<span class="number">55</span>,<span class="number">56</span>]</span><br><span class="line"><span class="comment">#约束限制条件</span></span><br><span class="line">flander_e=[<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,</span><br><span class="line">           <span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,</span><br><span class="line">           <span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,</span><br><span class="line">           <span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,</span><br><span class="line">           <span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>):</span><br><span class="line">    s=Solver()</span><br><span class="line">    last=IntVector(<span class="string">&#x27;last&#x27;</span>,<span class="number">5</span>)</span><br><span class="line">    <span class="keyword">if</span> i==<span class="number">0</span>:</span><br><span class="line">        s.add(last[<span class="number">1</span>]==<span class="number">19</span>)</span><br><span class="line">    <span class="keyword">if</span> i==<span class="number">1</span>:</span><br><span class="line">        s.add(last[<span class="number">2</span>]==<span class="number">22</span>)</span><br><span class="line">    <span class="keyword">if</span> i==<span class="number">3</span>:</span><br><span class="line">        s.add(last[<span class="number">2</span>]==<span class="number">22</span>)</span><br><span class="line">    <span class="comment">#分个组</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">#for j in range(5):</span></span><br><span class="line">        <span class="comment">#s.add(Or([last[j]==i for i in num]))</span></span><br><span class="line">    s.add(And([Or([last[j]==i <span class="keyword">for</span> i <span class="keyword">in</span> num])<span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>)]))</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>):</span><br><span class="line">        flander=IntVal(<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>):</span><br><span class="line">            flander=(flander+last[k]*matrix[<span class="number">5</span>*k+j])%<span class="number">0x20</span></span><br><span class="line">            <span class="comment">#%0x20和&amp;0x1f等价的，但是这里的变量是int，不能按位运算</span></span><br><span class="line">        s.add(flander==flander_e[<span class="number">5</span>*i+j])</span><br><span class="line">    result=s.check()</span><br><span class="line">    <span class="keyword">if</span> result == sat:</span><br><span class="line">        m=s.model()</span><br><span class="line">        values=[m[last[w]].as_long() <span class="keyword">for</span> w <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>)]</span><br><span class="line">        <span class="keyword">for</span> each <span class="keyword">in</span> values:</span><br><span class="line">            <span class="built_in">print</span>(table[num.index(each)],end=<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;no solution&quot;</span>)</span><br></pre></td></tr></table></figure><p>记得是之前听1k0ct说一次性爆出last会很慢很慢，我之后就改成了一次出last一行</p><p>i用来取行的序号，然后这里last的19,22,什么的是根据他给的t，y正推出来的，就根据那几个函数的步骤手动推出last 的已知解。然后就是不知道是什么的语法，这些查文档就好了吧（心虚）</p><p>flag已忘，望周知</p>]]></content>
      
      
      <categories>
          
          <category> Re-wp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基础 </tag>
            
            <tag> 逆向 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>nbctf</title>
      <link href="/2024/01/29/nbctf/"/>
      <url>/2024/01/29/nbctf/</url>
      
        <content type="html"><![CDATA[<h2 id="0x01-py逆向"><a href="#0x01-py逆向" class="headerlink" title="0x01 py逆向"></a>0x01 py逆向</h2><p>给了一个main.py和out.txt 的文件，打开分析一下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line"> </span><br><span class="line">key1 = random.choices(<span class="built_in">range</span>(<span class="number">256</span>), k=<span class="number">20</span>)  <span class="comment">#0到255里取20个随机数</span></span><br><span class="line">key2 = <span class="built_in">list</span>(<span class="built_in">range</span>(<span class="number">256</span>))  <span class="comment">#0到255的列表</span></span><br><span class="line">random.shuffle(key2) <span class="comment">#随机排列</span></span><br><span class="line">flag = <span class="built_in">open</span>(<span class="string">&#x27;flag.txt&#x27;</span>, <span class="string">&#x27;rb&#x27;</span>).read()    <span class="comment">#读取flag，设置成input</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">enc</span>(<span class="params">n</span>): <span class="comment">#加密函数</span></span><br><span class="line">    q = key2[n]</span><br><span class="line">    w = key1[q % <span class="number">20</span>]</span><br><span class="line">    n ^= q</span><br><span class="line">    <span class="keyword">return</span> n, w</span><br><span class="line"> </span><br><span class="line">x = <span class="number">0x00000000</span></span><br><span class="line"><span class="keyword">for</span> i, c <span class="keyword">in</span> <span class="built_in">enumerate</span>(flag):  <span class="comment">#枚举遍历，第一个是下标，第二个是里面的东西</span></span><br><span class="line">    x &lt;&lt;= <span class="number">8</span>  <span class="comment">#x左移动8位，一个字节</span></span><br><span class="line">    n, w = enc(c)  <span class="comment">#根据密钥和flag出两个数</span></span><br><span class="line">    <span class="keyword">if</span> i % <span class="number">2</span>:   <span class="comment">#如果是奇数下标，swap交换</span></span><br><span class="line">        n, w = w, n</span><br><span class="line">    x |= n</span><br><span class="line">    x |= (w &lt;&lt; ((<span class="number">2</span> * i + <span class="number">1</span>) * <span class="number">8</span>) ) <span class="comment">#按位运算的优先级高于赋值运算</span></span><br><span class="line"> </span><br><span class="line"><span class="built_in">print</span>(key1)</span><br><span class="line"><span class="built_in">print</span>(key2)</span><br><span class="line"><span class="built_in">print</span>(x)</span><br></pre></td></tr></table></figure><p>然后手动调试一下前几项，很容易发现x 的组成是由w和n交替排列的，大概的规律就是</p><pre><code>         w34n33......w2n1w0n0w1n2......w33n34</code></pre><p>根据output文件里的x的值，转码成十六进制</p><p>(0x)ea0149929a24de3a6ab642ebeaa16a02571f572449b67f1f57c4a4b67fc542027feb6a0eeaab4d9c42ab6a3e5124deab6a045724de244db69a16ea016ab6571f57a1a2fe4290</p><p>总共有70个字符，flag推算出是35位</p><p>根据这坨玩意写个抽象的脚本分离出w和n</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">enc=<span class="string">&quot;ea0149929a24de3a6ab642ebeaa16a02571f572449b67f1f57c4a4b67fc542027feb6a0eeaab4d9c42ab6a3e5124deab6a045724de244db69a16ea016ab6571f57a1a2fe4290&quot;</span></span><br><span class="line">enc_l=[]</span><br><span class="line">enc_r=[]</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">len</span>(enc))</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,<span class="number">70</span>):</span><br><span class="line">    enc_l.append(enc[i])</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">70</span>,<span class="number">140</span>):</span><br><span class="line">    enc_r.append(enc[i])</span><br><span class="line">n_o=[<span class="number">0xea</span>,<span class="number">0x49</span>,<span class="number">0x9a</span>,<span class="number">0xde</span>,<span class="number">0x6a</span>,<span class="number">0x42</span>,<span class="number">0xea</span>,<span class="number">0x6a</span>,<span class="number">0x57</span>,<span class="number">0x57</span>,<span class="number">0x49</span>,<span class="number">0x7f</span>,<span class="number">0x57</span>,<span class="number">0xa4</span>,<span class="number">0x7f</span>,<span class="number">0x42</span>,<span class="number">0x7f</span>,<span class="number">0x6a</span>]</span><br><span class="line">n_j=[<span class="number">0xea</span>,<span class="number">0x4d</span>,<span class="number">0x42</span>,<span class="number">0x6a</span>,<span class="number">0x51</span>,<span class="number">0xde</span>,<span class="number">0x6a</span>,<span class="number">0x57</span>,<span class="number">0xde</span>,<span class="number">0x4d</span>,<span class="number">0x9a</span>,<span class="number">0xea</span>,<span class="number">0x6a</span>,<span class="number">0x57</span>,<span class="number">0x57</span>,<span class="number">0xa2</span>,<span class="number">0x42</span>]</span><br><span class="line">w_o=[<span class="number">0x0e</span>,<span class="number">0xab</span>,<span class="number">0x9c</span>,<span class="number">0xab</span>,<span class="number">0x3e</span>,<span class="number">0x24</span>,<span class="number">0xab</span>,<span class="number">0x04</span>,<span class="number">0x24</span>,<span class="number">0x24</span>,<span class="number">0xb6</span>,<span class="number">0x16</span>,<span class="number">0x01</span>,<span class="number">0xb6</span>,<span class="number">0x1f</span>,<span class="number">0xa1</span>,<span class="number">0xfe</span>,<span class="number">0x90</span>]</span><br><span class="line">w_j=[<span class="number">0x01</span>,<span class="number">0x92</span>,<span class="number">0x24</span>,<span class="number">0x3a</span>,<span class="number">0xb6</span>,<span class="number">0xeb</span>,<span class="number">0xa1</span>,<span class="number">0x02</span>,<span class="number">0x1f</span>,<span class="number">0x24</span>,<span class="number">0xb6</span>,<span class="number">0x1f</span>,<span class="number">0xc4</span>,<span class="number">0xb6</span>,<span class="number">0xc5</span>,<span class="number">0x02</span>,<span class="number">0xeb</span>]</span><br><span class="line"><span class="comment">#n的偶数部分，34到0</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,<span class="number">70</span>,<span class="number">4</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;0x&quot;</span>,end=<span class="string">&quot;&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(enc_l[i],end=<span class="string">&quot;&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(enc_l[i+<span class="number">1</span>],end=<span class="string">&quot;&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;,&quot;</span>,end=<span class="string">&quot;&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;\n&quot;</span>)</span><br><span class="line"><span class="comment">#n的奇数部分，1到33</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>,<span class="number">70</span>,<span class="number">4</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;0x&quot;</span>,end=<span class="string">&quot;&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(enc_r[i],end=<span class="string">&quot;&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(enc_r[i+<span class="number">1</span>],end=<span class="string">&quot;&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;,&quot;</span>,end=<span class="string">&quot;&quot;</span>)</span><br><span class="line"><span class="comment">#w的奇数部分，33到1,</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;\n&quot;</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>,<span class="number">70</span>,<span class="number">4</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;0x&quot;</span>,end=<span class="string">&quot;&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(enc_l[i],end=<span class="string">&quot;&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(enc_l[i+<span class="number">1</span>],end=<span class="string">&quot;&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;,&quot;</span>,end=<span class="string">&quot;&quot;</span>)</span><br><span class="line"><span class="comment">#w的偶数部分 ,0到34</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;\n&quot;</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,<span class="number">70</span>,<span class="number">4</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;0x&quot;</span>,end=<span class="string">&quot;&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(enc_r[i],end=<span class="string">&quot;&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(enc_r[i+<span class="number">1</span>],end=<span class="string">&quot;&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;,&quot;</span>,end=<span class="string">&quot;&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;\n&quot;</span>)</span><br><span class="line">n=[]</span><br><span class="line">w=[]</span><br><span class="line">j=<span class="number">17</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,<span class="number">17</span>):</span><br><span class="line">    n.append(n_o[j])</span><br><span class="line">    n.append(n_j[i])</span><br><span class="line">    j-=<span class="number">1</span></span><br><span class="line"><span class="built_in">print</span>(n)</span><br><span class="line">j=<span class="number">16</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">18</span>):</span><br><span class="line">    w.append(w_o[i])</span><br><span class="line">    w.append(w_j[j])</span><br><span class="line">    j-=<span class="number">1</span></span><br><span class="line"><span class="built_in">print</span>(w)</span><br><span class="line">_n = [<span class="number">106</span>, <span class="number">234</span>, <span class="number">127</span>, <span class="number">77</span>, <span class="number">66</span>, <span class="number">66</span>, <span class="number">127</span>, <span class="number">106</span>, <span class="number">164</span>, <span class="number">81</span>, <span class="number">87</span>, <span class="number">222</span>, <span class="number">127</span>,</span><br><span class="line">    <span class="number">106</span>, <span class="number">73</span>, <span class="number">87</span>, <span class="number">87</span>, <span class="number">222</span>, <span class="number">87</span>, <span class="number">77</span>, <span class="number">106</span>,</span><br><span class="line">    <span class="number">154</span>, <span class="number">234</span>, <span class="number">234</span>, <span class="number">66</span>, <span class="number">106</span>, <span class="number">106</span>, <span class="number">87</span>, <span class="number">222</span>, <span class="number">87</span>, <span class="number">154</span>, <span class="number">162</span>, <span class="number">73</span>, <span class="number">66</span>,<span class="number">234</span>]</span><br><span class="line">_w = [<span class="number">14</span>, <span class="number">235</span>, <span class="number">171</span>, <span class="number">2</span>, <span class="number">156</span>, <span class="number">197</span>, <span class="number">171</span>, <span class="number">182</span>, <span class="number">62</span>, <span class="number">196</span>, <span class="number">36</span>, <span class="number">31</span>, <span class="number">171</span>,</span><br><span class="line">    <span class="number">182</span>, <span class="number">4</span>, <span class="number">36</span>, <span class="number">36</span>, <span class="number">31</span>, <span class="number">36</span>, <span class="number">2</span>, <span class="number">182</span>,</span><br><span class="line">    <span class="number">161</span>, <span class="number">22</span>, <span class="number">235</span>, <span class="number">1</span>, <span class="number">182</span>, <span class="number">182</span>, <span class="number">58</span>, <span class="number">31</span>, <span class="number">36</span>, <span class="number">161</span>, <span class="number">146</span>, <span class="number">254</span>, <span class="number">1</span>, <span class="number">144</span>]</span><br></pre></td></tr></table></figure><p>代码有点乱，大概思路就是先把70个字符分成两部分，然后分别从左到右分离出下标奇数部分的n和w，下标偶数部分的w和n，然后把这些n和w排好顺序，分别交替输出得到n和w 的数组。</p><p>这个过程读者可以自行完成，我这个只是参考，而且感觉很慢。最后得到的_n和_w便是结果</p><p>（脚本里输出的n和w有些问题，分别多了一项和少了一项，笔者懒得去修正了然后手动修改了一下得到正确的n和w，然后这个_n和_w也是有些问题的，当时看题时把main.py里的下标是奇数时，n和w替换，看成了偶数时才替换，所以这里得到的_n其实是实际的w，_w是实际上的n，搞反了，不过万幸的是不影响后面的爆破，只要换一下就好了）</p><p>接下来把得到的n和w拿来爆破出c就可以组合成flag了，至福~</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">key1=[<span class="number">127</span>, <span class="number">81</span>, <span class="number">241</span>, <span class="number">40</span>, <span class="number">222</span>, <span class="number">128</span>, <span class="number">45</span>, <span class="number">87</span>, <span class="number">27</span>, <span class="number">154</span>,</span><br><span class="line">      <span class="number">66</span>,<span class="number">162</span>, <span class="number">73</span>, <span class="number">176</span>, <span class="number">172</span>, <span class="number">164</span>, <span class="number">106</span>, <span class="number">234</span>, <span class="number">77</span>, <span class="number">5</span>]</span><br><span class="line">key2=[<span class="number">155</span>, <span class="number">117</span>, <span class="number">124</span>, <span class="number">113</span>, <span class="number">104</span>, <span class="number">46</span>, <span class="number">151</span>, <span class="number">71</span>, <span class="number">144</span>, <span class="number">229</span>, <span class="number">152</span>, <span class="number">240</span>,</span><br><span class="line">      <span class="number">199</span>, <span class="number">88</span>, <span class="number">103</span>, <span class="number">105</span>, <span class="number">245</span>, <span class="number">209</span>, <span class="number">13</span>, <span class="number">82</span>, <span class="number">166</span>, <span class="number">9</span>, <span class="number">201</span>, <span class="number">233</span>, <span class="number">228</span>,</span><br><span class="line">      <span class="number">154</span>, <span class="number">19</span>, <span class="number">5</span>, <span class="number">30</span>, <span class="number">141</span>, <span class="number">81</span>, <span class="number">206</span>, <span class="number">246</span>, <span class="number">232</span>, <span class="number">107</span>, <span class="number">29</span>, <span class="number">208</span>, <span class="number">253</span>,</span><br><span class="line">      <span class="number">187</span>, <span class="number">116</span>, <span class="number">98</span>, <span class="number">160</span>, <span class="number">60</span>, <span class="number">7</span>, <span class="number">220</span>, <span class="number">143</span>, <span class="number">80</span>, <span class="number">239</span>, <span class="number">52</span>, <span class="number">15</span>, <span class="number">94</span>, <span class="number">50</span>,</span><br><span class="line">      <span class="number">149</span>, <span class="number">241</span>, <span class="number">57</span>, <span class="number">92</span>, <span class="number">230</span>, <span class="number">100</span>, <span class="number">31</span>, <span class="number">51</span>, <span class="number">36</span>, <span class="number">24</span>, <span class="number">39</span>, <span class="number">14</span>, <span class="number">25</span>, <span class="number">90</span>, <span class="number">101</span>,</span><br><span class="line">      <span class="number">55</span>, <span class="number">194</span>, <span class="number">225</span>, <span class="number">157</span>, <span class="number">102</span>, <span class="number">2</span>, <span class="number">26</span>, <span class="number">148</span>, <span class="number">161</span>, <span class="number">180</span>, <span class="number">120</span>, <span class="number">223</span>, <span class="number">165</span>, <span class="number">32</span>,</span><br><span class="line">      <span class="number">146</span>, <span class="number">185</span>, <span class="number">243</span>, <span class="number">119</span>, <span class="number">210</span>, <span class="number">172</span>, <span class="number">244</span>, <span class="number">1</span>, <span class="number">125</span>, <span class="number">44</span>, <span class="number">35</span>, <span class="number">169</span>, <span class="number">179</span>, <span class="number">188</span>,</span><br><span class="line">      <span class="number">64</span>, <span class="number">207</span>, <span class="number">33</span>, <span class="number">137</span>, <span class="number">200</span>, <span class="number">142</span>, <span class="number">182</span>, <span class="number">250</span>, <span class="number">195</span>, <span class="number">28</span>, <span class="number">4</span>, <span class="number">79</span>, <span class="number">191</span>, <span class="number">86</span>, <span class="number">215</span>,</span><br><span class="line">      <span class="number">96</span>, <span class="number">236</span>, <span class="number">91</span>, <span class="number">122</span>, <span class="number">196</span>, <span class="number">87</span>, <span class="number">118</span>, <span class="number">231</span>, <span class="number">126</span>, <span class="number">97</span>, <span class="number">147</span>, <span class="number">67</span>, <span class="number">132</span>, <span class="number">190</span>, <span class="number">234</span>,</span><br><span class="line">      <span class="number">237</span>, <span class="number">43</span>, <span class="number">193</span>, <span class="number">252</span>, <span class="number">18</span>, <span class="number">212</span>, <span class="number">163</span>, <span class="number">56</span>, <span class="number">73</span>, <span class="number">123</span>, <span class="number">176</span>, <span class="number">162</span>, <span class="number">23</span>, <span class="number">192</span>, <span class="number">49</span>,</span><br><span class="line">      <span class="number">21</span>, <span class="number">242</span>, <span class="number">171</span>, <span class="number">112</span>, <span class="number">153</span>, <span class="number">238</span>, <span class="number">203</span>, <span class="number">134</span>, <span class="number">167</span>, <span class="number">93</span>, <span class="number">115</span>, <span class="number">95</span>, <span class="number">8</span>, <span class="number">12</span>, <span class="number">65</span>,</span><br><span class="line">      <span class="number">217</span>, <span class="number">248</span>, <span class="number">168</span>, <span class="number">219</span>, <span class="number">47</span>, <span class="number">211</span>, <span class="number">108</span>, <span class="number">76</span>, <span class="number">129</span>, <span class="number">145</span>, <span class="number">62</span>, <span class="number">156</span>, <span class="number">34</span>, <span class="number">218</span>, <span class="number">135</span>,</span><br><span class="line">      <span class="number">48</span>, <span class="number">70</span>, <span class="number">75</span>, <span class="number">3</span>, <span class="number">249</span>, <span class="number">72</span>, <span class="number">202</span>, <span class="number">133</span>, <span class="number">183</span>, <span class="number">38</span>, <span class="number">37</span>, <span class="number">227</span>, <span class="number">164</span>, <span class="number">173</span>, <span class="number">159</span>, <span class="number">251</span>,</span><br><span class="line">      <span class="number">0</span>, <span class="number">174</span>, <span class="number">54</span>, <span class="number">20</span>, <span class="number">136</span>, <span class="number">53</span>, <span class="number">138</span>, <span class="number">99</span>, <span class="number">226</span>, <span class="number">178</span>, <span class="number">42</span>, <span class="number">66</span>, <span class="number">150</span>, <span class="number">205</span>, <span class="number">204</span>, <span class="number">214</span>,</span><br><span class="line">      <span class="number">197</span>, <span class="number">235</span>, <span class="number">110</span>, <span class="number">216</span>, <span class="number">63</span>, <span class="number">45</span>, <span class="number">184</span>, <span class="number">74</span>, <span class="number">41</span>, <span class="number">177</span>, <span class="number">27</span>, <span class="number">69</span>, <span class="number">130</span>, <span class="number">89</span>, <span class="number">61</span>, <span class="number">247</span>,</span><br><span class="line">      <span class="number">255</span>, <span class="number">17</span>, <span class="number">254</span>, <span class="number">181</span>, <span class="number">131</span>, <span class="number">22</span>, <span class="number">224</span>, <span class="number">83</span>, <span class="number">189</span>, <span class="number">59</span>, <span class="number">114</span>, <span class="number">139</span>, <span class="number">111</span>,</span><br><span class="line">      <span class="number">68</span>, <span class="number">6</span>, <span class="number">84</span>,<span class="number">11</span>, <span class="number">127</span>, <span class="number">221</span>, <span class="number">106</span>, <span class="number">77</span>, <span class="number">109</span>, <span class="number">158</span>,</span><br><span class="line">      <span class="number">170</span>, <span class="number">16</span>, <span class="number">121</span>, <span class="number">222</span>, <span class="number">186</span>, <span class="number">10</span>, <span class="number">58</span>, <span class="number">175</span>, <span class="number">40</span>, <span class="number">128</span>, <span class="number">198</span>, <span class="number">78</span>, <span class="number">85</span>, <span class="number">213</span>, <span class="number">140</span>]</span><br><span class="line">x = <span class="number">3449711664888782790334923396354433085218951813669043815144799745483347584183883892868078716490762334737115401929391994359609927294549975954045314661787321463018287415952</span></span><br><span class="line">w=[<span class="number">106</span>, <span class="number">234</span>, <span class="number">127</span>, <span class="number">77</span>, <span class="number">66</span>, <span class="number">66</span>, <span class="number">127</span>, <span class="number">106</span>, <span class="number">164</span>, <span class="number">81</span>, <span class="number">87</span>, <span class="number">222</span>, <span class="number">127</span>,</span><br><span class="line">    <span class="number">106</span>, <span class="number">73</span>, <span class="number">87</span>, <span class="number">87</span>, <span class="number">222</span>, <span class="number">87</span>, <span class="number">77</span>, <span class="number">106</span>,</span><br><span class="line">    <span class="number">154</span>, <span class="number">234</span>, <span class="number">234</span>, <span class="number">66</span>, <span class="number">106</span>, <span class="number">106</span>, <span class="number">87</span>, <span class="number">222</span>, <span class="number">87</span>, <span class="number">154</span>, <span class="number">162</span>, <span class="number">73</span>, <span class="number">66</span>,<span class="number">234</span>]</span><br><span class="line">n=[<span class="number">14</span>, <span class="number">235</span>, <span class="number">171</span>, <span class="number">2</span>, <span class="number">156</span>, <span class="number">197</span>, <span class="number">171</span>, <span class="number">182</span>, <span class="number">62</span>, <span class="number">196</span>, <span class="number">36</span>, <span class="number">31</span>, <span class="number">171</span>,</span><br><span class="line">    <span class="number">182</span>, <span class="number">4</span>, <span class="number">36</span>, <span class="number">36</span>, <span class="number">31</span>, <span class="number">36</span>, <span class="number">2</span>, <span class="number">182</span>,</span><br><span class="line">    <span class="number">161</span>, <span class="number">22</span>, <span class="number">235</span>, <span class="number">1</span>, <span class="number">182</span>, <span class="number">182</span>, <span class="number">58</span>, <span class="number">31</span>, <span class="number">36</span>, <span class="number">161</span>, <span class="number">146</span>, <span class="number">254</span>, <span class="number">1</span>, <span class="number">144</span>]</span><br><span class="line">flag=<span class="string">&quot;&quot;</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">enc</span>(<span class="params">n</span>): <span class="comment">#加密函数</span></span><br><span class="line">    q = key2[n]</span><br><span class="line">    w = key1[q % <span class="number">20</span>]</span><br><span class="line">    n ^= q</span><br><span class="line">    <span class="keyword">return</span> n, w</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">35</span>):</span><br><span class="line">      <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">32</span>, <span class="number">127</span>):</span><br><span class="line">            a , b = enc(j)</span><br><span class="line">            <span class="keyword">if</span> a==n[i] <span class="keyword">and</span> b==w[i]:</span><br><span class="line">                  flag += <span class="built_in">chr</span>(j)</span><br><span class="line">                  <span class="keyword">break</span></span><br><span class="line"><span class="built_in">print</span>(flag)</span><br><span class="line"> </span><br><span class="line"> </span><br></pre></td></tr></table></figure><p>nbctf{cr15s_cr0ss_str4wb3rry_s4uz3}</p><h2 id="0x02-sands"><a href="#0x02-sands" class="headerlink" title="0x02 sands"></a>0x02 sands</h2><p>看介绍就知道是迷宫题目，打开ida分析一下</p><p><img src="Images/eb2a67a911f14049a4ce7c18044a2d9f-1706531980127-2.png" alt="eb2a67a911f14049a4ce7c18044a2d9f">个关键的语句，和普通迷宫不同的是，这个迷宫会有‘S’，沙子没回合都会根据step移动来阻挡你的路线，如果沙子移动后正好和你的位置重合，会直接导致游戏失败（逻辑是沙子先动人后动），因为沙子撞人的判断是人移动后的，所以在这个迷宫中，只要你在沙子撞到你后移动走，也是能继续游戏的，这个是关键，知道这个小技巧后走迷宫就简单许多了。</p><p>比赛时为了节省时间可以省去不必要的东西，只保留关键的能帮助解题的判断语句，赛后我把迷宫完善了不少，已经能当做一个小游戏玩了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="type">int</span> map[<span class="number">100</span>]=&#123;<span class="number">38</span>, <span class="number">35</span>, <span class="number">35</span>, <span class="number">35</span>, <span class="number">48</span>, <span class="number">48</span>, <span class="number">48</span>, <span class="number">48</span>, <span class="number">48</span>, <span class="number">35</span>,</span><br><span class="line">            <span class="number">48</span>, <span class="number">48</span>, <span class="number">35</span>, <span class="number">83</span>, <span class="number">48</span>, <span class="number">35</span>, <span class="number">35</span>, <span class="number">48</span>, <span class="number">48</span>, <span class="number">35</span>, <span class="number">35</span>,</span><br><span class="line">          <span class="number">48</span>, <span class="number">83</span>, <span class="number">35</span>, <span class="number">48</span>, <span class="number">35</span>, <span class="number">83</span>, <span class="number">83</span>, <span class="number">48</span>, <span class="number">35</span>, <span class="number">35</span>, <span class="number">48</span>,</span><br><span class="line">           <span class="number">48</span>, <span class="number">35</span>, <span class="number">48</span>, <span class="number">35</span>, <span class="number">48</span>, <span class="number">48</span>, <span class="number">35</span>, <span class="number">35</span>, <span class="number">48</span>, <span class="number">83</span>, <span class="number">48</span>, </span><br><span class="line">           <span class="number">35</span>, <span class="number">48</span>, <span class="number">35</span>, <span class="number">48</span>, <span class="number">83</span>, <span class="number">83</span>, <span class="number">48</span>, <span class="number">48</span>, <span class="number">35</span>, <span class="number">35</span>, <span class="number">35</span>, </span><br><span class="line">           <span class="number">48</span>, <span class="number">35</span>, <span class="number">48</span>, <span class="number">83</span>, <span class="number">48</span>, <span class="number">48</span>, <span class="number">48</span>, <span class="number">48</span>, <span class="number">48</span>, <span class="number">35</span>, <span class="number">48</span>,</span><br><span class="line">            <span class="number">35</span>, <span class="number">48</span>, <span class="number">48</span>, <span class="number">48</span>, <span class="number">83</span>, <span class="number">35</span>, <span class="number">35</span>, <span class="number">48</span>, <span class="number">35</span>, <span class="number">48</span>, <span class="number">35</span>, </span><br><span class="line">            <span class="number">35</span>, <span class="number">35</span>, <span class="number">35</span>, <span class="number">48</span>, <span class="number">48</span>, <span class="number">83</span>, <span class="number">48</span>, <span class="number">83</span>, <span class="number">48</span>, <span class="number">35</span>, <span class="number">48</span>,</span><br><span class="line">             <span class="number">48</span>, <span class="number">83</span>, <span class="number">48</span>, <span class="number">48</span>, <span class="number">48</span>, <span class="number">83</span>, <span class="number">48</span>, <span class="number">48</span>, <span class="number">35</span>, <span class="number">76</span>, <span class="number">83</span>, </span><br><span class="line">             <span class="number">48</span>, <span class="number">48</span>&#125;;</span><br><span class="line"><span class="type">int</span> i=<span class="number">0</span>,j=<span class="number">0</span>,step=<span class="number">0</span>;</span><br><span class="line"><span class="type">char</span> ch;</span><br><span class="line"><span class="type">char</span> step_arr[<span class="number">50</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="comment">//i是横坐标，j是纵坐标</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">move</span><span class="params">(<span class="type">char</span> ch)</span></span>&#123;</span><br><span class="line">    <span class="keyword">switch</span>(ch)&#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;a&#x27;</span>:</span><br><span class="line">            <span class="keyword">if</span>(i!=<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(map[<span class="number">10</span>*j+i<span class="number">-1</span>]==<span class="string">&#x27;0&#x27;</span>||map[<span class="number">10</span>*j+i<span class="number">-1</span>]==<span class="string">&#x27;L&#x27;</span>)&#123;</span><br><span class="line">                    map[<span class="number">10</span>*j+i<span class="number">-1</span>]=<span class="string">&#x27;&amp;&#x27;</span>;</span><br><span class="line">                    <span class="keyword">if</span>(map[<span class="number">10</span>*j+i]!=<span class="string">&#x27;S&#x27;</span>)&#123;</span><br><span class="line">                    map[<span class="number">10</span>*j+i]=<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line">                    i--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;d&#x27;</span>:</span><br><span class="line">            <span class="keyword">if</span>(i!=<span class="number">9</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(map[<span class="number">10</span>*j+i+<span class="number">1</span>]==<span class="string">&#x27;0&#x27;</span>||map[<span class="number">10</span>*j+i+<span class="number">1</span>]==<span class="string">&#x27;L&#x27;</span>)&#123;</span><br><span class="line">                    map[<span class="number">10</span>*j+i+<span class="number">1</span>]=<span class="string">&#x27;&amp;&#x27;</span>;</span><br><span class="line">                    <span class="keyword">if</span>(map[<span class="number">10</span>*j+i]!=<span class="string">&#x27;S&#x27;</span>)&#123;</span><br><span class="line">                    map[<span class="number">10</span>*j+i]=<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line">                    i++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;s&#x27;</span>:</span><br><span class="line">            <span class="keyword">if</span>(j!=<span class="number">9</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(map[<span class="number">10</span>*j+<span class="number">10</span>+i]==<span class="string">&#x27;0&#x27;</span>||map[<span class="number">10</span>*j+<span class="number">10</span>+i]==<span class="string">&#x27;L&#x27;</span>)&#123;</span><br><span class="line">                    map[<span class="number">10</span>*j+<span class="number">10</span>+i]=<span class="string">&#x27;&amp;&#x27;</span>;</span><br><span class="line">                    <span class="keyword">if</span>(map[<span class="number">10</span>*j+i]!=<span class="string">&#x27;S&#x27;</span>)&#123;</span><br><span class="line">                    map[<span class="number">10</span>*j+i]=<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line">                    j++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;w&#x27;</span>:</span><br><span class="line">            <span class="keyword">if</span>(j!=<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(map[<span class="number">10</span>*j<span class="number">-10</span>+i]==<span class="string">&#x27;0&#x27;</span>||map[<span class="number">10</span>*j+i<span class="number">-10</span>]==<span class="string">&#x27;L&#x27;</span>)&#123;</span><br><span class="line">                    map[<span class="number">10</span>*j<span class="number">-10</span>+i]=<span class="string">&#x27;&amp;&#x27;</span>;</span><br><span class="line">                    <span class="keyword">if</span>(map[<span class="number">10</span>*j+i]!=<span class="string">&#x27;S&#x27;</span>)&#123;</span><br><span class="line">                    map[<span class="number">10</span>*j+i]=<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line">                    j--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">set_map</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> k;</span><br><span class="line">    <span class="keyword">for</span>(k=<span class="number">0</span>;k&lt;<span class="number">100</span>;k++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(k%<span class="number">10</span>==<span class="number">0</span>)&#123;</span><br><span class="line">            std::cout&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>,map[k]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sand_move</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> x,y;</span><br><span class="line">    <span class="keyword">switch</span>(step%<span class="number">4</span>)&#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">            <span class="keyword">for</span>(x=<span class="number">9</span>;x&gt;=<span class="number">0</span>;x--)&#123;</span><br><span class="line">                <span class="keyword">for</span>(y=<span class="number">0</span>;y&lt;=<span class="number">9</span>;y++)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(map[<span class="number">10</span>*y+x]==<span class="string">&#x27;S&#x27;</span>&amp;&amp;x!=<span class="number">9</span>)&#123;</span><br><span class="line">                        <span class="keyword">if</span>(map[<span class="number">10</span>*y+x+<span class="number">1</span>]==<span class="string">&#x27;0&#x27;</span>||map[<span class="number">10</span>*y+x+<span class="number">1</span>]==<span class="string">&#x27;&amp;&#x27;</span>)&#123;</span><br><span class="line">                            map[<span class="number">10</span>*y+x+<span class="number">1</span>]=<span class="string">&#x27;S&#x27;</span>;</span><br><span class="line">                            map[<span class="number">10</span>*y+x]=<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">                        &#125;  </span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">            <span class="keyword">for</span>(y=<span class="number">0</span>;y&lt;=<span class="number">9</span>;y++)&#123;</span><br><span class="line">                <span class="keyword">for</span>(x=<span class="number">0</span>;x&lt;=<span class="number">9</span>;x++)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(map[<span class="number">10</span>*y+x]==<span class="string">&#x27;S&#x27;</span>&amp;&amp;y!=<span class="number">0</span>)&#123;</span><br><span class="line">                        <span class="keyword">if</span>(map[<span class="number">10</span>*y+x<span class="number">-10</span>]==<span class="string">&#x27;0&#x27;</span>||map[<span class="number">10</span>*y+x<span class="number">-10</span>]==<span class="string">&#x27;&amp;&#x27;</span>)&#123;</span><br><span class="line">                            map[<span class="number">10</span>*y+x<span class="number">-10</span>]=<span class="string">&#x27;S&#x27;</span>;</span><br><span class="line">                            map[<span class="number">10</span>*y+x]=<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">for</span>(x=<span class="number">0</span>;x&lt;=<span class="number">9</span>;x++)&#123;</span><br><span class="line">                <span class="keyword">for</span>(y=<span class="number">0</span>;y&lt;=<span class="number">9</span>;y++)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(map[<span class="number">10</span>*y+x]==<span class="string">&#x27;S&#x27;</span>&amp;&amp;x!=<span class="number">0</span>)&#123;</span><br><span class="line">                        <span class="keyword">if</span>(map[<span class="number">10</span>*y+x<span class="number">-1</span>]==<span class="string">&#x27;0&#x27;</span>||map[<span class="number">10</span>*y+x<span class="number">-1</span>]==<span class="string">&#x27;&amp;&#x27;</span>)&#123;</span><br><span class="line">                            map[<span class="number">10</span>*y+x<span class="number">-1</span>]=<span class="string">&#x27;S&#x27;</span>;</span><br><span class="line">                            map[<span class="number">10</span>*y+x]=<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">for</span>(y=<span class="number">9</span>;y&gt;=<span class="number">0</span>;y--)&#123;</span><br><span class="line">                <span class="keyword">for</span>(x=<span class="number">0</span>;x&lt;=<span class="number">9</span>;x++)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(map[<span class="number">10</span>*y+x]==<span class="string">&#x27;S&#x27;</span>&amp;&amp;y!=<span class="number">9</span>)&#123;</span><br><span class="line">                        <span class="keyword">if</span>(map[<span class="number">10</span>*y+x+<span class="number">10</span>]==<span class="string">&#x27;0&#x27;</span>||map[<span class="number">10</span>/y+x+<span class="number">10</span>]==<span class="string">&#x27;&amp;&#x27;</span>)&#123;</span><br><span class="line">                            map[<span class="number">10</span>*y+x+<span class="number">10</span>]=<span class="string">&#x27;S&#x27;</span>;</span><br><span class="line">                            map[<span class="number">10</span>*y+x]=<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;  </span><br><span class="line">    <span class="keyword">while</span>(step&lt;=<span class="number">49</span>&amp;&amp;map[<span class="number">10</span>*j+i]!=<span class="string">&#x27;S&#x27;</span>)&#123;</span><br><span class="line">        <span class="built_in">set_map</span>();</span><br><span class="line">        std::cout&lt;&lt;<span class="string">&quot;\n&quot;</span>&lt;&lt;<span class="string">&quot;step:&quot;</span>&lt;&lt;step;</span><br><span class="line">        std::cout&lt;&lt;<span class="string">&quot;\n&quot;</span>&lt;&lt;<span class="string">&quot;sand de is &quot;</span>&lt;&lt;(step%<span class="number">4</span>);</span><br><span class="line">        std::cout&lt;&lt;<span class="string">&quot;\n&quot;</span>&lt;&lt;<span class="string">&quot;(0是下移动,1是左移动,2是上移动,3是右移动)&quot;</span>;</span><br><span class="line">        std::cout&lt;&lt;<span class="string">&quot;\n&quot;</span>&lt;&lt;<span class="string">&quot;enter your direcation:&quot;</span>;</span><br><span class="line">std::cin&gt;&gt;ch;</span><br><span class="line">        <span class="built_in">sand_move</span>();</span><br><span class="line">        step_arr[step]=ch;</span><br><span class="line">        step++;</span><br><span class="line">        <span class="built_in">move</span>(ch);</span><br><span class="line">        <span class="keyword">if</span>(j==<span class="number">9</span>&amp;&amp;i==<span class="number">6</span>)&#123;</span><br><span class="line">        std::cout&lt;&lt;<span class="string">&quot;yep&quot;</span>&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> l=<span class="number">0</span>;l&lt;step;l++)&#123;</span><br><span class="line">            std::cout&lt;&lt;step_arr[l];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样很浪费时间，不过赛后无所谓了。</p><p>然后这题还要连一下官方给的靶机，在linux虚拟机里面的命令行打入</p><p>nc 【ip】【端口】</p><p>连接成功后ls罗列一下文件，cat可以查看文件</p><h2 id="0x03-twostep"><a href="#0x03-twostep" class="headerlink" title="0x03 twostep"></a>0x03 twostep</h2><p>这个题的逻辑就是反复调用两个不同的函数，然后分块加密，函数1中有几个子函数，每个子函数加密一块，函数2同理，然后调用法则是函数1到函数2，函数2再到函数1，每次调用时step（计数器）+1，然后case不同的step分块加密，最后根据一个数组word_404090[]知道这个加密块在整体flag具体的位置</p><p><img src="Images/850be99663a24e22ba85483570b7924e-1706532051009-5.png" alt="850be99663a24e22ba85483570b7924e"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#472036518</span><br><span class="line">#123456789</span><br></pre></td></tr></table></figure><p>下面是步数step，上面是位置。</p><p>函数1</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line">__int64 __fastcall <span class="title function_">encry1</span><span class="params">(_BYTE *input)</span></span><br><span class="line">&#123;</span><br><span class="line">  __int64 result; <span class="comment">// rax</span></span><br><span class="line">  <span class="type">char</span> one; <span class="comment">// [rsp+19h] [rbp-A7h]</span></span><br><span class="line">  __int16 v3; <span class="comment">// [rsp+1Ah] [rbp-A6h]</span></span><br><span class="line">  __int16 v4; <span class="comment">// [rsp+1Ch] [rbp-A4h]</span></span><br><span class="line">  __int16 v5; <span class="comment">// [rsp+1Eh] [rbp-A2h]</span></span><br><span class="line">  <span class="type">unsigned</span> __int64 i; <span class="comment">// [rsp+20h] [rbp-A0h]</span></span><br><span class="line">  <span class="type">unsigned</span> __int64 k; <span class="comment">// [rsp+20h] [rbp-A0h]</span></span><br><span class="line">  __int64 v8; <span class="comment">// [rsp+20h] [rbp-A0h]</span></span><br><span class="line">  <span class="type">unsigned</span> __int64 m; <span class="comment">// [rsp+20h] [rbp-A0h]</span></span><br><span class="line">  <span class="type">unsigned</span> __int64 j; <span class="comment">// [rsp+28h] [rbp-98h]</span></span><br><span class="line">  _BYTE *v11; <span class="comment">// [rsp+30h] [rbp-90h]</span></span><br><span class="line">  _BYTE *v12; <span class="comment">// [rsp+30h] [rbp-90h]</span></span><br><span class="line">  _BYTE *v13; <span class="comment">// [rsp+30h] [rbp-90h]</span></span><br><span class="line">  __int16 v14[<span class="number">4</span>]; <span class="comment">// [rsp+38h] [rbp-88h]</span></span><br><span class="line">  __int64 v15[<span class="number">6</span>]; <span class="comment">// [rsp+40h] [rbp-80h]</span></span><br><span class="line">  __int64 v16[<span class="number">8</span>]; <span class="comment">// [rsp+70h] [rbp-50h]</span></span><br><span class="line">  __int16 v17; <span class="comment">// [rsp+B6h] [rbp-Ah]</span></span><br><span class="line">  <span class="type">unsigned</span> __int64 v18; <span class="comment">// [rsp+B8h] [rbp-8h] 472036518</span></span><br><span class="line">                        <span class="comment">//                    123456789</span></span><br><span class="line"> </span><br><span class="line">  v18 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  v14[<span class="number">0</span>] = <span class="number">0x4808</span>;</span><br><span class="line">  v14[<span class="number">1</span>] = <span class="number">0xC40</span>;</span><br><span class="line">  v14[<span class="number">2</span>] = <span class="number">0x480C</span>;</span><br><span class="line">  v14[<span class="number">3</span>] = <span class="number">0x408C</span>;</span><br><span class="line">  v16[<span class="number">0</span>] = <span class="number">1LL</span>;</span><br><span class="line">  v16[<span class="number">1</span>] = <span class="number">16LL</span>;</span><br><span class="line">  v16[<span class="number">2</span>] = <span class="number">32LL</span>;</span><br><span class="line">  v16[<span class="number">3</span>] = <span class="number">512LL</span>;</span><br><span class="line">  v16[<span class="number">4</span>] = <span class="number">1024LL</span>;</span><br><span class="line">  v16[<span class="number">5</span>] = <span class="number">2048LL</span>;</span><br><span class="line">  v16[<span class="number">6</span>] = <span class="number">0x2000</span>LL;</span><br><span class="line">  v16[<span class="number">7</span>] = <span class="number">0x4000</span>LL;</span><br><span class="line">  v15[<span class="number">0</span>] = <span class="number">177LL</span>;</span><br><span class="line">  v15[<span class="number">1</span>] = <span class="number">166LL</span>;</span><br><span class="line">  v15[<span class="number">2</span>] = <span class="number">183LL</span>;</span><br><span class="line">  v15[<span class="number">3</span>] = <span class="number">182LL</span>;</span><br><span class="line">  v15[<span class="number">4</span>] = <span class="number">177LL</span>;</span><br><span class="line">  v15[<span class="number">5</span>] = <span class="number">0xAD</span>LL;</span><br><span class="line">  v17 = <span class="number">170</span>;</span><br><span class="line">  <span class="keyword">switch</span> ( step )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0LL</span>:</span><br><span class="line">      <span class="keyword">if</span> ( *input == <span class="string">&#x27;n&#x27;</span> &amp;&amp; input[<span class="number">1</span>] == <span class="string">&#x27;b&#x27;</span> &amp;&amp; input[<span class="number">2</span>] == <span class="string">&#x27;c&#x27;</span> &amp;&amp; input[<span class="number">3</span>] == <span class="string">&#x27;t&#x27;</span> &amp;&amp; input[<span class="number">4</span>] == <span class="string">&#x27;f&#x27;</span> &amp;&amp; input[<span class="number">5</span>] == <span class="string">&#x27;&#123;&#x27;</span> )</span><br><span class="line">        result = encry2(input + <span class="number">6</span>);             <span class="comment">// step=0</span></span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        result = <span class="number">0LL</span>;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1LL</span>:</span><br><span class="line">      v11 = step_change(input);</span><br><span class="line">      <span class="keyword">for</span> ( i = <span class="number">0LL</span>; i &lt;= <span class="number">3</span>; ++i )              <span class="comment">// step=2</span></span><br><span class="line">      &#123;</span><br><span class="line">        one = v11[i];</span><br><span class="line">        v4 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> ( j = <span class="number">0LL</span>; j &lt;= <span class="number">3</span>; ++j )</span><br><span class="line">        &#123;</span><br><span class="line">          v4 |= (one &amp; <span class="number">3</span>) &lt;&lt; (<span class="number">4</span> * j + <span class="number">2</span>);</span><br><span class="line">          one &gt;&gt;= <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> ( v4 != v14[i] )</span><br><span class="line">          <span class="keyword">return</span> <span class="number">0LL</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      result = encry2(input);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">3LL</span>:</span><br><span class="line">      v12 = step_change(input);</span><br><span class="line">      <span class="keyword">for</span> ( k = <span class="number">0LL</span>; k &lt;= <span class="number">4</span>; ++k )              <span class="comment">// step=4</span></span><br><span class="line">        v100[k] = v12[k];</span><br><span class="line">      result = encry2(input);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">6LL</span>:</span><br><span class="line">      v3 = *step_change(input);</span><br><span class="line">      v8 = <span class="number">0LL</span>;                                 <span class="comment">// step=7</span></span><br><span class="line">      <span class="keyword">while</span> ( v3 )</span><br><span class="line">      &#123;</span><br><span class="line">        v5 = v3 &amp; -v3;                          <span class="comment">// 等于1</span></span><br><span class="line">        <span class="keyword">if</span> ( v8 == <span class="number">8</span> )</span><br><span class="line">          <span class="keyword">return</span> <span class="number">0LL</span>;</span><br><span class="line">        <span class="keyword">if</span> ( v16[v8] == v5 )</span><br><span class="line">          ++v8;</span><br><span class="line">        v3 ^= v5;</span><br><span class="line">      &#125;</span><br><span class="line">      result = v8 == <span class="number">8</span> &amp;&amp; encry2(input);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">8LL</span>:</span><br><span class="line">      v13 = step_change(input);</span><br><span class="line">      <span class="keyword">for</span> ( m = <span class="number">0LL</span>; m &lt;= <span class="number">5</span>; ++m )              <span class="comment">// step=9</span></span><br><span class="line">        LOBYTE(v17) = v13[m] ^ v15[m];          <span class="comment">// 去调试找找v17是多少</span></span><br><span class="line">      result = <span class="number">1LL</span>;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      result = <span class="number">0LL</span>;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>函数2</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line">__int64 __fastcall <span class="title function_">encry2</span><span class="params">(_BYTE *input)</span></span><br><span class="line">&#123;</span><br><span class="line">  __int64 result; <span class="comment">// rax</span></span><br><span class="line">  <span class="type">unsigned</span> __int64 i; <span class="comment">// [rsp+18h] [rbp-E8h]</span></span><br><span class="line">  <span class="type">unsigned</span> __int64 j; <span class="comment">// [rsp+18h] [rbp-E8h]</span></span><br><span class="line">  <span class="type">unsigned</span> __int64 k; <span class="comment">// [rsp+18h] [rbp-E8h]</span></span><br><span class="line">  __int64 v5; <span class="comment">// [rsp+20h] [rbp-E0h]</span></span><br><span class="line">  _BYTE *v6; <span class="comment">// [rsp+28h] [rbp-D8h]</span></span><br><span class="line">  _BYTE *v7; <span class="comment">// [rsp+28h] [rbp-D8h]</span></span><br><span class="line">  _BYTE *v8; <span class="comment">// [rsp+28h] [rbp-D8h]</span></span><br><span class="line">  _BYTE *v9; <span class="comment">// [rsp+28h] [rbp-D8h]</span></span><br><span class="line">  __int64 v10[<span class="number">6</span>]; <span class="comment">// [rsp+30h] [rbp-D0h]</span></span><br><span class="line">  __int64 v11[<span class="number">6</span>]; <span class="comment">// [rsp+60h] [rbp-A0h]</span></span><br><span class="line">  __int64 v12[<span class="number">6</span>]; <span class="comment">// [rsp+90h] [rbp-70h]</span></span><br><span class="line">  __int64 v13[<span class="number">8</span>]; <span class="comment">// [rsp+C0h] [rbp-40h] 472036518</span></span><br><span class="line">                  <span class="comment">//                     123456789</span></span><br><span class="line"> </span><br><span class="line">  v13[<span class="number">7</span>] = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  v13[<span class="number">0</span>] = <span class="number">54515LL</span>;</span><br><span class="line">  v13[<span class="number">1</span>] = <span class="number">15689LL</span>;</span><br><span class="line">  v13[<span class="number">2</span>] = <span class="number">4219LL</span>;</span><br><span class="line">  v13[<span class="number">3</span>] = <span class="number">50297LL</span>;</span><br><span class="line">  v13[<span class="number">4</span>] = <span class="number">43652LL</span>;</span><br><span class="line">  v13[<span class="number">5</span>] = <span class="number">38919LL</span>;</span><br><span class="line">  v10[<span class="number">0</span>] = <span class="number">14668LL</span>;</span><br><span class="line">  v10[<span class="number">1</span>] = <span class="number">24063LL</span>;</span><br><span class="line">  v10[<span class="number">2</span>] = <span class="number">37349LL</span>;</span><br><span class="line">  v10[<span class="number">3</span>] = <span class="number">50716LL</span>;</span><br><span class="line">  v10[<span class="number">4</span>] = <span class="number">61563LL</span>;</span><br><span class="line">  v11[<span class="number">0</span>] = <span class="number">1843061LL</span>;</span><br><span class="line">  v11[<span class="number">1</span>] = <span class="number">222420LL</span>;</span><br><span class="line">  v11[<span class="number">2</span>] = <span class="number">5184810LL</span>;</span><br><span class="line">  v11[<span class="number">3</span>] = <span class="number">4590105LL</span>;</span><br><span class="line">  v11[<span class="number">4</span>] = <span class="number">2184197LL</span>;</span><br><span class="line">  v5 = <span class="number">0LL</span>;</span><br><span class="line">  v12[<span class="number">0</span>] = <span class="number">1073741834LL</span>;</span><br><span class="line">  v12[<span class="number">1</span>] = <span class="number">2415919110LL</span>;</span><br><span class="line">  v12[<span class="number">2</span>] = <span class="number">939524099LL</span>;</span><br><span class="line">  v12[<span class="number">3</span>] = <span class="number">536870913LL</span>;</span><br><span class="line">  v12[<span class="number">4</span>] = <span class="number">1845493760LL</span>;</span><br><span class="line">  <span class="keyword">switch</span> ( step )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0LL</span>:</span><br><span class="line">      v6 = step_change(input);</span><br><span class="line">      <span class="keyword">if</span> ( (*v6 ^ <span class="number">95</span>) == v6[<span class="number">1</span>]                  <span class="comment">// step=1</span></span><br><span class="line">        &amp;&amp; (v6[<span class="number">1</span>] ^ <span class="number">117</span>) == v6[<span class="number">2</span>]</span><br><span class="line">        &amp;&amp; (v6[<span class="number">2</span>] ^ <span class="number">18</span>) == v6[<span class="number">3</span>]</span><br><span class="line">        &amp;&amp; (v6[<span class="number">3</span>] ^ <span class="number">56</span>) == *v6</span><br><span class="line">        &amp;&amp; *v6 == <span class="number">108</span> )</span><br><span class="line">      &#123;</span><br><span class="line">        result = encry1(input);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">      &#123;</span><br><span class="line">        result = <span class="number">0LL</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">2LL</span>:</span><br><span class="line">      v7 = step_change(input);</span><br><span class="line">      <span class="keyword">for</span> ( i = <span class="number">0LL</span>; i &lt;= <span class="number">4</span>; ++i )              <span class="comment">// step=3</span></span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">if</span> ( v13[i] + v13[i + <span class="number">1</span>] * v7[i] != v11[i] )</span><br><span class="line">          <span class="keyword">return</span> <span class="number">0LL</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      result = encry1(input);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">4LL</span>:</span><br><span class="line">      v8 = step_change(input);</span><br><span class="line">      <span class="keyword">for</span> ( j = <span class="number">0LL</span>; j &lt;= <span class="number">4</span>; ++j )              <span class="comment">// step=5</span></span><br><span class="line">      &#123;</span><br><span class="line">        v5 += v100[j] + (v8[j] &lt;&lt; <span class="number">7</span>);</span><br><span class="line">        <span class="keyword">if</span> ( v5 != v10[j] )</span><br><span class="line">          <span class="keyword">return</span> <span class="number">0LL</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      result = encry2(input);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">5LL</span>:</span><br><span class="line">      v9 = step_change(input);</span><br><span class="line">      <span class="keyword">for</span> ( k = <span class="number">0LL</span>; k &lt;= <span class="number">4</span>; ++k )              <span class="comment">// step=6</span></span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">if</span> ( v12[k] != ((v9[k] &gt;&gt; (k + <span class="number">3</span>)) | (v9[k] &lt;&lt; (<span class="number">32</span> - (k + <span class="number">3</span>)))) )</span><br><span class="line">          <span class="keyword">return</span> <span class="number">0LL</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      result = encry1(input);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">7LL</span>:</span><br><span class="line">      qword_404308 = *step_change(input);</span><br><span class="line">      result = *&amp;qword_404308 == <span class="number">3.325947034342098e151</span> &amp;&amp; encry1(input);<span class="comment">// step=8</span></span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      result = <span class="number">0LL</span>;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>大概思路就是这样，剩下逐个攻破加密块，按照word_404090里一一对应的关系排列组合，就能得出flag了。（调试太痛苦了，最后不调试还不知道，摆了）</p>]]></content>
      
      
      <categories>
          
          <category> Re-wp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基础 </tag>
            
            <tag> 逆向 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CPP类的基础</title>
      <link href="/2024/01/29/cpp%E7%B1%BB%E5%9F%BA%E7%A1%80/"/>
      <url>/2024/01/29/cpp%E7%B1%BB%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<h2 id="构造函数和析构函数"><a href="#构造函数和析构函数" class="headerlink" title="构造函数和析构函数"></a>构造函数和析构函数</h2><p>函数名和类名相同，有参数，构造函数创建对象时会自动调用且只调用一次，而析构函数在对象销毁前会自动调用一次，这两个函数是必需的，如果不手动设置，编译器会自动设置</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//构造函数</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Person</span>()&#123;</span><br><span class="line">std::cout&lt;&lt;<span class="string">&quot;OK&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//析构函数 </span></span><br><span class="line">~<span class="built_in">Person</span>()&#123;</span><br><span class="line">std::cout&lt;&lt;<span class="string">&quot;OK&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;; </span><br></pre></td></tr></table></figure><h2 id="构造函数的分类"><a href="#构造函数的分类" class="headerlink" title="构造函数的分类"></a>构造函数的分类</h2><p>默认无参构造函数，有参构造函数，拷贝构造函数</p><p>调用方法有括号法显示法和隐式转化法</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Person</span>()&#123;</span><br><span class="line"><span class="comment">//无参 </span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">Person</span>(<span class="type">int</span> a)&#123;</span><br><span class="line"><span class="comment">//有参 </span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">Person</span>(<span class="type">const</span> Person &amp;p)&#123;</span><br><span class="line"><span class="comment">//拷贝 </span></span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//调用 </span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test1</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//括号法 </span></span><br><span class="line"><span class="comment">//默认构造不要加括号()，编译器会误以为是函数的声明 </span></span><br><span class="line">Person p1;</span><br><span class="line"><span class="function">Person <span class="title">p2</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line"><span class="function">Person <span class="title">p3</span><span class="params">(p2)</span></span>;</span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test2</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//显示法</span></span><br><span class="line">Person p1;</span><br><span class="line">Person p2=<span class="built_in">Person</span>(<span class="number">10</span>);</span><br><span class="line">Person p3=<span class="built_in">Person</span>(p2);</span><br><span class="line"></span><br><span class="line"><span class="built_in">Person</span>(<span class="number">10</span>)<span class="comment">//匿名对象，当前行执行完后自动回收</span></span><br><span class="line"><span class="comment">//注意：不要用拷贝构造函数初始化匿名对象 </span></span><br><span class="line"><span class="comment">//编译器会认为Person(p3)===Person p3，对象重定义 </span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test3</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//隐式转化法 </span></span><br><span class="line">Person p4 =<span class="number">10</span>;<span class="comment">//相当于Person p4 =Perosn(10)</span></span><br><span class="line">Person p5 = p4;<span class="comment">//相当于拷贝 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="拷贝函数的调用时机"><a href="#拷贝函数的调用时机" class="headerlink" title="拷贝函数的调用时机"></a>拷贝函数的调用时机</h2><p>使用一个已经创建完毕的对象来初始化一个新对象</p><p>值传递的方式给函数参数传值</p><p>值传递的方式返回局部对象</p><h2 id="构造函数调用规则"><a href="#构造函数调用规则" class="headerlink" title="构造函数调用规则"></a>构造函数调用规则</h2><p>C++至少给一个类添加三个函数</p><p>默认构造函数，默认析构函数，默认拷贝构造函数</p><p>若定义了有参构造函数，则不会默认添加无参构造函数，但有拷贝构造函数</p><p>若定义了拷贝构造函数，c++不会添加其他构造函数</p><h2 id="深拷贝与浅拷贝"><a href="#深拷贝与浅拷贝" class="headerlink" title="深拷贝与浅拷贝"></a>深拷贝与浅拷贝</h2><p>浅拷贝：简单的赋值拷贝操作</p><p>深拷贝：在堆区重新申请空间，进行拷贝操作</p><h2 id="初始化列表"><a href="#初始化列表" class="headerlink" title="初始化列表"></a>初始化列表</h2><p>构造函数（）：属性1（值1），属性2（值2）…… { … }</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Person</span>():<span class="built_in">m_a</span>(<span class="number">10</span>),<span class="built_in">m_b</span>(<span class="number">20</span>),<span class="built_in">m_c</span>(<span class="number">30</span>)&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//另一种 </span></span><br><span class="line"><span class="built_in">Person</span>(<span class="type">int</span> a,<span class="type">int</span> b,<span class="type">int</span> c):<span class="built_in">m_a</span>(a),<span class="built_in">m_b</span>(b),<span class="built_in">m_c</span>(c)&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//普通的 </span></span><br><span class="line"><span class="built_in">Person</span>(<span class="type">int</span> a,<span class="type">int</span> b, <span class="type">int</span> c)&#123;</span><br><span class="line">ma=a;</span><br><span class="line">mb=b;</span><br><span class="line">mc=c;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> ma,mb,mc;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">Person p;</span><br><span class="line"><span class="function">Person <span class="title">p</span><span class="params">(<span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>)</span></span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="其他类对象作为本类的成员"><a href="#其他类对象作为本类的成员" class="headerlink" title="其他类对象作为本类的成员"></a>其他类对象作为本类的成员</h2><p>其他类对象作为本类的成员时，先有其他类对象的构造函数，再有自身的构造函数</p><p>先有自身的析构，再有其他类对象的析构</p><h2 id="静态成员"><a href="#静态成员" class="headerlink" title="静态成员"></a>静态成员</h2><p>加上关键字static</p><h3 id="静态成员变量"><a href="#静态成员变量" class="headerlink" title="静态成员变量"></a>静态成员变量</h3><p>在编译阶段分配内存，程序还未运行就已经有内存，全局区的内存</p><p>需要在类内声明，然后在类外初始化</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">//类内声明 </span></span><br><span class="line"><span class="type">static</span> A;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//类外初始化 </span></span><br><span class="line"><span class="type">int</span> Person::A=<span class="number">100</span>;</span><br></pre></td></tr></table></figure><p>所有对象共享一份数据</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//静态成员变量不属于某个对象</span></span><br><span class="line"><span class="comment">//可以通过对象或者类名访问</span></span><br><span class="line">Person p;</span><br><span class="line">std::cout&lt;&lt;p.A&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">std::cout&lt;&lt;Person::A&lt;&lt;endl; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="静态成员函数"><a href="#静态成员函数" class="headerlink" title="静态成员函数"></a>静态成员函数</h3><p>所有对象共享一个函数（与成员变量访问方式一样）</p><p>通过静态成员函数只能访问静态成员变量</p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基础 </tag>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
  
  
    
    
    <entry>
      <title>关于</title>
      <link href="/about/index.html"/>
      <url>/about/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/css/universe.css"/>
      <url>/css/universe.css</url>
      
        <content type="html"><![CDATA[/*样式页面调节*/:root {  --trans-light: rgba(255, 255, 255, 0.75);  --trans-dark: rgba(25, 25, 25, 0.6);  --border-style: 1px solid rgb(169, 169, 169);  /*blur(5px) saturate(150%)*/  --backdrop-filter: none;}/* 背景宇宙星光  */#universe{    display: block;    position: fixed;    margin: 0;    padding: 0;    border: 0;    outline: 0;    left: 0;    top: 0;    width: 100%;    height: 100%;    pointer-events: none;    /* 这个是调置顶的优先级的，-1在文章页下面，背景上面，个人推荐这种 */    z-index: -1;  }  /* 翻页按钮居中 */#pagination {    width: 100%;    margin: auto;  }    /* 一级菜单居中 */#nav .menus_items {  position: absolute !important;  width: fit-content !important;  left: 50% !important;  transform: translateX(-50%) !important;}/* 子菜单横向展示 */#nav .menus_items .menus_item:hover .menus_item_child {  display: flex !important;}/* 这里的2是代表导航栏的第2个元素，即有子菜单的元素，可以按自己需求修改 */.menus_items .menus_item:nth-child(5) .menus_item_child {  left: -38px;}/* 首页文章卡片 */#recent-posts > .recent-post-item {  background: var(--trans-light);  backdrop-filter: var(--backdrop-filter);  border-radius: 25px;  border: var(--border-style);}/* 首页侧栏卡片 */#aside-content .card-widget {  background: var(--trans-light);  backdrop-filter: var(--backdrop-filter);  border-radius: 18px;  border: var(--border-style);}/* 文章页、归档页、普通页面 */div#post,div#page,div#archive {  background: var(--trans-light);  backdrop-filter: var(--backdrop-filter);  border: var(--border-style);  border-radius: 20px;}/* 导航栏 */#page-header.nav-fixed #nav {  background: rgba(255, 255, 255, 0.75);  backdrop-filter: var(--backdrop-filter);}[data-theme="dark"] #page-header.nav-fixed #nav {  background: rgba(0, 0, 0, 0.7) !important;}/* 夜间模式遮罩 */[data-theme="dark"] #recent-posts > .recent-post-item,[data-theme="dark"] #aside-content .card-widget,[data-theme="dark"] div#post,[data-theme="dark"] div#archive,[data-theme="dark"] div#page {  background: var(--trans-dark);}/* 夜间模式页脚页头遮罩透明 */[data-theme="dark"] #footer::before {  background: transparent !important;}[data-theme="dark"] #page-header::before {  background: transparent !important;}/* 阅读模式 */.read-mode #aside-content .card-widget {  background: rgba(158, 204, 171, 0.5) !important;}.read-mode div#post {  background: rgba(158, 204, 171, 0.5) !important;}/* 夜间模式下的阅读模式 */[data-theme="dark"] .read-mode #aside-content .card-widget {  background: rgba(25, 25, 25, 0.9) !important;  color: #ffffff;}[data-theme="dark"] .read-mode div#post {  background: rgba(25, 25, 25, 0.9) !important;  color: #ffffff;}/* 页脚与头图透明 */#footer {  background: transparent !important;}#page-header {  background: transparent !important;}/* 白天模式遮罩透明 */#footer::before {  background: transparent !important;}#page-header::before {  background: transparent !important;}/* 夜间模式遮罩透明 */[data-theme="dark"] #footer::before {  background: transparent !important;}[data-theme="dark"] #page-header::before {  background: transparent !important;}]]></content>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/css/custom.css"/>
      <url>/css/custom.css</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>分类</title>
      <link href="/categories/index.html"/>
      <url>/categories/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>游戏</title>
      <link href="/games/index.html"/>
      <url>/games/index.html</url>
      
        <content type="html"><![CDATA[<h2 id="兰斯8攻略"><a href="#兰斯8攻略" class="headerlink" title="兰斯8攻略"></a>兰斯8攻略</h2><p><a href="https://www.bilibili.com/read/readlist/rl472073">【攻略】兰斯8完美图文攻略（整理版）</a></p>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>友链</title>
      <link href="/link/index.html"/>
      <url>/link/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>视频</title>
      <link href="/movies/index.html"/>
      <url>/movies/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/js/runtime.js"/>
      <url>/js/runtime.js</url>
      
        <content type="html"><![CDATA[setInterval(() => {  let create_time = Math.round(new Date('2024-01-28 00:00:00').getTime() / 1000); //在此行修改建站时间  let timestamp = Math.round((new Date().getTime()) / 1000);  let second = timestamp - create_time;  let time = new Array(0, 0, 0, 0, 0);  var nol = function(h){    return h>9?h:'0'+h;  }  if (second >= 365 * 24 * 3600) {    time[0] = parseInt(second / (365 * 24 * 3600));    second %= 365 * 24 * 3600;  }  if (second >= 24 * 3600) {    time[1] = parseInt(second / (24 * 3600));    second %= 24 * 3600;  }  if (second >= 3600) {    time[2] = nol(parseInt(second / 3600));    second %= 3600;  }  if (second >= 60) {    time[3] = nol(parseInt(second / 60));    second %= 60;  }  if (second > 0) {    time[4] = nol(second);  }  if ((Number(time[2])<22) && (Number(time[2])>7)){    currentTimeHtml ="<img class='boardsign' src='https://img.shields.io/badge/面包店-营业中-6adea8?style=social&logo=cakephp' title='要买一些新鲜美味的面包吗~'><div id='runtime'>" + time[0] + ' YEAR ' + time[1] + ' DAYS ' + time[2] + ' : ' + time[3] + ' : ' + time[4] + '</div>';  }  else{    currentTimeHtml ="<img class='boardsign' src='https://img.shields.io/badge/面包店-打烊了-6adea8?style=social&logo=coffeescript' title='这个点了应该去睡觉啦，熬夜对身体不好哦~'><div id='runtime'>" + time[0] + ' YEAR ' + time[1] + ' DAYS ' + time[2] + ' : ' + time[3] + ' : ' + time[4] + '</div>';  }  document.getElementById("workboard").innerHTML = currentTimeHtml;}, 1000);]]></content>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/js/universe.js"/>
      <url>/js/universe.js</url>
      
        <content type="html"><![CDATA[function dark() {window.requestAnimationFrame=window.requestAnimationFrame||window.mozRequestAnimationFrame||window.webkitRequestAnimationFrame||window.msRequestAnimationFrame;var n,e,i,h,t=.05,s=document.getElementById("universe"),o=!0,a="180,184,240",r="226,225,142",d="226,225,224",c=[];function f(){n=window.innerWidth,e=window.innerHeight,i=.216*n,s.setAttribute("width",n),s.setAttribute("height",e)}function u(){h.clearRect(0,0,n,e);for(var t=c.length,i=0;i<t;i++){var s=c[i];s.move(),s.fadeIn(),s.fadeOut(),s.draw()}}function y(){this.reset=function(){this.giant=m(3),this.comet=!this.giant&&!o&&m(10),this.x=l(0,n-10),this.y=l(0,e),this.r=l(1.1,2.6),this.dx=l(t,6*t)+(this.comet+1-1)*t*l(50,120)+2*t,this.dy=-l(t,6*t)-(this.comet+1-1)*t*l(50,120),this.fadingOut=null,this.fadingIn=!0,this.opacity=0,this.opacityTresh=l(.2,1-.4*(this.comet+1-1)),this.do=l(5e-4,.002)+.001*(this.comet+1-1)},this.fadeIn=function(){this.fadingIn&&(this.fadingIn=!(this.opacity>this.opacityTresh),this.opacity+=this.do)},this.fadeOut=function(){this.fadingOut&&(this.fadingOut=!(this.opacity<0),this.opacity-=this.do/2,(this.x>n||this.y<0)&&(this.fadingOut=!1,this.reset()))},this.draw=function(){if(h.beginPath(),this.giant)h.fillStyle="rgba("+a+","+this.opacity+")",h.arc(this.x,this.y,2,0,2*Math.PI,!1);else if(this.comet){h.fillStyle="rgba("+d+","+this.opacity+")",h.arc(this.x,this.y,1.5,0,2*Math.PI,!1);for(var t=0;t<30;t++)h.fillStyle="rgba("+d+","+(this.opacity-this.opacity/20*t)+")",h.rect(this.x-this.dx/4*t,this.y-this.dy/4*t-2,2,2),h.fill()}else h.fillStyle="rgba("+r+","+this.opacity+")",h.rect(this.x,this.y,this.r,this.r);h.closePath(),h.fill()},this.move=function(){this.x+=this.dx,this.y+=this.dy,!1===this.fadingOut&&this.reset(),(this.x>n-n/4||this.y<0)&&(this.fadingOut=!0)},setTimeout(function(){o=!1},50)}function m(t){return Math.floor(1e3*Math.random())+1<10*t}function l(t,i){return Math.random()*(i-t)+t}f(),window.addEventListener("resize",f,!1),function(){h=s.getContext("2d");for(var t=0;t<i;t++)c[t]=new y,c[t].reset();u()}(),function t(){document.getElementsByTagName('html')[0].getAttribute('data-theme')=='dark'&&u(),window.requestAnimationFrame(t)}()};dark()]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>音乐</title>
      <link href="/music/index.html"/>
      <url>/music/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>标签</title>
      <link href="/tags/index.html"/>
      <url>/tags/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
  
</search>
